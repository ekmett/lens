-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lenses, Folds and Traversals
--   
--   This package comes "Batteries Included" with many useful lenses for
--   the types commonly used from the Haskell Platform, and with tools for
--   automatically generating lenses and isomorphisms for user-supplied
--   data types.
--   
--   The combinators in <tt>Control.Lens</tt> provide a highly generic
--   toolbox for composing families of getters, folds, isomorphisms,
--   traversals, setters and lenses and their indexed variants.
--   
--   An overview, with a large number of examples can be found in the
--   <a>README</a>.
--   
--   An introductory video on the style of code used in this library by
--   Simon Peyton Jones is available from <a>Skills Matter</a>.
--   
--   A video on how to use lenses and how they are constructed is available
--   on <a>youtube</a>.
--   
--   Slides for that second talk can be obtained from <a>comonad.com</a>.
--   
--   More information on the care and feeding of lenses, including a brief
--   tutorial and motivation for their types can be found on the <a>lens
--   wiki</a>.
--   
--   A small game of <tt>pong</tt> and other more complex examples that
--   manage their state using lenses can be found in the <a>example
--   folder</a>.
--   
--   <i>Lenses, Folds and Traversals</i>
--   
--   With some signatures simplified, the core of the hierarchy of
--   lens-like constructions looks like:
--   
--   
--   <a>(Local Copy)</a>
--   
--   You can compose any two elements of the hierarchy above using
--   <tt>(.)</tt> from the <tt>Prelude</tt>, and you can use any element of
--   the hierarchy as any type it linked to above it.
--   
--   The result is their lowest upper bound in the hierarchy (or an error
--   if that bound doesn't exist).
--   
--   For instance:
--   
--   <ul>
--   <li>You can use any <a>Traversal</a> as a <a>Fold</a> or as a
--   <a>Setter</a>.</li>
--   <li>The composition of a <a>Traversal</a> and a <a>Getter</a> yields a
--   <a>Fold</a>.</li>
--   </ul>
--   
--   <i>Minimizing Dependencies</i>
--   
--   If you want to provide lenses and traversals for your own types in
--   your own libraries, then you can do so without incurring a dependency
--   on this (or any other) lens package at all.
--   
--   <i>e.g.</i> for a data type:
--   
--   <pre>
--   data Foo a = Foo Int Int a
--   </pre>
--   
--   You can define lenses such as
--   
--   <pre>
--   -- bar :: Lens' (Foo a) Int
--   bar :: Functor f =&gt; (Int -&gt; f Int) -&gt; Foo a -&gt; f (Foo a)
--   bar f (Foo a b c) = fmap (\a' -&gt; Foo a' b c) (f a)
--   </pre>
--   
--   <pre>
--   -- quux :: Lens (Foo a) (Foo b) a b
--   quux :: Functor f =&gt; (a -&gt; f b) -&gt; Foo a -&gt; f (Foo b)
--   quux f (Foo a b c) = fmap (Foo a b) (f c)
--   </pre>
--   
--   without the need to use any type that isn't already defined in the
--   <tt>Prelude</tt>.
--   
--   And you can define a traversal of multiple fields with
--   <a>Control.Applicative.Applicative</a>:
--   
--   <pre>
--   -- traverseBarAndBaz :: Traversal' (Foo a) Int
--   traverseBarAndBaz :: Applicative f =&gt; (Int -&gt; f Int) -&gt; Foo a -&gt; f (Foo a)
--   traverseBarAndBaz f (Foo a b c) = Foo &lt;$&gt; f a &lt;*&gt; f b &lt;*&gt; pure c
--   </pre>
--   
--   What is provided in this library is a number of stock lenses and
--   traversals for common haskell types, a wide array of combinators for
--   working them, and more exotic functionality, (<i>e.g.</i> getters,
--   setters, indexed folds, isomorphisms).
@package lens
@version 4.11


-- | One of most commonly-asked questions about this package is whether it
--   provides lenses for working with <a>Map</a>. It does, but their uses
--   are perhaps obscured by their genericity. This module exists to
--   provide documentation for them.
--   
--   <a>Map</a> is an instance of <a>At</a>, so we have a lenses on values
--   at keys:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1, "world")] ^.at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 .~ Just "world" $ Map.empty
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 0 ?~ "hello" $ Map.empty
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in a
--   <a>Map</a>, thanks to its <a>TraversableWithIndex</a>,
--   <a>FoldableWithIndex</a>, and <a>FunctorWithIndex</a> instances.
--   
--   <pre>
--   &gt;&gt;&gt; imap const $ Map.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap (\i _ -&gt; Sum i) $ Map.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverse_ (curry print) $ Map.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoList $ Map.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; ix 2 %~ ("New " ++) $ Map.fromList [(2, "Earth")]
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) $ Map.empty
--   Nothing
--   </pre>
--   
--   Additionally, <a>Map</a> has <a>TraverseMin</a> and <a>TraverseMax</a>
--   instances, which let us traverse over the value at the least and
--   greatest keys, respectively.
--   
--   <pre>
--   &gt;&gt;&gt; preview traverseMin $ Map.fromList [(5, "Saturn"), (6, "Uranus")]
--   Just "Saturn"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview traverseMax $ Map.fromList [(5, "Saturn"), (6, "Uranus")]
--   Just "Uranus"
--   </pre>
module Data.Map.Lens


-- | This module provides utility functions on lists used by the library
--   implementation.
module Control.Lens.Internal.List

-- | Return the the subset of given ordinals within a given bound and in
--   order of the first occurrence seen.
--   
--   Bound: <tt>0 &lt;= x &lt; l</tt>
--   
--   <pre>
--   &gt;&gt;&gt; ordinalNub 3 [-1,2,1,4,2,3]
--   [2,1]
--   </pre>
ordinalNub :: Int -> [Int] -> [Int]


module Control.Lens.Internal.TH

-- | Compatibility shim for recent changes to template haskell's
--   <a>tySynInstD</a>
tySynInstD' :: Name -> [TypeQ] -> TypeQ -> DecQ

-- | Apply arguments to a type constructor
appsT :: TypeQ -> [TypeQ] -> TypeQ

-- | Apply arguments to a function
appsE1 :: ExpQ -> [ExpQ] -> ExpQ

-- | Construct a tuple type given a list of types.
toTupleT :: [TypeQ] -> TypeQ

-- | Construct a tuple value given a list of expressions.
toTupleE :: [ExpQ] -> ExpQ

-- | Construct a tuple pattern given a list of patterns.
toTupleP :: [PatQ] -> PatQ

-- | Apply arguments to a type constructor.
conAppsT :: Name -> [Type] -> Type

-- | Return <a>Name</a> contained in a <a>TyVarBndr</a>.
bndrName :: TyVarBndr -> Name
fromSet :: (k -> v) -> Set k -> Map k v
lensPackageKey :: String
mkLensName_tc :: String -> String -> Name
mkLensName_v :: String -> String -> Name
traversalTypeName :: Name
traversal'TypeName :: Name
lensTypeName :: Name
lens'TypeName :: Name
isoTypeName :: Name
iso'TypeName :: Name
getterTypeName :: Name
foldTypeName :: Name
prismTypeName :: Name
prism'TypeName :: Name
reviewTypeName :: Name
wrappedTypeName :: Name
unwrappedTypeName :: Name
rewrappedTypeName :: Name
_wrapped'ValName :: Name
isoValName :: Name
prismValName :: Name
untoValName :: Name
coerceValName :: Name
composeValName :: Name
idValName :: Name
fmapValName :: Name
pureValName :: Name
apValName :: Name
rightDataName :: Name
leftDataName :: Name


-- | Reifies arbitrary terms at the type level. Based on the Functional
--   Pearl: Implicit Configurations paper by Oleg Kiselyov and Chung-chieh
--   Shan.
--   
--   <a>http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf</a>
--   
--   The approach from the paper was modified to work with Data.Proxy and
--   streamline the API by Edward Kmett and Elliott Hird.
--   
--   Usage comes down to two combinators, <a>reify</a> and <a>reflect</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reify 6 (\p -&gt; reflect p + reflect p)
--   12
--   </pre>
--   
--   The argument passed along by reify is just a <tt>data <a>Proxy</a> t =
--   Proxy</tt>, so all of the information needed to reconstruct your value
--   has been moved to the type level. This enables it to be used when
--   constructing instances (see <tt>examples/Monoid.hs</tt>).
--   
--   This version is based on the "slow" path from the <tt>reflection</tt>
--   package, but modified to work with the same <a>Reifies</a> class as is
--   provided by the "fast" path, and to make sure the parameter is
--   <a>Typeable</a>.
--   
--   This is necessary to work around the changes to <tt>Data.Typeable</tt>
--   in GHC HEAD.
module Control.Lens.Internal.Reflection
class Reifies (s :: k) a | s -> a
reflect :: Reifies s a => proxy s -> a

-- | Reify a value at the type level in a <a>Typeable</a>-compatible
--   fashion, to be recovered with <a>reflect</a>.
reifyTypeable :: Typeable a => a -> (forall s. (Typeable s, Reifies s a) => Proxy s -> r) -> r
instance Typeable T0
instance Typeable T1
instance Typeable T2
instance Typeable T3
instance Typeable T4
instance Typeable T5
instance Typeable T6
instance Typeable T7
instance Typeable T8
instance Typeable T9
instance Typeable T10
instance Typeable T11
instance Typeable T12
instance Typeable T13
instance Typeable T14
instance Typeable T15
instance Typeable T16
instance Typeable T17
instance Typeable T18
instance Typeable T19
instance Typeable T20
instance Typeable T21
instance Typeable T22
instance Typeable T23
instance Typeable T24
instance Typeable T25
instance Typeable T26
instance Typeable T27
instance Typeable T28
instance Typeable T29
instance Typeable T30
instance Typeable T31
instance Typeable T32
instance Typeable T33
instance Typeable T34
instance Typeable T35
instance Typeable T36
instance Typeable T37
instance Typeable T38
instance Typeable T39
instance Typeable T40
instance Typeable T41
instance Typeable T42
instance Typeable T43
instance Typeable T44
instance Typeable T45
instance Typeable T46
instance Typeable T47
instance Typeable T48
instance Typeable T49
instance Typeable T50
instance Typeable T51
instance Typeable T52
instance Typeable T53
instance Typeable T54
instance Typeable T55
instance Typeable T56
instance Typeable T57
instance Typeable T58
instance Typeable T59
instance Typeable T60
instance Typeable T61
instance Typeable T62
instance Typeable T63
instance Typeable T64
instance Typeable T65
instance Typeable T66
instance Typeable T67
instance Typeable T68
instance Typeable T69
instance Typeable T70
instance Typeable T71
instance Typeable T72
instance Typeable T73
instance Typeable T74
instance Typeable T75
instance Typeable T76
instance Typeable T77
instance Typeable T78
instance Typeable T79
instance Typeable T80
instance Typeable T81
instance Typeable T82
instance Typeable T83
instance Typeable T84
instance Typeable T85
instance Typeable T86
instance Typeable T87
instance Typeable T88
instance Typeable T89
instance Typeable T90
instance Typeable T91
instance Typeable T92
instance Typeable T93
instance Typeable T94
instance Typeable T95
instance Typeable T96
instance Typeable T97
instance Typeable T98
instance Typeable T99
instance Typeable T100
instance Typeable T101
instance Typeable T102
instance Typeable T103
instance Typeable T104
instance Typeable T105
instance Typeable T106
instance Typeable T107
instance Typeable T108
instance Typeable T109
instance Typeable T110
instance Typeable T111
instance Typeable T112
instance Typeable T113
instance Typeable T114
instance Typeable T115
instance Typeable T116
instance Typeable T117
instance Typeable T118
instance Typeable T119
instance Typeable T120
instance Typeable T121
instance Typeable T122
instance Typeable T123
instance Typeable T124
instance Typeable T125
instance Typeable T126
instance Typeable T127
instance Typeable T128
instance Typeable T129
instance Typeable T130
instance Typeable T131
instance Typeable T132
instance Typeable T133
instance Typeable T134
instance Typeable T135
instance Typeable T136
instance Typeable T137
instance Typeable T138
instance Typeable T139
instance Typeable T140
instance Typeable T141
instance Typeable T142
instance Typeable T143
instance Typeable T144
instance Typeable T145
instance Typeable T146
instance Typeable T147
instance Typeable T148
instance Typeable T149
instance Typeable T150
instance Typeable T151
instance Typeable T152
instance Typeable T153
instance Typeable T154
instance Typeable T155
instance Typeable T156
instance Typeable T157
instance Typeable T158
instance Typeable T159
instance Typeable T160
instance Typeable T161
instance Typeable T162
instance Typeable T163
instance Typeable T164
instance Typeable T165
instance Typeable T166
instance Typeable T167
instance Typeable T168
instance Typeable T169
instance Typeable T170
instance Typeable T171
instance Typeable T172
instance Typeable T173
instance Typeable T174
instance Typeable T175
instance Typeable T176
instance Typeable T177
instance Typeable T178
instance Typeable T179
instance Typeable T180
instance Typeable T181
instance Typeable T182
instance Typeable T183
instance Typeable T184
instance Typeable T185
instance Typeable T186
instance Typeable T187
instance Typeable T188
instance Typeable T189
instance Typeable T190
instance Typeable T191
instance Typeable T192
instance Typeable T193
instance Typeable T194
instance Typeable T195
instance Typeable T196
instance Typeable T197
instance Typeable T198
instance Typeable T199
instance Typeable T200
instance Typeable T201
instance Typeable T202
instance Typeable T203
instance Typeable T204
instance Typeable T205
instance Typeable T206
instance Typeable T207
instance Typeable T208
instance Typeable T209
instance Typeable T210
instance Typeable T211
instance Typeable T212
instance Typeable T213
instance Typeable T214
instance Typeable T215
instance Typeable T216
instance Typeable T217
instance Typeable T218
instance Typeable T219
instance Typeable T220
instance Typeable T221
instance Typeable T222
instance Typeable T223
instance Typeable T224
instance Typeable T225
instance Typeable T226
instance Typeable T227
instance Typeable T228
instance Typeable T229
instance Typeable T230
instance Typeable T231
instance Typeable T232
instance Typeable T233
instance Typeable T234
instance Typeable T235
instance Typeable T236
instance Typeable T237
instance Typeable T238
instance Typeable T239
instance Typeable T240
instance Typeable T241
instance Typeable T242
instance Typeable T243
instance Typeable T244
instance Typeable T245
instance Typeable T246
instance Typeable T247
instance Typeable T248
instance Typeable T249
instance Typeable T250
instance Typeable T251
instance Typeable T252
instance Typeable T253
instance Typeable T254
instance Typeable T255
instance Typeable W
instance Typeable Stable
instance (B b0, B b1, B b2, B b3, B b4, B b5, B b6, B b7, w0 ~ W b0 b1 b2 b3, w1 ~ W b4 b5 b6 b7) => Reifies (Stable w0 w1 a) a
instance B T255
instance B T254
instance B T253
instance B T252
instance B T251
instance B T250
instance B T249
instance B T248
instance B T247
instance B T246
instance B T245
instance B T244
instance B T243
instance B T242
instance B T241
instance B T240
instance B T239
instance B T238
instance B T237
instance B T236
instance B T235
instance B T234
instance B T233
instance B T232
instance B T231
instance B T230
instance B T229
instance B T228
instance B T227
instance B T226
instance B T225
instance B T224
instance B T223
instance B T222
instance B T221
instance B T220
instance B T219
instance B T218
instance B T217
instance B T216
instance B T215
instance B T214
instance B T213
instance B T212
instance B T211
instance B T210
instance B T209
instance B T208
instance B T207
instance B T206
instance B T205
instance B T204
instance B T203
instance B T202
instance B T201
instance B T200
instance B T199
instance B T198
instance B T197
instance B T196
instance B T195
instance B T194
instance B T193
instance B T192
instance B T191
instance B T190
instance B T189
instance B T188
instance B T187
instance B T186
instance B T185
instance B T184
instance B T183
instance B T182
instance B T181
instance B T180
instance B T179
instance B T178
instance B T177
instance B T176
instance B T175
instance B T174
instance B T173
instance B T172
instance B T171
instance B T170
instance B T169
instance B T168
instance B T167
instance B T166
instance B T165
instance B T164
instance B T163
instance B T162
instance B T161
instance B T160
instance B T159
instance B T158
instance B T157
instance B T156
instance B T155
instance B T154
instance B T153
instance B T152
instance B T151
instance B T150
instance B T149
instance B T148
instance B T147
instance B T146
instance B T145
instance B T144
instance B T143
instance B T142
instance B T141
instance B T140
instance B T139
instance B T138
instance B T137
instance B T136
instance B T135
instance B T134
instance B T133
instance B T132
instance B T131
instance B T130
instance B T129
instance B T128
instance B T127
instance B T126
instance B T125
instance B T124
instance B T123
instance B T122
instance B T121
instance B T120
instance B T119
instance B T118
instance B T117
instance B T116
instance B T115
instance B T114
instance B T113
instance B T112
instance B T111
instance B T110
instance B T109
instance B T108
instance B T107
instance B T106
instance B T105
instance B T104
instance B T103
instance B T102
instance B T101
instance B T100
instance B T99
instance B T98
instance B T97
instance B T96
instance B T95
instance B T94
instance B T93
instance B T92
instance B T91
instance B T90
instance B T89
instance B T88
instance B T87
instance B T86
instance B T85
instance B T84
instance B T83
instance B T82
instance B T81
instance B T80
instance B T79
instance B T78
instance B T77
instance B T76
instance B T75
instance B T74
instance B T73
instance B T72
instance B T71
instance B T70
instance B T69
instance B T68
instance B T67
instance B T66
instance B T65
instance B T64
instance B T63
instance B T62
instance B T61
instance B T60
instance B T59
instance B T58
instance B T57
instance B T56
instance B T55
instance B T54
instance B T53
instance B T52
instance B T51
instance B T50
instance B T49
instance B T48
instance B T47
instance B T46
instance B T45
instance B T44
instance B T43
instance B T42
instance B T41
instance B T40
instance B T39
instance B T38
instance B T37
instance B T36
instance B T35
instance B T34
instance B T33
instance B T32
instance B T31
instance B T30
instance B T29
instance B T28
instance B T27
instance B T26
instance B T25
instance B T24
instance B T23
instance B T22
instance B T21
instance B T20
instance B T19
instance B T18
instance B T17
instance B T16
instance B T15
instance B T14
instance B T13
instance B T12
instance B T11
instance B T10
instance B T9
instance B T8
instance B T7
instance B T6
instance B T5
instance B T4
instance B T3
instance B T2
instance B T1
instance B T0


-- | This module provides a shim around <a>coerce</a> that defaults to
--   <tt>unsafeCoerce</tt> on GHC &lt; 7.8
module Control.Lens.Internal.Coerce

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible k a b => a -> b
coerce' :: Coercible a b => b -> a


-- | This module includes orphan instances for <tt>(,)</tt>, <a>Either</a>
--   and <tt>Const</tt> that should be supplied by base. These have moved
--   to <tt>semigroupoids</tt> as of 4.2.
module Control.Lens.Internal.Instances


module Control.Lens.Internal.Zoom

-- | This type family is used by <a>Zoom</a> to describe the common effect
--   type.

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>StateT</a>.
newtype Focusing m s a
Focusing :: m (s, a) -> Focusing m s a
unfocusing :: Focusing m s a -> m (s, a)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>RWST</a>.
newtype FocusingWith w m s a
FocusingWith :: m (s, a, w) -> FocusingWith w m s a
unfocusingWith :: FocusingWith w m s a -> m (s, a, w)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>WriterT</a>.
newtype FocusingPlus w k s a
FocusingPlus :: k (s, w) a -> FocusingPlus w k s a
unfocusingPlus :: FocusingPlus w k s a -> k (s, w) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>MaybeT</a> or <a>ListT</a>.
newtype FocusingOn f k s a
FocusingOn :: k (f s) a -> FocusingOn f k s a
unfocusingOn :: FocusingOn f k s a -> k (f s) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>ErrorT</a>.
newtype FocusingMay k s a
FocusingMay :: k (May s) a -> FocusingMay k s a
unfocusingMay :: FocusingMay k s a -> k (May s) a

-- | Make a <a>Monoid</a> out of <a>Maybe</a> for error handling.
newtype May a
May :: Maybe a -> May a
getMay :: May a -> Maybe a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>ErrorT</a>.
newtype FocusingErr e k s a
FocusingErr :: k (Err e s) a -> FocusingErr e k s a
unfocusingErr :: FocusingErr e k s a -> k (Err e s) a

-- | Make a <a>Monoid</a> out of <a>Either</a> for error handling.
newtype Err e a
Err :: Either e a -> Err e a
getErr :: Err e a -> Either e a

-- | This type family is used by <a>Magnify</a> to describe the common
--   effect type.

-- | Wrap a monadic effect with a phantom type argument.
newtype Effect m r a
Effect :: m r -> Effect m r a
getEffect :: Effect m r a -> m r

-- | Wrap a monadic effect with a phantom type argument. Used when
--   magnifying <a>RWST</a>.
newtype EffectRWS w st m s a
EffectRWS :: (st -> m (s, st, w)) -> EffectRWS w st m s a
getEffectRWS :: EffectRWS w st m s a -> st -> m (s, st, w)
instance [safe] Contravariant (EffectRWS w st m s)
instance [safe] (Monoid s, Monoid w, Monad m) => Applicative (EffectRWS w st m s)
instance [safe] (Semigroup s, Semigroup w, Bind m) => Apply (EffectRWS w st m s)
instance [safe] Functor (EffectRWS w st m s)
instance [safe] (Monad m, Monoid r) => Applicative (Effect m r)
instance [safe] (Apply m, Semigroup r) => Apply (Effect m r)
instance [safe] (Monad m, Monoid r) => Monoid (Effect m r a)
instance [safe] (Apply m, Semigroup r) => Semigroup (Effect m r a)
instance [safe] Contravariant (Effect m r)
instance [safe] Functor (Effect m r)
instance [safe] Applicative (k (Err e s)) => Applicative (FocusingErr e k s)
instance [safe] Apply (k (Err e s)) => Apply (FocusingErr e k s)
instance [safe] Functor (k (Err e s)) => Functor (FocusingErr e k s)
instance [safe] Monoid a => Monoid (Err e a)
instance [safe] Semigroup a => Semigroup (Err e a)
instance [safe] Applicative (k (May s)) => Applicative (FocusingMay k s)
instance [safe] Apply (k (May s)) => Apply (FocusingMay k s)
instance [safe] Functor (k (May s)) => Functor (FocusingMay k s)
instance [safe] Monoid a => Monoid (May a)
instance [safe] Semigroup a => Semigroup (May a)
instance [safe] Applicative (k (f s)) => Applicative (FocusingOn f k s)
instance [safe] Apply (k (f s)) => Apply (FocusingOn f k s)
instance [safe] Functor (k (f s)) => Functor (FocusingOn f k s)
instance [safe] Applicative (k (s, w)) => Applicative (FocusingPlus w k s)
instance [safe] Apply (k (s, w)) => Apply (FocusingPlus w k s)
instance [safe] Functor (k (s, w)) => Functor (FocusingPlus w k s)
instance [safe] (Monad m, Monoid s, Monoid w) => Applicative (FocusingWith w m s)
instance [safe] (Monad m, Semigroup s, Semigroup w) => Apply (FocusingWith w m s)
instance [safe] Monad m => Functor (FocusingWith w m s)
instance [safe] (Monad m, Monoid s) => Applicative (Focusing m s)
instance [safe] (Monad m, Semigroup s) => Apply (Focusing m s)
instance [safe] Monad m => Functor (Focusing m s)


module Control.Lens.Internal.Setter

-- | Anything <a>Settable</a> must be isomorphic to the <a>Identity</a>
--   <a>Functor</a>.
class (Applicative f, Distributive f, Traversable f) => Settable f where untaintedDot g = g `seq` rmap untainted g taintedDot g = g `seq` rmap pure g
untainted :: Settable f => f a -> a
untaintedDot :: (Settable f, Profunctor p) => p a (f b) -> p a b
taintedDot :: (Settable f, Profunctor p) => p a b -> p a (f b)
instance (Settable f, Settable g) => Settable (Compose f g)
instance Settable f => Settable (Backwards f)
instance Settable Identity


module Control.Lens.Internal.Review

-- | This class is provided mostly for backwards compatibility with lens
--   3.8, but it can also shorten type signatures.
class (Profunctor p, Bifunctor p) => Reviewable p

-- | This is a profunctor used internally to implement <a>Review</a>
--   
--   It plays a role similar to that of <a>Accessor</a> or <tt>Const</tt>
--   do for <a>Control.Lens.Getter</a>
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
instance (Profunctor p, Bifunctor p) => Reviewable p


module Control.Lens.Internal.Prism

-- | This type is used internally by the <a>Prism</a> code to provide
--   efficient access to the two parts of a <tt>Prism</tt>.
data Market a b s t
Market :: (b -> t) -> (s -> Either t a) -> Market a b s t

-- | <pre>
--   type <a>Market'</a> a s t = <a>Market</a> a a s t
--   </pre>
type Market' a = Market a a
instance Choice (Market a b)
instance Profunctor (Market a b)
instance Functor (Market a b s)


module Control.Lens.Internal.Iso

-- | This is used internally by the <a>Iso</a> code to provide efficient
--   access to the two functions that make up an isomorphism.
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t

-- | This class provides a generalized notion of list reversal extended to
--   other containers.
class Reversing t
reversing :: Reversing t => t -> t
instance Storable a => Reversing (Vector a)
instance Unbox a => Reversing (Vector a)
instance Prim a => Reversing (Vector a)
instance Reversing (Seq a)
instance Reversing (Vector a)
instance Reversing Text
instance Reversing Text
instance Reversing ByteString
instance Reversing ByteString
instance Reversing [a]
instance Profunctor (Exchange a b)
instance Functor (Exchange a b s)


-- | This module provides implementation details of the combinators in
--   <a>Control.Lens.Level</a>, which provides for the breadth-first
--   <a>Traversal</a> of an arbitrary <a>Traversal</a>.
module Control.Lens.Internal.Level

-- | This data type represents a path-compressed copy of one level of a
--   source data structure. We can safely use path-compression because we
--   know the depth of the tree.
--   
--   Path compression is performed by viewing a <a>Level</a> as a PATRICIA
--   trie of the paths into the structure to leaves at a given depth,
--   similar in many ways to a <a>IntMap</a>, but unlike a regular PATRICIA
--   trie we do not need to store the mask bits merely the depth of the
--   fork.
--   
--   One invariant of this structure is that underneath a <a>Two</a> node
--   you will not find any <a>Zero</a> nodes, so <a>Zero</a> can only occur
--   at the root.
data Level i a
Two :: {-# UNPACK #-} !Word -> !(Level i a) -> !(Level i a) -> Level i a
One :: i -> a -> Level i a
Zero :: Level i a

-- | This is an illegal <a>Monoid</a> used to construct a single
--   <a>Level</a>.
newtype Deepening i a
Deepening :: (forall r. Int -> (Level i a -> Bool -> r) -> r) -> Deepening i a
runDeepening :: Deepening i a -> forall r. Int -> (Level i a -> Bool -> r) -> r

-- | Generate the leaf of a given <a>Deepening</a> based on whether or not
--   we're at the correct depth.
deepening :: i -> a -> Deepening i a

-- | This is an illegal <a>Applicative</a> used to replace the contents of
--   a list of consecutive <a>Level</a> values representing each layer of a
--   structure into the original shape that they were derived from.
--   
--   Attempting to <tt>Flow</tt> something back into a shape other than the
--   one it was taken from will fail.
newtype Flows i b a
Flows :: ([Level i b] -> a) -> Flows i b a
runFlows :: Flows i b a -> [Level i b] -> a
instance (Eq i, Eq a) => Eq (Level i a)
instance (Ord i, Ord a) => Ord (Level i a)
instance (Show i, Show a) => Show (Level i a)
instance (Read i, Read a) => Read (Level i a)
instance Applicative (Flows i b)
instance Apply (Flows i b)
instance Functor (Flows i b)
instance Monoid (Deepening i a)
instance Semigroup (Deepening i a)
instance Traversable (Level i)
instance Foldable (Level i)
instance Functor (Level i)


module Control.Lens.Internal.Getter

-- | A <a>Functor</a> you can <a>coerce</a> ignores its argument, which it
--   carries solely as a phantom type parameter.
--   
--   By the <a>Functor</a> and <a>Contravariant</a> laws, an instance of
--   both will necessarily satisfy:
--   
--   <pre>
--   <a>id</a> = <a>fmap</a> f = <a>coerce</a> = <a>contramap</a> g
--   </pre>
coerce :: (Contravariant f, Functor f) => f a -> f b

-- | The <tt>mempty</tt> equivalent for a <a>Contravariant</a>
--   <a>Applicative</a> <a>Functor</a>.
noEffect :: (Contravariant f, Applicative f) => f a
newtype AlongsideLeft f b a
AlongsideLeft :: f (a, b) -> AlongsideLeft f b a
getAlongsideLeft :: AlongsideLeft f b a -> f (a, b)
newtype AlongsideRight f a b
AlongsideRight :: f (a, b) -> AlongsideRight f a b
getAlongsideRight :: AlongsideRight f a b -> f (a, b)
instance Read (f (a, b)) => Read (AlongsideRight f a b)
instance Show (f (a, b)) => Show (AlongsideRight f a b)
instance Read (f (a, b)) => Read (AlongsideLeft f b a)
instance Show (f (a, b)) => Show (AlongsideLeft f b a)
instance Traversable f => Bitraversable (AlongsideRight f)
instance Foldable f => Bifoldable (AlongsideRight f)
instance Functor f => Bifunctor (AlongsideRight f)
instance Traversable1 f => Traversable1 (AlongsideRight f a)
instance Foldable1 f => Foldable1 (AlongsideRight f a)
instance Traversable f => Traversable (AlongsideRight f a)
instance Foldable f => Foldable (AlongsideRight f a)
instance Contravariant f => Contravariant (AlongsideRight f a)
instance Functor f => Functor (AlongsideRight f a)
instance Traversable f => Bitraversable (AlongsideLeft f)
instance Foldable f => Bifoldable (AlongsideLeft f)
instance Functor f => Bifunctor (AlongsideLeft f)
instance Traversable1 f => Traversable1 (AlongsideLeft f b)
instance Foldable1 f => Foldable1 (AlongsideLeft f b)
instance Traversable f => Traversable (AlongsideLeft f b)
instance Foldable f => Foldable (AlongsideLeft f b)
instance Contravariant f => Contravariant (AlongsideLeft f b)
instance Functor f => Functor (AlongsideLeft f b)


-- | Internal implementation details for <a>Indexed</a> lens-likes
module Control.Lens.Internal.Indexed

-- | A function with access to a index. This constructor may be useful when
--   you need to store an <a>Indexable</a> in a container to avoid
--   <tt>ImpredicativeTypes</tt>.
--   
--   <pre>
--   index :: Indexed i a b -&gt; i -&gt; a -&gt; b
--   </pre>
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
runIndexed :: Indexed i a b -> i -> a -> b

-- | This is a <a>Profunctor</a> that is both <a>Corepresentable</a> by
--   <tt>f</tt> and <a>Representable</a> by <tt>g</tt> such that <tt>f</tt>
--   is left adjoint to <tt>g</tt>. From this you can derive a lot of
--   structure due to the preservation of limits and colimits.
class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p where distrib = tabulate . collect . sieve conjoined _ r = r
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r

-- | This class permits overloading of function application for things that
--   also admit a notion of a key or index.
class Conjoined p => Indexable i p
indexed :: Indexable i p => p a b -> i -> a -> b

-- | <a>Applicative</a> composition of <tt><a>State</a> <a>Int</a></tt>
--   with a <a>Functor</a>, used by <a>indexed</a>.
newtype Indexing f a
Indexing :: (Int -> (Int, f a)) -> Indexing f a
runIndexing :: Indexing f a -> Int -> (Int, f a)

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   <pre>
--   <a>indexing</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int</a>  s t a b
--   <a>indexing</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   <a>indexing</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing</a> :: <a>Indexable</a> <a>Int</a> p =&gt; <a>LensLike</a> (<a>Indexing</a> f) s t a b -&gt; <a>Optical</a> p (-&gt;) f s t a b
--   </pre>
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t

-- | <a>Applicative</a> composition of <tt><a>State</a> <a>Int64</a></tt>
--   with a <a>Functor</a>, used by <a>indexed64</a>.
newtype Indexing64 f a
Indexing64 :: (Int64 -> (Int64, f a)) -> Indexing64 f a
runIndexing64 :: Indexing64 f a -> Int64 -> (Int64, f a)

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   This combinator is like <a>indexing</a> except that it handles large
--   traversals and folds gracefully.
--   
--   <pre>
--   <a>indexing64</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int64</a> s a
--   <a>indexing64</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int64</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing64</a> :: <a>Indexable</a> <a>Int64</a> p =&gt; <a>LensLike</a> (<a>Indexing64</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t

-- | Fold a container with indices returning both the indices and the
--   values.
--   
--   The result is only valid to compose in a <tt>Traversal</tt>, if you
--   don't edit the index as edits to the index have no effect.
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)

-- | When composed with an <tt>IndexedFold</tt> or
--   <tt>IndexedTraversal</tt> this yields an (<a>Indexed</a>)
--   <tt>Fold</tt> of the indices.
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)
instance Contravariant f => Contravariant (Indexing64 f)
instance Applicative f => Applicative (Indexing64 f)
instance Apply f => Apply (Indexing64 f)
instance Functor f => Functor (Indexing64 f)
instance Contravariant f => Contravariant (Indexing f)
instance Applicative f => Applicative (Indexing f)
instance Apply f => Apply (Indexing f)
instance Functor f => Functor (Indexing f)
instance i ~ j => Indexable i (Indexed j)
instance Conjoined (Indexed i)
instance ArrowLoop (Indexed i)
instance ArrowApply (Indexed i)
instance ArrowChoice (Indexed i)
instance Arrow (Indexed i)
instance Category (Indexed i)
instance Strong (Indexed i)
instance Choice (Indexed i)
instance Corepresentable (Indexed i)
instance Cosieve (Indexed i) ((,) i)
instance Representable (Indexed i)
instance Sieve (Indexed i) ((->) i)
instance Costrong (Indexed i)
instance Profunctor (Indexed i)
instance MonadFix (Indexed i a)
instance Monad (Indexed i a)
instance Bind (Indexed i a)
instance Applicative (Indexed i a)
instance Apply (Indexed i a)
instance Functor (Indexed i a)
instance Indexable i (->)
instance Conjoined (->)


module Control.Lens.Internal.Context

-- | This is a Bob Atkey -style 2-argument indexed functor.
--   
--   It exists as a superclass for <a>IndexedComonad</a> and expresses the
--   functoriality of an <a>IndexedComonad</a> in its third argument.
class IndexedFunctor w
ifmap :: IndexedFunctor w => (s -> t) -> w a b s -> w a b t

-- | This is a Bob Atkey -style 2-argument indexed comonad.
--   
--   It exists as a superclass for <a>IndexedComonad</a> and expresses the
--   functoriality of an <a>IndexedComonad</a> in its third argument.
--   
--   The notion of indexed monads is covered in more depth in Bob Atkey's
--   "Parameterized Notions of Computation"
--   <a>http://bentnib.org/paramnotions-jfp.pdf</a> and that construction
--   is dualized here.
class IndexedFunctor w => IndexedComonad w where iduplicate = iextend id iextend f = ifmap f . iduplicate
iextract :: IndexedComonad w => w a a t -> t
iduplicate :: IndexedComonad w => w a c t -> w a b (w b c t)
iextend :: IndexedComonad w => (w b c t -> r) -> w a c t -> w a b r

-- | This is an indexed analogue to <a>ComonadStore</a> for when you are
--   working with an <a>IndexedComonad</a>.
class IndexedComonad w => IndexedComonadStore w where ipeek c = iextract . iseek c ipeeks f = iextract . iseeks f iexperiment bfc wbct = (`ipeek` wbct) <$> bfc (ipos wbct) context wabt = Context (`ipeek` wabt) (ipos wabt)
ipos :: IndexedComonadStore w => w a c t -> a
ipeek :: IndexedComonadStore w => c -> w a c t -> t
ipeeks :: IndexedComonadStore w => (a -> c) -> w a c t -> t
iseek :: IndexedComonadStore w => b -> w a c t -> w b c t
iseeks :: IndexedComonadStore w => (a -> b) -> w a c t -> w b c t
iexperiment :: (IndexedComonadStore w, Functor f) => (b -> f c) -> w b c t -> f t
context :: IndexedComonadStore w => w a b t -> Context a b t

-- | This is used internally to construct a <a>Bazaar</a>, <a>Context</a>
--   or <a>Pretext</a> from a singleton value.
class Corepresentable p => Sellable p w | w -> p
sell :: Sellable p w => p a (w a b b)

-- | The indexed store can be used to characterize a <a>Lens</a> and is
--   used by <a>clone</a>.
--   
--   <tt><a>Context</a> a b t</tt> is isomorphic to <tt>newtype
--   <a>Context</a> a b t = <a>Context</a> { runContext :: forall f.
--   <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; f t }</tt>, and to
--   <tt>exists s. (s, <a>Lens</a> s t a b)</tt>.
--   
--   A <a>Context</a> is like a <a>Lens</a> that has already been applied
--   to a some structure.
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | <pre>
--   type <a>Context'</a> a s = <a>Context</a> a a s
--   </pre>
type Context' a = Context a a

-- | This is a generalized form of <a>Context</a> that can be repeatedly
--   cloned with less impact on its performance, and which permits the use
--   of an arbitrary <a>Conjoined</a> <a>Profunctor</a>
newtype Pretext p a b t
Pretext :: (forall f. Functor f => p a (f b) -> f t) -> Pretext p a b t
runPretext :: Pretext p a b t -> forall f. Functor f => p a (f b) -> f t

-- | <pre>
--   type <a>Pretext'</a> p a s = <a>Pretext</a> p a a s
--   </pre>
type Pretext' p a = Pretext p a a

-- | This is a generalized form of <a>Context</a> that can be repeatedly
--   cloned with less impact on its performance, and which permits the use
--   of an arbitrary <a>Conjoined</a> <a>Profunctor</a>.
--   
--   The extra phantom <a>Functor</a> is used to let us lie and claim
--   <a>Getter</a>-compatibility under limited circumstances. This is used
--   internally to permit a number of combinators to gracefully degrade
--   when applied to a <a>Fold</a> or <a>Getter</a>.
newtype PretextT p (g :: * -> *) a b t
PretextT :: (forall f. Functor f => p a (f b) -> f t) -> PretextT p a b t
runPretextT :: PretextT p a b t -> forall f. Functor f => p a (f b) -> f t

-- | <pre>
--   type <a>PretextT'</a> p g a s = <a>PretextT</a> p g a a s
--   </pre>
type PretextT' p g a = PretextT p g a a
instance (Profunctor p, Contravariant g) => Contravariant (PretextT p g a b)
instance Corepresentable p => Sellable p (PretextT p g)
instance (a ~ b, Conjoined p) => ComonadStore a (PretextT p g a b)
instance Conjoined p => IndexedComonadStore (PretextT p g)
instance (a ~ b, Conjoined p) => Comonad (PretextT p g a b)
instance Conjoined p => IndexedComonad (PretextT p g)
instance Functor (PretextT p g a b)
instance IndexedFunctor (PretextT p g)
instance Corepresentable p => Sellable p (Pretext p)
instance (a ~ b, Conjoined p) => ComonadStore a (Pretext p a b)
instance Conjoined p => IndexedComonadStore (Pretext p)
instance (a ~ b, Conjoined p) => Comonad (Pretext p a b)
instance Conjoined p => IndexedComonad (Pretext p)
instance Functor (Pretext p a b)
instance IndexedFunctor (Pretext p)
instance Sellable (->) Context
instance a ~ b => ComonadStore a (Context a b)
instance a ~ b => Comonad (Context a b)
instance Functor (Context a b)
instance IndexedComonadStore Context
instance IndexedComonad Context
instance IndexedFunctor Context


module Control.Lens.Internal.Bazaar

-- | This class is used to run the various <a>Bazaar</a> variants used in
--   this library.
class Profunctor p => Bizarre p w | w -> p
bazaar :: (Bizarre p w, Applicative f) => p a (f b) -> w a b t -> f t

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar</a> a b t</tt>
--   holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar</a> holds many stores and you can easily add
--   more.
--   
--   This is a final encoding of <a>Bazaar</a>.
newtype Bazaar p a b t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
runBazaar :: Bazaar p a b t -> forall f. Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar'</a> p a t = <a>Bazaar</a> p a a t
--   </pre>
type Bazaar' p a = Bazaar p a a

-- | <a>BazaarT</a> is like <a>Bazaar</a>, except that it provides a
--   questionable <a>Contravariant</a> instance To protect this instance it
--   relies on the soundness of another <a>Contravariant</a> type, and
--   usage conventions.
--   
--   For example. This lets us write a suitably polymorphic and lazy
--   <a>taking</a>, but there must be a better way!
newtype BazaarT p (g :: * -> *) a b t
BazaarT :: (forall f. Applicative f => p a (f b) -> f t) -> BazaarT p a b t
runBazaarT :: BazaarT p a b t -> forall f. Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>BazaarT'</a> p g a t = <a>BazaarT</a> p g a a t
--   </pre>
type BazaarT' p g a = BazaarT p g a a
class Profunctor p => Bizarre1 p w | w -> p
bazaar1 :: (Bizarre1 p w, Apply f) => p a (f b) -> w a b t -> f t

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar1</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar1</a> a b
--   t</tt> holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar1</a> holds many stores and you can easily
--   add more.
--   
--   This is a final encoding of <a>Bazaar1</a>.
newtype Bazaar1 p a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
runBazaar1 :: Bazaar1 p a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar1'</a> p a t = <a>Bazaar1</a> p a a t
--   </pre>
type Bazaar1' p a = Bazaar1 p a a

-- | <a>BazaarT1</a> is like <a>Bazaar1</a>, except that it provides a
--   questionable <a>Contravariant</a> instance To protect this instance it
--   relies on the soundness of another <a>Contravariant</a> type, and
--   usage conventions.
--   
--   For example. This lets us write a suitably polymorphic and lazy
--   <a>taking</a>, but there must be a better way!
newtype BazaarT1 p (g :: * -> *) a b t
BazaarT1 :: (forall f. Apply f => p a (f b) -> f t) -> BazaarT1 p a b t
runBazaarT1 :: BazaarT1 p a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>BazaarT1'</a> p g a t = <a>BazaarT1</a> p g a a t
--   </pre>
type BazaarT1' p g a = BazaarT1 p g a a
instance Contravariant g => Semigroup (BazaarT1 p g a b t)
instance (Profunctor p, Contravariant g) => Contravariant (BazaarT1 p g a b)
instance (a ~ b, Conjoined p) => ComonadApply (BazaarT1 p g a b)
instance (a ~ b, Conjoined p) => Comonad (BazaarT1 p g a b)
instance Apply (BazaarT1 p g a b)
instance Functor (BazaarT1 p g a b)
instance Profunctor p => Bizarre1 p (BazaarT1 p g)
instance Corepresentable p => Sellable p (BazaarT1 p g)
instance Conjoined p => IndexedComonad (BazaarT1 p g)
instance IndexedFunctor (BazaarT1 p g)
instance (a ~ b, Conjoined p) => ComonadApply (Bazaar1 p a b)
instance (a ~ b, Conjoined p) => Comonad (Bazaar1 p a b)
instance Apply (Bazaar1 p a b)
instance Functor (Bazaar1 p a b)
instance Profunctor p => Bizarre1 p (Bazaar1 p)
instance Corepresentable p => Sellable p (Bazaar1 p)
instance Conjoined p => IndexedComonad (Bazaar1 p)
instance IndexedFunctor (Bazaar1 p)
instance Contravariant g => Monoid (BazaarT p g a b t)
instance Contravariant g => Semigroup (BazaarT p g a b t)
instance (Profunctor p, Contravariant g) => Contravariant (BazaarT p g a b)
instance (a ~ b, Conjoined p) => ComonadApply (BazaarT p g a b)
instance (a ~ b, Conjoined p) => Comonad (BazaarT p g a b)
instance Applicative (BazaarT p g a b)
instance Apply (BazaarT p g a b)
instance Functor (BazaarT p g a b)
instance Profunctor p => Bizarre p (BazaarT p g)
instance Corepresentable p => Sellable p (BazaarT p g)
instance Conjoined p => IndexedComonad (BazaarT p g)
instance IndexedFunctor (BazaarT p g)
instance (a ~ b, Conjoined p) => ComonadApply (Bazaar p a b)
instance (a ~ b, Conjoined p) => Comonad (Bazaar p a b)
instance Applicative (Bazaar p a b)
instance Apply (Bazaar p a b)
instance Functor (Bazaar p a b)
instance Profunctor p => Bizarre p (Bazaar p)
instance Corepresentable p => Sellable p (Bazaar p)
instance Conjoined p => IndexedComonad (Bazaar p)
instance IndexedFunctor (Bazaar p)


module Control.Lens.Internal.Magma

-- | This provides a way to peek at the internal structure of a
--   <a>Traversal</a> or <a>IndexedTraversal</a>
data Magma i t b a
MagmaAp :: Magma i (x -> y) b a -> Magma i x b a -> Magma i y b a
MagmaPure :: x -> Magma i x b a
MagmaFmap :: (x -> y) -> Magma i x b a -> Magma i y b a
Magma :: i -> a -> Magma i b b a

-- | Run a <a>Magma</a> where all the individual leaves have been converted
--   to the expected type
runMagma :: Magma i t a a -> t

-- | This is a a non-reassociating initially encoded version of
--   <a>Bazaar</a>.
newtype Molten i a b t
Molten :: Magma i t b a -> Molten i a b t
runMolten :: Molten i a b t -> Magma i t b a

-- | This is used to generate an indexed magma from an unindexed source
--   
--   By constructing it this way we avoid infinite reassociations in sums
--   where possible.
data Mafic a b t
Mafic :: Int -> (Int -> Magma Int t b a) -> Mafic a b t

-- | Generate a <a>Magma</a> using from a prefix sum.
runMafic :: Mafic a b t -> Magma Int t b a

-- | This is used to generate an indexed magma from an unindexed source
--   
--   By constructing it this way we avoid infinite reassociations where
--   possible.
--   
--   In <tt><a>TakingWhile</a> p g a b t</tt>, <tt>g</tt> has a
--   <tt>nominal</tt> role to avoid exposing an illegal _|_ via
--   <a>Contravariant</a>, while the remaining arguments are degraded to a
--   <tt>nominal</tt> role by the invariants of <a>Magma</a>
data TakingWhile p (g :: * -> *) a b t
TakingWhile :: Bool -> t -> (Bool -> Magma () t b (Corep p a)) -> TakingWhile p a b t

-- | Generate a <a>Magma</a> with leaves only while the predicate holds
--   from left to right.
runTakingWhile :: TakingWhile p f a b t -> Magma () t b (Corep p a)
instance IndexedFunctor (TakingWhile p f)
instance Contravariant f => Contravariant (TakingWhile p f a b)
instance Corepresentable p => Bizarre p (TakingWhile p g)
instance Applicative (TakingWhile p f a b)
instance Apply (TakingWhile p f a b)
instance Functor (TakingWhile p f a b)
instance IndexedFunctor Mafic
instance Bizarre (Indexed Int) Mafic
instance Sellable (->) Mafic
instance Applicative (Mafic a b)
instance Apply (Mafic a b)
instance Functor (Mafic a b)
instance a ~ b => Comonad (Molten i a b)
instance IndexedComonad (Molten i)
instance IndexedFunctor (Molten i)
instance Bizarre (Indexed i) (Molten i)
instance Sellable (Indexed i) (Molten i)
instance Applicative (Molten i a b)
instance Apply (Molten i a b)
instance Functor (Molten i a b)
instance (Show i, Show a) => Show (Magma i t b a)
instance Traversable (Magma i t b)
instance Foldable (Magma i t b)
instance Functor (Magma i t b)


module Control.Lens.Internal.Fold

-- | A <a>Monoid</a> for a <a>Contravariant</a> <a>Applicative</a>.
newtype Folding f a
Folding :: f a -> Folding f a
getFolding :: Folding f a -> f a

-- | Used internally by <a>traverseOf_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
newtype Traversed a f
Traversed :: f a -> Traversed a f
getTraversed :: Traversed a f -> f a

-- | Used internally by <a>mapM_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
newtype Sequenced a m
Sequenced :: m a -> Sequenced a m
getSequenced :: Sequenced a m -> m a

-- | Used for <a>maximumOf</a>.
data Max a
NoMax :: Max a
Max :: a -> Max a

-- | Obtain the maximum.
getMax :: Max a -> Maybe a

-- | Used for <a>minimumOf</a>.
data Min a
NoMin :: Min a
Min :: a -> Min a

-- | Obtain the minimum.
getMin :: Min a -> Maybe a

-- | Used for <a>preview</a>.
data Leftmost a
LPure :: Leftmost a
LLeaf :: a -> Leftmost a
LStep :: (Leftmost a) -> Leftmost a

-- | Extract the <a>Leftmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getLeftmost :: Leftmost a -> Maybe a

-- | Used for <a>lastOf</a>.
data Rightmost a
RPure :: Rightmost a
RLeaf :: a -> Rightmost a
RStep :: (Rightmost a) -> Rightmost a

-- | Extract the <a>Rightmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getRightmost :: Rightmost a -> Maybe a
data ReifiedMonoid a
ReifiedMonoid :: (a -> a -> a) -> a -> ReifiedMonoid a
reifiedMappend :: ReifiedMonoid a -> a -> a -> a
reifiedMempty :: ReifiedMonoid a -> a
newtype M a s
M :: a -> M a s
reifyFold :: (a -> a -> a) -> a -> (forall s. Reifies s (ReifiedMonoid a) => t -> M a s) -> t -> a
instance Reifies s (ReifiedMonoid a) => Monoid (M a s)
instance Monoid (Rightmost a)
instance Semigroup (Rightmost a)
instance Monoid (Leftmost a)
instance Semigroup (Leftmost a)
instance Ord a => Monoid (Max a)
instance Ord a => Semigroup (Max a)
instance Ord a => Monoid (Min a)
instance Ord a => Semigroup (Min a)
instance Monad m => Monoid (Sequenced a m)
instance Apply m => Semigroup (Sequenced a m)
instance Applicative f => Monoid (Traversed a f)
instance Apply f => Semigroup (Traversed a f)
instance (Contravariant f, Applicative f) => Monoid (Folding f a)
instance (Contravariant f, Apply f) => Semigroup (Folding f a)


-- | This module exports the majority of the types that need to appear in
--   user signatures or in documentation when talking about lenses. The
--   remaining types for consuming lenses are distributed across various
--   modules in the hierarchy.
module Control.Lens.Type

-- | A witness that <tt>(a ~ s, b ~ t)</tt>.
--   
--   Note: Composition with an <a>Equality</a> is index-preserving.
type Equality s t a b = forall p (f :: * -> *). p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Equality</a>.
type Equality' s a = Equality s s a a

-- | Composable <tt>asTypeOf</tt>. Useful for constraining excess
--   polymorphism, <tt>foo . (id :: As Int) . bar</tt>.
type As a = Equality' a a

-- | Isomorphism families can be composed with another <a>Lens</a> using
--   (<tt>.</tt>) and <tt>id</tt>.
--   
--   Note: Composition with an <a>Iso</a> is index- and measure-
--   preserving.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | A <a>Prism</a> <tt>l</tt> is a <a>Traversal</a> that can also be
--   turned around with <a>re</a> to obtain a <a>Getter</a> in the opposite
--   direction.
--   
--   There are two laws that a <a>Prism</a> should satisfy:
--   
--   First, if I <a>re</a> or <a>review</a> a value with a <a>Prism</a> and
--   then <a>preview</a> or use (<a>^?</a>), I will get it back:
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b)  <tt>Just</tt> b
--   </pre>
--   
--   Second, if you can extract a value <tt>a</tt> using a <a>Prism</a>
--   <tt>l</tt> from a value <tt>s</tt>, then the value <tt>s</tt> is
--   completely described by <tt>l</tt> and <tt>a</tt>:
--   
--   If <tt><a>preview</a> l s  <tt>Just</tt> a</tt> then
--   <tt><a>review</a> l a  s</tt>
--   
--   These two laws imply that the <a>Traversal</a> laws hold for every
--   <a>Prism</a> and that we <a>traverse</a> at most 1 element:
--   
--   <pre>
--   <a>lengthOf</a> l x <tt>&lt;=</tt> 1
--   </pre>
--   
--   It may help to think of this as a <a>Iso</a> that can be partial in
--   one direction.
--   
--   Every <a>Prism</a> is a valid <a>Traversal</a>.
--   
--   Every <a>Iso</a> is a valid <a>Prism</a>.
--   
--   For example, you might have a <tt><a>Prism'</a> <tt>Integer</tt>
--   <a>Natural</a></tt> allows you to always go from a <a>Natural</a> to
--   an <tt>Integer</tt>, and provide you with tools to check if an
--   <tt>Integer</tt> is a <a>Natural</a> and/or to edit one if it is.
--   
--   <pre>
--   <tt>nat</tt> :: <a>Prism'</a> <tt>Integer</tt> <a>Natural</a>
--   <tt>nat</tt> = <a>prism</a> <tt>toInteger</tt> <tt>$</tt> \ i -&gt;
--      if i <tt>&lt;</tt> 0
--      then <tt>Left</tt> i
--      else <tt>Right</tt> (<tt>fromInteger</tt> i)
--   </pre>
--   
--   Now we can ask if an <tt>Integer</tt> is a <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5^?nat
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-5)^?nat
--   Nothing
--   </pre>
--   
--   We can update the ones that are:
--   
--   <pre>
--   &gt;&gt;&gt; (-3,4) &amp; both.nat *~ 2
--   (-3,8)
--   </pre>
--   
--   And we can then convert from a <a>Natural</a> to an <tt>Integer</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^. re nat -- :: Natural
--   5
--   </pre>
--   
--   Similarly we can use a <a>Prism</a> to <a>traverse</a> the
--   <tt>Left</tt> half of an <tt>Either</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" &amp; _Left %~ length
--   Left 5
--   </pre>
--   
--   or to construct an <tt>Either</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
--   
--   such that if you query it with the <a>Prism</a>, you will get your
--   original input back.
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left ^? _Left
--   Just 5
--   </pre>
--   
--   Another interesting way to think of a <a>Prism</a> is as the
--   categorical dual of a <a>Lens</a> -- a co-<a>Lens</a>, so to speak.
--   This is what permits the construction of <a>outside</a>.
--   
--   Note: Composition with a <a>Prism</a> is index-preserving.
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | A <a>Lens</a> is actually a lens family as described in
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   With great power comes great responsibility and a <a>Lens</a> is
--   subject to the three common sense <a>Lens</a> laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s)   v
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>set</a> l (<a>view</a> l s) s   s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>set</a> l v' (<a>set</a> l v s)  <a>set</a> l v' s
--   </pre>
--   
--   These laws are strong enough that the 4 type parameters of a
--   <a>Lens</a> cannot vary fully independently. For more on how they
--   interact, read the "Why is it a Lens Family?" section of
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   There are some emergent properties of these laws:
--   
--   1) <tt><a>set</a> l s</tt> must be injective for every <tt>s</tt> This
--   is a consequence of law #1
--   
--   2) <tt><a>set</a> l</tt> must be surjective, because of law #2, which
--   indicates that it is possible to obtain any <tt>v</tt> from some
--   <tt>s</tt> such that <tt><a>set</a> s v = s</tt>
--   
--   3) Given just the first two laws you can prove a weaker form of law #3
--   where the values <tt>v</tt> that you are setting match:
--   
--   <pre>
--   <a>set</a> l v (<a>set</a> l v s)  <a>set</a> l v s
--   </pre>
--   
--   Every <a>Lens</a> can be used directly as a <a>Setter</a> or
--   <a>Traversal</a>.
--   
--   You can also use a <a>Lens</a> for <a>Getting</a> as if it were a
--   <a>Fold</a> or <a>Getter</a>.
--   
--   Since every <a>Lens</a> is a valid <a>Traversal</a>, the
--   <a>Traversal</a> laws are required of any <a>Lens</a> you create:
--   
--   <pre>
--   l <a>pure</a>  <a>pure</a>
--   <a>fmap</a> (l f) <tt>.</tt> l g  <a>getCompose</a> <tt>.</tt> l (<a>Compose</a> <tt>.</tt> <a>fmap</a> f <tt>.</tt> g)
--   </pre>
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; <a>LensLike</a> f s t a b
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | A <a>Traversal</a> can be used directly as a <a>Setter</a> or a
--   <a>Fold</a> (but not as a <a>Lens</a>) and provides the ability to
--   both read and update multiple fields, subject to some relatively weak
--   <a>Traversal</a> laws.
--   
--   These have also been known as multilenses, but they have the signature
--   and spirit of
--   
--   <pre>
--   <a>traverse</a> :: <a>Traversable</a> f =&gt; <a>Traversal</a> (f a) (f b) a b
--   </pre>
--   
--   and the more evocative name suggests their application.
--   
--   Most of the time the <a>Traversal</a> you will want to use is just
--   <a>traverse</a>, but you can also pass any <a>Lens</a> or <a>Iso</a>
--   as a <a>Traversal</a>, and composition of a <a>Traversal</a> (or
--   <a>Lens</a> or <a>Iso</a>) with a <a>Traversal</a> (or <a>Lens</a> or
--   <a>Iso</a>) using (<tt>.</tt>) forms a valid <a>Traversal</a>.
--   
--   The laws for a <a>Traversal</a> <tt>t</tt> follow from the laws for
--   <a>Traversable</a> as stated in "The Essence of the Iterator Pattern".
--   
--   <pre>
--   t <a>pure</a>  <a>pure</a>
--   <a>fmap</a> (t f) <tt>.</tt> t g  <a>getCompose</a> <tt>.</tt> t (<a>Compose</a> <tt>.</tt> <a>fmap</a> f <tt>.</tt> g)
--   </pre>
--   
--   One consequence of this requirement is that a <a>Traversal</a> needs
--   to leave the same number of elements as a candidate for subsequent
--   <a>Traversal</a> that it started with. Another testament to the
--   strength of these laws is that the caveat expressed in section 5.5 of
--   the "Essence of the Iterator Pattern" about exotic <a>Traversable</a>
--   instances that <a>traverse</a> the same entry multiple times was
--   actually already ruled out by the second law in that same paper!
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a
type Traversal1 s t a b = forall f. Apply f => (a -> f b) -> s -> f t
type Traversal1' s a = Traversal1 s s a a

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a)  <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <tt>id</tt>  <tt>id</tt>
--   <a>over</a> l f <tt>.</tt> <a>over</a> l g  <a>over</a> l (f <tt>.</tt> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a>  <a>pure</a>
--   l f <tt>.</tt> <a>untainted</a> <tt>.</tt> l g  l (f <tt>.</tt> <a>untainted</a> <tt>.</tt> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<tt>.</tt>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <tt>Char</tt>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Setter'</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s

-- | A relevant Fold (aka <a>Fold1</a>) has one or more targets.
type Fold1 s a = forall f. (Contravariant f, Apply f) => (a -> f a) -> s -> f s

-- | Every <a>IndexedLens</a> is a valid <a>Lens</a> and a valid
--   <a>IndexedTraversal</a>.
type IndexedLens i s t a b = forall f p. (Indexable i p, Functor f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedLens'</a> i = <a>Simple</a> (<a>IndexedLens</a> i)
--   </pre>
type IndexedLens' i s a = IndexedLens i s s a a

-- | Every <a>IndexedTraversal</a> is a valid <a>Traversal</a> or
--   <a>IndexedFold</a>.
--   
--   The <a>Indexed</a> constraint is used to allow an
--   <a>IndexedTraversal</a> to be used directly as a <a>Traversal</a>.
--   
--   The <a>Traversal</a> laws are still required to hold.
--   
--   In addition, the index <tt>i</tt> should satisfy the requirement that
--   it stays unchanged even when modifying the value <tt>a</tt>, otherwise
--   traversals like <tt>indices</tt> break the <a>Traversal</a> laws.
type IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall p f. (Indexable i p, Apply f) => p a (f b) -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a

-- | Every <a>IndexedSetter</a> is a valid <a>Setter</a>.
--   
--   The <a>Setter</a> laws are still required to hold.
type IndexedSetter i s t a b = forall f p. (Indexable i p, Settable f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedSetter'</a> i = <a>Simple</a> (<a>IndexedSetter</a> i)
--   </pre>
type IndexedSetter' i s a = IndexedSetter i s s a a

-- | Every <a>IndexedGetter</a> is a valid <a>IndexedFold</a> and can be
--   used for <a>Getting</a> like a <a>Getter</a>.
type IndexedGetter i s a = forall p f. (Indexable i p, Contravariant f, Functor f) => p a (f a) -> s -> f s

-- | Every <a>IndexedFold</a> is a valid <a>Fold</a> and can be used for
--   <a>Getting</a>.
type IndexedFold i s a = forall p f. (Indexable i p, Contravariant f, Applicative f) => p a (f a) -> s -> f s
type IndexedFold1 i s a = forall p f. (Indexable i p, Contravariant f, Apply f) => p a (f a) -> s -> f s

-- | An <a>IndexPreservingLens</a> leaves any index it is composed with
--   alone.
type IndexPreservingLens s t a b = forall p f. (Conjoined p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>IndexPreservingLens'</a> = <a>Simple</a> <a>IndexPreservingLens</a>
--   </pre>
type IndexPreservingLens' s a = IndexPreservingLens s s a a

-- | An <a>IndexPreservingLens</a> leaves any index it is composed with
--   alone.
type IndexPreservingTraversal s t a b = forall p f. (Conjoined p, Applicative f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>IndexPreservingTraversal'</a> = <a>Simple</a> <a>IndexPreservingTraversal</a>
--   </pre>
type IndexPreservingTraversal' s a = IndexPreservingTraversal s s a a
type IndexPreservingTraversal1 s t a b = forall p f. (Conjoined p, Apply f) => p a (f b) -> p s (f t)
type IndexPreservingTraversal1' s a = IndexPreservingTraversal1 s s a a

-- | An <a>IndexPreservingSetter</a> can be composed with a
--   <a>IndexedSetter</a>, <a>IndexedTraversal</a> or <a>IndexedLens</a>
--   and leaves the index intact, yielding an <a>IndexedSetter</a>.
type IndexPreservingSetter s t a b = forall p f. (Conjoined p, Settable f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <tt>IndexedPreservingSetter'</tt> i = <a>Simple</a> <tt>IndexedPreservingSetter</tt>
--   </pre>
type IndexPreservingSetter' s a = IndexPreservingSetter s s a a

-- | An <a>IndexPreservingGetter</a> can be used as a <a>Getter</a>, but
--   when composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a>, <a>IndexedFold</a> or
--   <a>IndexedGetter</a> respectively.
type IndexPreservingGetter s a = forall p f. (Conjoined p, Contravariant f, Functor f) => p a (f a) -> p s (f s)

-- | An <a>IndexPreservingFold</a> can be used as a <a>Fold</a>, but when
--   composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a> respectively.
type IndexPreservingFold s a = forall p f. (Conjoined p, Contravariant f, Applicative f) => p a (f a) -> p s (f s)
type IndexPreservingFold1 s a = forall p f. (Conjoined p, Contravariant f, Apply f) => p a (f a) -> p s (f s)

-- | A <a>Simple</a> <a>Lens</a>, <a>Simple</a> <a>Traversal</a>, ... can
--   be used instead of a <a>Lens</a>,<a>Traversal</a>, ... whenever the
--   type variables don't change upon setting a value.
--   
--   <pre>
--   <a>_imagPart</a> :: <a>Simple</a> <a>Lens</a> (<a>Complex</a> a) a
--   <a>traversed</a> :: <a>Simple</a> (<a>IndexedTraversal</a> <tt>Int</tt>) [a] a
--   </pre>
--   
--   Note: To use this alias in your own code with <tt><a>LensLike</a>
--   f</tt> or <a>Setter</a>, you may have to turn on
--   <tt>LiberalTypeSynonyms</tt>.
--   
--   This is commonly abbreviated as a "prime" marker, <i>e.g.</i>
--   <a>Lens'</a> = <a>Simple</a> <a>Lens</a>.
type Simple f s a = f s s a a

-- | Many combinators that accept a <a>Lens</a> can also accept a
--   <a>Traversal</a> in limited situations.
--   
--   They do so by specializing the type of <a>Functor</a> that they
--   require of the caller.
--   
--   If a function accepts a <tt><a>LensLike</a> f s t a b</tt> for some
--   <a>Functor</a> <tt>f</tt>, then they may be passed a <a>Lens</a>.
--   
--   Further, if <tt>f</tt> is an <a>Applicative</a>, they may also be
--   passed a <a>Traversal</a>.
type LensLike f s t a b = (a -> f b) -> s -> f t

-- | <pre>
--   type <a>LensLike'</a> f = <a>Simple</a> (<a>LensLike</a> f)
--   </pre>
type LensLike' f s a = LensLike f s s a a

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
type Over p f s t a b = p a (f b) -> s -> f t

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
--   
--   <pre>
--   type <a>Over'</a> p f = <a>Simple</a> (<a>Over</a> p f)
--   </pre>
type Over' p f s a = Over p f s s a a

-- | Convenient alias for constructing indexed lenses and their ilk.
type IndexedLensLike i f s t a b = forall p. Indexable i p => p a (f b) -> s -> f t

-- | Convenient alias for constructing simple indexed lenses and their ilk.
type IndexedLensLike' i f s a = IndexedLensLike i f s s a a

-- | <pre>
--   type <a>LensLike</a> f s t a b = <a>Optical</a> (-&gt;) (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Over</a> p f s t a b = <a>Optical</a> p (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Optic</a> p f s t a b = <a>Optical</a> p p f s t a b
--   </pre>
type Optical p q f s t a b = p a (f b) -> q s (f t)

-- | <pre>
--   type <a>Optical'</a> p q f s a = <a>Simple</a> (<a>Optical</a> p q f) s a
--   </pre>
type Optical' p q f s a = Optical p q f s s a a

-- | A valid <a>Optic</a> <tt>l</tt> should satisfy the laws:
--   
--   <pre>
--   l <a>pure</a>  <a>pure</a>
--   l (<tt>Procompose</tt> f g) = <tt>Procompose</tt> (l f) (l g)
--   </pre>
--   
--   This gives rise to the laws for <a>Equality</a>, <a>Iso</a>,
--   <a>Prism</a>, <a>Lens</a>, <a>Traversal</a>, <a>Traversal1</a>,
--   <a>Setter</a>, <a>Fold</a>, <a>Fold1</a>, and <a>Getter</a> as well
--   along with their index-preserving variants.
--   
--   <pre>
--   type <a>LensLike</a> f s t a b = <a>Optic</a> (-&gt;) f s t a b
--   </pre>
type Optic p f s t a b = p a (f b) -> p s (f t)

-- | <pre>
--   type <a>Optic'</a> p q f s a = <a>Simple</a> (<a>Optic</a> p q f) s a
--   </pre>
type Optic' p f s a = Optic p f s s a a


-- | A <tt><a>Setter</a> s t a b</tt> is a generalization of <a>fmap</a>
--   from <a>Functor</a>. It allows you to map into a structure and change
--   out the contents, but it isn't strong enough to allow you to enumerate
--   those contents. Starting with <tt><a>fmap</a> :: <a>Functor</a> f
--   =&gt; (a -&gt; b) -&gt; f a -&gt; f b</tt> we monomorphize the type to
--   obtain <tt>(a -&gt; b) -&gt; s -&gt; t</tt> and then decorate it with
--   <a>Identity</a> to obtain:
--   
--   <pre>
--   type <a>Setter</a> s t a b = (a -&gt; <a>Identity</a> b) -&gt; s -&gt; <a>Identity</a> t
--   </pre>
--   
--   Every <a>Traversal</a> is a valid <a>Setter</a>, since <a>Identity</a>
--   is <a>Applicative</a>.
--   
--   Everything you can do with a <a>Functor</a>, you can do with a
--   <a>Setter</a>. There are combinators that generalize <a>fmap</a> and
--   (<a>&lt;$</a>).
module Control.Lens.Setter

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a)  <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <tt>id</tt>  <tt>id</tt>
--   <a>over</a> l f <tt>.</tt> <a>over</a> l g  <a>over</a> l (f <tt>.</tt> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a>  <a>pure</a>
--   l f <tt>.</tt> <a>untainted</a> <tt>.</tt> l g  l (f <tt>.</tt> <a>untainted</a> <tt>.</tt> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<tt>.</tt>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <tt>Char</tt>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Setter'</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | Every <a>IndexedSetter</a> is a valid <a>Setter</a>.
--   
--   The <a>Setter</a> laws are still required to hold.
type IndexedSetter i s t a b = forall f p. (Indexable i p, Settable f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedSetter'</a> i = <a>Simple</a> (<a>IndexedSetter</a> i)
--   </pre>
type IndexedSetter' i s a = IndexedSetter i s s a a

-- | Running a <a>Setter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type ASetter s t a b = (a -> Identity b) -> s -> Identity t

-- | This is a useful alias for use when consuming a <a>Setter'</a>.
--   
--   Most user code will never have to use this type.
--   
--   <pre>
--   type <a>ASetter'</a> = <a>Simple</a> <a>ASetter</a>
--   </pre>
type ASetter' s a = ASetter s s a a

-- | Running an <a>IndexedSetter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type AnIndexedSetter i s t a b = Indexed i a (Identity b) -> s -> Identity t

-- | <pre>
--   type <a>AnIndexedSetter'</a> i = <a>Simple</a> (<a>AnIndexedSetter</a> i)
--   </pre>
type AnIndexedSetter' i s a = AnIndexedSetter i s s a a

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter</a> and <a>AnIndexedSetter</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting p s t a b = p a (Identity b) -> s -> Identity t

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter'</a> and <a>AnIndexedSetter'</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting' p s a = Setting p s s a a

-- | Build a <a>Setter</a>, <a>IndexedSetter</a> or
--   <a>IndexPreservingSetter</a> depending on your choice of
--   <a>Profunctor</a>.
--   
--   <pre>
--   <a>sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b

-- | Build an index-preserving <a>Setter</a> from a map-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a>  <a>id</a>
--   f g <a>.</a> f h  f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>setting</a> <a>.</a> <a>over</a>  <a>id</a>
--   <a>over</a> <a>.</a> <a>setting</a>  <a>id</a>
--   </pre>
--   
--   Another way to view <a>sets</a> is that it takes a "semantic editor
--   combinator" and transforms it into a <a>Setter</a>.
--   
--   <pre>
--   <a>setting</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b

-- | Restore <a>ASetter</a> to a full <a>Setter</a>.
cloneSetter :: ASetter s t a b -> Setter s t a b

-- | Build an <a>IndexPreservingSetter</a> from any <a>Setter</a>.
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b

-- | Clone an <a>IndexedSetter</a>.
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | This <a>Setter</a> can be used to map over all of the values in a
--   <a>Functor</a>.
--   
--   <pre>
--   <a>fmap</a>  <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a>  <a>over</a> <a>traverse</a>
--   (<a>&lt;$</a>)  <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (+1) [1,2,3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped x [a,b,c]
--   [x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[a,b],[c]] &amp; mapped.mapped +~ x
--   [[a + x,b + x],[c + x]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (mapped._2) length [("hello","world"),("leaders","!!!")]
--   [("hello",5),("leaders",3)]
--   </pre>
--   
--   <pre>
--   <a>mapped</a> :: <a>Functor</a> f =&gt; <a>Setter</a> (f a) (f b) a b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>fmap</a></tt>.
mapped :: Functor f => Setter (f a) (f b) a b

-- | This <tt>setter</tt> can be used to modify all of the values in a
--   <a>Monad</a>.
--   
--   You sometimes have to use this rather than <a>mapped</a> -- due to
--   temporary insanity <a>Functor</a> is not a superclass of <a>Monad</a>.
--   
--   <pre>
--   <a>liftM</a>  <a>over</a> <a>lifted</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over lifted f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set lifted b (Just a)
--   Just b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>liftM</a></tt>.
lifted :: Monad m => Setter (m a) (m b) a b

-- | This <a>Setter</a> can be used to map over all of the inputs to a
--   <a>Contravariant</a>.
--   
--   <pre>
--   <a>contramap</a>  <a>over</a> <a>contramapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getPredicate (over contramapped (*2) (Predicate even)) 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getOp (over contramapped (*5) (Op show)) 100
--   "500"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Prelude.map ($ 1) $ over (mapped . _Unwrapping' Op . contramapped) (*12) [(*2),(+1),(^3)]
--   [24,13,1728]
--   </pre>
contramapped :: Contravariant f => Setter (f b) (f a) a b

-- | This <a>Setter</a> can be used to map over the input of a
--   <a>Profunctor</a>.
--   
--   The most common <a>Profunctor</a> to use this with is
--   <tt>(-&gt;)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) g x
--   g (f x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ show) length [1,2,3]
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) h x y
--   h (f x) y
--   </pre>
--   
--   Map over the argument of the result of a function -- i.e., its second
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; (mapped.argument %~ f) h x y
--   h x (f y)
--   </pre>
--   
--   <pre>
--   <a>argument</a> :: <a>Setter</a> (b -&gt; r) (a -&gt; r) a b
--   </pre>
argument :: Profunctor p => Setter (p b r) (p a r) a b

-- | Modify the target of a <a>Lens</a> or all the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a function.
--   
--   <pre>
--   <a>fmap</a>  <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a>  <a>over</a> <a>traverse</a>
--   <a>sets</a> <a>.</a> <a>over</a>  <a>id</a>
--   <a>over</a> <a>.</a> <a>sets</a>  <a>id</a>
--   </pre>
--   
--   Given any valid <a>Setter</a> <tt>l</tt>, you can also rely on the
--   law:
--   
--   <pre>
--   <a>over</a> l f <a>.</a> <a>over</a> l g = <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (over mapped g [a,b,c]) == over mapped (f . g) [a,b,c]
--   True
--   </pre>
--   
--   Another way to view <a>over</a> is to say that it transforms a
--   <a>Setter</a> into a "semantic editor combinator".
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (Just a)
--   Just (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (*10) [1,2,3]
--   [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 show (10,20)
--   ("10",20)
--   </pre>
--   
--   <pre>
--   <a>over</a> :: <a>Setter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   <a>over</a> :: <a>ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
over :: Profunctor p => Setting p s t a b -> p a b -> s -> t

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   <pre>
--   (<a>&lt;$</a>)  <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _2 "hello" (1,())
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped () [1,2,3,4]
--   [(),(),(),()]
--   </pre>
--   
--   Note: Attempting to <a>set</a> a <a>Fold</a> or <a>Getter</a> will
--   fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set</a> :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a  <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f  <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f  <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: Profunctor p => Setting p s t a b -> p a b -> s -> t

-- | Increment the target(s) of a numerically valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 +~ c
--   (a + c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both +~ c
--   (a + c,b + c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 +~ 1
--   (1,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(a,b),(c,d)] &amp; traverse.both +~ e
--   [(a + e,b + e),(c + e,d + e)]
--   </pre>
--   
--   <pre>
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(+~) :: Num a => ASetter s t a a -> a -> s -> t

-- | Decrement the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 -~ c
--   (a - c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both -~ c
--   (a - c,b - c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 -~ 2 $ (1,2)
--   (-1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapped.mapped -~ 1 $ [[4,5],[6,7]]
--   [[3,4],[5,6]]
--   </pre>
--   
--   <pre>
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(-~) :: Num a => ASetter s t a a -> a -> s -> t

-- | Multiply the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 *~ c
--   (a * c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both *~ c
--   (a * c,b * c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 *~ 4
--   (1,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just 24 &amp; mapped *~ 2
--   Just 48
--   </pre>
--   
--   <pre>
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(*~) :: Num a => ASetter s t a a -> a -> s -> t

-- | Divide the target(s) of a numerically valued <a>Lens</a>, <a>Iso</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 //~ c
--   (a / c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both //~ c
--   (a / c,b / c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 //~ 2
--   ("Hawaii",5.0)
--   </pre>
--   
--   <pre>
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,3) &amp; _2 ^~ 2
--   (1,9)
--   </pre>
--   
--   <pre>
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t

-- | Raise the target(s) of a fractionally valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 ^^~ (-1)
--   (1,0.5)
--   </pre>
--   
--   <pre>
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t

-- | Raise the target(s) of a floating-point valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an arbitrary power.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 **~ c
--   (a**c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both **~ c
--   (a**c,b**c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 **~ 10 $ (3,2)
--   (3,1024.0)
--   </pre>
--   
--   <pre>
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(**~) :: Floating a => ASetter s t a a -> a -> s -> t

-- | Logically <a>||</a> the target(s) of a <a>Bool</a>-valued <a>Lens</a>
--   or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ True $ (False,True)
--   (True,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ False $ (False,True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   (<a>||~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t

-- | Modify the target of a monoidally valued by <a>mappend</a>ing another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Monoid a => ASetter s t a a -> a -> s -> t

-- | Logically <a>&amp;&amp;</a> the target(s) of a <a>Bool</a>-valued
--   <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ True $ (False, True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ False $ (False, True)
--   (False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t

-- | Set with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.~</a> t</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;.~ c
--   (c,(c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("good","morning","vietnam") &amp; _3 &lt;.~ "world"
--   ("world",("good","morning","world"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,Map.fromList [("goodnight","gracie")]) &amp; _2.at "hello" &lt;.~ Just "world"
--   (Just "world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<.~) :: ASetter s t a b -> b -> s -> (b, t)

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t  <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t

-- | Set to <a>Just</a> a value with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?~</a> d</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   ("world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an alias for (<a>.=</a>).
--   
--   <pre>
--   &gt;&gt;&gt; execState (do assign _1 c; assign _2 d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
assign :: MonadState s m => ASetter s s a b -> b -> m ()

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .= c; _2 .= d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
--   
--   <i>It puts the state in the monad or it gets the hose again.</i>
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()

-- | Map over the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= f;_2 %= g) (a,b)
--   (f a,g b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do both %= f) (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; m ()
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>ASetter</a> s s a b -&gt; (a -&gt; b) -&gt; m ()
--   </pre>
(%=) :: (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by adding a value.
--   
--   Example:
--   
--   <pre>
--   <tt>fresh</tt> :: <a>MonadState</a> <a>Int</a> m =&gt; m <a>Int</a>
--   <tt>fresh</tt> = do
--     <a>id</a> <a>+=</a> 1
--     <a>use</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 += c; _2 += d) (a,b)
--   (a + c,b + d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1.at 1.non 0 += 10) (Map.fromList [(2,100)],"hello")
--   (fromList [(1,10),(2,100)],"hello")
--   </pre>
--   
--   <pre>
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by subtracting a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 -= c; _2 -= d) (a,b)
--   (a - c,b - d)
--   </pre>
--   
--   <pre>
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by multiplying by value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 *= c; _2 *= d) (a,b)
--   (a * c,b * d)
--   </pre>
--   
--   <pre>
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by dividing by a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 //= c; _2 //= d) (a,b)
--   (a / c,b / d)
--   </pre>
--   
--   <pre>
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an arbitrary power
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 **= c; _2 **= d) (a,b)
--   (a**c,b**d)
--   </pre>
--   
--   <pre>
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, 'Iso, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>||</a> with a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ||= True; _2 ||= False; _3 ||= True; _4 ||= False) (True,True,False,False)
--   (True,True,True,False)
--   </pre>
--   
--   <pre>
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by <a>mappend</a>ing a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &lt;&gt;= Sum c; _2 &lt;&gt;= Product d) (Sum a,Product b)
--   (Sum {getSum = a + c},Product {getProduct = b * d})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;&gt;= "!!!") ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Setter'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(<>=) :: (MonadState s m, Monoid a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>&amp;&amp;</a> with a
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &amp;&amp;= True; _2 &amp;&amp;= False; _3 &amp;&amp;= True; _4 &amp;&amp;= False) (True,True,False,False)
--   (True,False,False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()

-- | Set with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>_2</a> <a>&lt;.=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; b -&gt; m b
--   </pre>
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with
--   <a>Just</a> a new value, irrespective of the old.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do at 1 ?= a; at 2 ?= b) Map.empty
--   fromList [(1,a),(2,b)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ?= b; _2 ?= c) (Just a, Nothing)
--   (Just b,Just c)
--   </pre>
--   
--   <pre>
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s (<a>Maybe</a> a)       -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s (<a>Maybe</a> a)      -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s (<a>Maybe</a> a) -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s (<a>Maybe</a> a)    -&gt; a -&gt; m ()
--   </pre>
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()

-- | Set <a>Just</a> a value with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>at</a> "foo" <a>&lt;?=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a (<a>Maybe</a> b)    -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a (<a>Maybe</a> b)       -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a (<a>Maybe</a> b)      -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a (<a>Maybe</a> b) -&gt; b -&gt; m b
--   </pre>
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b

-- | Run a monadic action, and set all of the targets of a <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to its result.
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; m b -&gt; m ()
--   </pre>
--   
--   As a reasonable mnemonic, this lets you store the result of a monadic
--   action in a <a>Lens</a> rather than in a local variable.
--   
--   <pre>
--   do foo &lt;- bar
--      ...
--   </pre>
--   
--   will store the result in a variable, while
--   
--   <pre>
--   do foo <a>&lt;~</a> bar
--      ...
--   </pre>
--   
--   will store the result in a <a>Lens</a>, <a>Setter</a>, or
--   <a>Traversal</a>.
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()

-- | Write to a fragment of a larger <tt>Writer</tt> format.
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()

-- | This is a generalization of <a>pass</a> that alows you to modify just
--   a portion of the resulting <a>MonadWriter</a>.
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a

-- | This is a generalization of <a>pass</a> that alows you to modify just
--   a portion of the resulting <a>MonadWriter</a> with access to the index
--   of an <a>IndexedSetter</a>.
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a

-- | This is a generalization of <a>censor</a> that alows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>.
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a

-- | This is a generalization of <a>censor</a> that alows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>, with
--   access to the index of an <a>IndexedSetter</a>.
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter'</a> or <a>Traversal</a> with a constant value, without
--   changing its type.
--   
--   This is a type restricted version of <a>set</a>, which retains the
--   type of the original.
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped x [a,b,c,d]
--   [x,x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' _2 "hello" (1,"world")
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped 0 [1,2,3,4]
--   [0,0,0,0]
--   </pre>
--   
--   Note: Attempting to adjust <a>set'</a> a <a>Fold</a> or <a>Getter</a>
--   will fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set'</a> :: <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
set' :: ASetter' s a -> a -> s -> s

-- | Map with index. (Deprecated alias for <a>iover</a>).
--   
--   When you do not need access to the index, then <a>mapOf</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>mapOf</a> l  <a>imapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapOf</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>

-- | <i>Deprecated: Use <a>iover</a></i>
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Map with index. This is an alias for <a>imapOf</a>.
--   
--   When you do not need access to the index, then <a>over</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>over</a> l  <a>iover</a> l <a>.</a> <a>const</a>
--   <a>iover</a> l  <a>over</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>iover</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Set with index. Equivalent to <a>iover</a> with the current value
--   ignored.
--   
--   When you do not need access to the index, then <a>set</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>set</a> l  <a>iset</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iset</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t

-- | Build an <a>IndexedSetter</a> from an <a>imap</a>-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a>  <a>id</a>
--   f g <a>.</a> f h  f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>isets</a> <a>.</a> <a>iover</a>  <a>id</a>
--   <a>iover</a> <a>.</a> <a>isets</a>  <a>id</a>
--   </pre>
--   
--   Another way to view <a>sets</a> is that it takes a "semantic editor
--   combinator" and transforms it into a <a>Setter</a>.
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b

-- | Adjust every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>%@~</a>)  <a>iover</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>%~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%~</a> f  l <a>%@~</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Replace every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>.@~</a>)  <a>iset</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>.~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.~</a> b  l <a>.@~</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t

-- | Adjust every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>%=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%=</a> f  l <a>%@=</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   </pre>
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()

-- | Replace every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>.=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.=</a> b  l <a>.@=</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; m ()
--   </pre>
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()

-- | Run an arrow command and use the output to set all the targets of a
--   <a>Lens</a>, <a>Setter</a> or <a>Traversal</a> to the result.
--   
--   <a>assignA</a> can be used very similarly to (<a>&lt;~</a>), except
--   that the type of the object being modified can change; for example:
--   
--   <pre>
--   runKleisli action ((), (), ()) where
--     action =      assignA _1 (Kleisli (const getVal1))
--              &gt;&gt;&gt; assignA _2 (Kleisli (const getVal2))
--              &gt;&gt;&gt; assignA _3 (Kleisli (const getVal3))
--     getVal1 :: Either String Int
--     getVal1 = ...
--     getVal2 :: Either String Bool
--     getVal2 = ...
--     getVal3 :: Either String Char
--     getVal3 = ...
--   </pre>
--   
--   has the type <tt><a>Either</a> <a>String</a> (<a>Int</a>, <a>Bool</a>,
--   <a>Char</a>)</tt>
--   
--   <pre>
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Iso</a> s t a b       -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Lens</a> s t a b      -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Traversal</a> s t a b -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Setter</a> s t a b    -&gt; p s b -&gt; p s t
--   </pre>
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t

-- | Anything <a>Settable</a> must be isomorphic to the <a>Identity</a>
--   <a>Functor</a>.
class (Applicative f, Distributive f, Traversable f) => Settable f where untaintedDot g = g `seq` rmap untainted g taintedDot g = g `seq` rmap pure g
newtype Identity a :: * -> *
Identity :: a -> Identity a
runIdentity :: Identity a -> a

-- | <a>mapOf</a> is a deprecated alias for <a>over</a>.

-- | <i>Deprecated: Use <a>over</a></i>
mapOf :: Profunctor p => Setting p s t a b -> p a b -> s -> t


-- | A <tt><a>Lens</a> s t a b</tt> is a purely functional reference.
--   
--   While a <a>Traversal</a> could be used for <a>Getting</a> like a valid
--   <a>Fold</a>, it wasn't a valid <a>Getter</a> as a <a>Getter</a> can't
--   require an <a>Applicative</a> constraint.
--   
--   <a>Functor</a>, however, is a constraint on both.
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   Every <a>Lens</a> is a valid <a>Setter</a>.
--   
--   Every <a>Lens</a> can be used for <a>Getting</a> like a <a>Fold</a>
--   that doesn't use the <a>Applicative</a> or <tt>Contravariant</tt>.
--   
--   Every <a>Lens</a> is a valid <a>Traversal</a> that only uses the
--   <a>Functor</a> part of the <a>Applicative</a> it is supplied.
--   
--   Every <a>Lens</a> can be used for <a>Getting</a> like a valid
--   <a>Getter</a>.
--   
--   Since every <a>Lens</a> can be used for <a>Getting</a> like a valid
--   <a>Getter</a> it follows that it must view exactly one element in the
--   structure.
--   
--   The <a>Lens</a> laws follow from this property and the desire for it
--   to act like a <a>Traversable</a> when used as a <a>Traversal</a>.
--   
--   In the examples below, <tt>getter</tt> and <tt>setter</tt> are
--   supplied as example getters and setters, and are not actual functions
--   supplied by this package.
module Control.Lens.Lens

-- | A <a>Lens</a> is actually a lens family as described in
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   With great power comes great responsibility and a <a>Lens</a> is
--   subject to the three common sense <a>Lens</a> laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s)   v
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>set</a> l (<a>view</a> l s) s   s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>set</a> l v' (<a>set</a> l v s)  <a>set</a> l v' s
--   </pre>
--   
--   These laws are strong enough that the 4 type parameters of a
--   <a>Lens</a> cannot vary fully independently. For more on how they
--   interact, read the "Why is it a Lens Family?" section of
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   There are some emergent properties of these laws:
--   
--   1) <tt><a>set</a> l s</tt> must be injective for every <tt>s</tt> This
--   is a consequence of law #1
--   
--   2) <tt><a>set</a> l</tt> must be surjective, because of law #2, which
--   indicates that it is possible to obtain any <tt>v</tt> from some
--   <tt>s</tt> such that <tt><a>set</a> s v = s</tt>
--   
--   3) Given just the first two laws you can prove a weaker form of law #3
--   where the values <tt>v</tt> that you are setting match:
--   
--   <pre>
--   <a>set</a> l v (<a>set</a> l v s)  <a>set</a> l v s
--   </pre>
--   
--   Every <a>Lens</a> can be used directly as a <a>Setter</a> or
--   <a>Traversal</a>.
--   
--   You can also use a <a>Lens</a> for <a>Getting</a> as if it were a
--   <a>Fold</a> or <a>Getter</a>.
--   
--   Since every <a>Lens</a> is a valid <a>Traversal</a>, the
--   <a>Traversal</a> laws are required of any <a>Lens</a> you create:
--   
--   <pre>
--   l <a>pure</a>  <a>pure</a>
--   <a>fmap</a> (l f) <tt>.</tt> l g  <a>getCompose</a> <tt>.</tt> l (<a>Compose</a> <tt>.</tt> <a>fmap</a> f <tt>.</tt> g)
--   </pre>
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; <a>LensLike</a> f s t a b
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | Every <a>IndexedLens</a> is a valid <a>Lens</a> and a valid
--   <a>IndexedTraversal</a>.
type IndexedLens i s t a b = forall f p. (Indexable i p, Functor f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedLens'</a> i = <a>Simple</a> (<a>IndexedLens</a> i)
--   </pre>
type IndexedLens' i s a = IndexedLens i s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Lens</a>.
--   
--   This type can also be used when you need to store a <a>Lens</a> in a
--   container, since it is rank-1. You can turn them back into a
--   <a>Lens</a> with <a>cloneLens</a>, or use it directly with combinators
--   like <a>storing</a> and (<a>^#</a>).
type ALens s t a b = LensLike (Pretext (->) a b) s t a b

-- | <pre>
--   type <a>ALens'</a> = <a>Simple</a> <a>ALens</a>
--   </pre>
type ALens' s a = ALens s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedLens</a>
type AnIndexedLens i s t a b = Optical (Indexed i) (->) (Pretext (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedLens'</a> = <a>Simple</a> (<a>AnIndexedLens</a> i)
--   </pre>
type AnIndexedLens' i s a = AnIndexedLens i s s a a

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Build an <a>IndexedLens</a> from a <a>Getter</a> and a <a>Setter</a>.
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b

-- | Build an index-preserving <a>Lens</a> from a <a>Getter</a> and a
--   <a>Setter</a>.
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b

-- | (<a>%%~</a>) can be used in one of two scenarios:
--   
--   When applied to a <a>Lens</a>, it can edit the target of the
--   <a>Lens</a> in a structure, extracting a functorial result.
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting an applicative summary of its actions.
--   
--   For all that the definition of this combinator is just:
--   
--   <pre>
--   (<a>%%~</a>)  <a>id</a>
--   </pre>
--   
--   It may be beneficial to think about it as if it had these even more
--   restricted types, however:
--   
--   <pre>
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Iso</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Lens</a> s t a b      -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting a supplemental monoidal summary of its actions,
--   by choosing <tt>f = ((,) m)</tt>
--   
--   <pre>
--   (<a>%%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) :: <a>Monoid</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; (m, b)) -&gt; s -&gt; (m, t)
--   </pre>
(%%~) :: Optical p q f s t a b -> p a (f b) -> q s (f t)

-- | Modify the target of a <a>Lens</a> in the current state returning some
--   extra information of type <tt>r</tt> or modify all targets of a
--   <a>Traversal</a> in the current state, extracting extra information of
--   type <tt>r</tt> and return a monoidal summary of the changes.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 %%= \x -&gt; (f x, g x)) (a,b)
--   (f a,(g a,b))
--   </pre>
--   
--   <pre>
--   (<a>%%=</a>)  (<a>state</a> <a>.</a>)
--   </pre>
--   
--   It may be useful to think of (<a>%%=</a>), instead, as having either
--   of the following more restricted type signatures:
--   
--   <pre>
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; (r, b)) -&gt; m r
--   </pre>
(%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary of the supplementary results and the answer.
--   
--   <pre>
--   (<a>%%@~</a>)  <a>withIndex</a>
--   </pre>
--   
--   <pre>
--   (<a>%%@~</a>) :: <a>Functor</a> f =&gt; <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%@~</a>) :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   In particular, it is often useful to think of this function as having
--   one of these even more restricted type signatures:
--   
--   <pre>
--   (<a>%%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%@~</a>) :: <a>Monoid</a> r =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   </pre>
(%%@~) :: IndexedLensLike i f s t a b -> (i -> a -> f b) -> s -> f t

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   supplementary results.
--   
--   <pre>
--   l <a>%%@=</a> f  <a>state</a> (l <a>%%@~</a> f)
--   </pre>
--   
--   <pre>
--   (<a>%%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   (<a>%%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   </pre>
(%%@=) :: MonadState s m => IndexedLensLike i ((,) r) s s a b -> (i -> a -> (r, b)) -> m r

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary along with the answer.
--   
--   <pre>
--   l <a>&lt;%~</a> f  l <a>&lt;%@~</a> <a>const</a> f
--   </pre>
--   
--   When you do not need access to the index then (<a>&lt;%~</a>) is more
--   liberal in what it can accept.
--   
--   If you do not need the intermediate result, you can use (<a>%@~</a>)
--   or even (<a>%~</a>).
--   
--   <pre>
--   (<a>&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%@~</a>) :: <a>Monoid</a> b =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%@~) :: Optical (Indexed i) q ((,) b) s t a b -> (i -> a -> b) -> q s (b, t)

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   intermediate results.
--   
--   <pre>
--   (<a>&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   (<a>&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   </pre>
(<%@=) :: MonadState s m => IndexedLensLike i ((,) b) s s a b -> (i -> a -> b) -> m b

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> and return a
--   monoidal summary of the old values along with the answer.
--   
--   <pre>
--   (<a>&lt;&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%@~</a>) :: <a>Monoid</a> a =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%@~) :: Optical (Indexed i) q ((,) a) s t a b -> (i -> a -> b) -> q s (a, t)

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> within the
--   current state, and return a monoidal summary of the old values.
--   
--   <pre>
--   (<a>&lt;&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   (<a>&lt;&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   </pre>
(<<%@=) :: MonadState s m => IndexedLensLike i ((,) a) s s a b -> (i -> a -> b) -> m a

-- | Passes the result of the left side to the function on the right side
--   (forward pipe operator).
--   
--   This is the flipped version of (<a>$</a>), which is more common in
--   languages like F# as (<tt>|&gt;</tt>) where it is needed for
--   inference. Here it is supplied for notational convenience and given a
--   precedence that allows it to be nested inside uses of (<a>$</a>).
--   
--   <pre>
--   &gt;&gt;&gt; a &amp; f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &amp; length &amp; succ
--   6
--   </pre>
--   
--   This combinator is commonly used when applying multiple <a>Lens</a>
--   operations in sequence.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _1.element 0 .~ 'j' &amp; _1.element 4 .~ 'y'
--   ("jelly","world")
--   </pre>
--   
--   This reads somewhat similar to:
--   
--   <pre>
--   &gt;&gt;&gt; flip execState ("hello","world") $ do _1.element 0 .= 'j'; _1.element 4 .= 'y'
--   ("jelly","world")
--   </pre>
(&) :: a -> (a -> b) -> b

-- | Infix flipped <a>fmap</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b

-- | This is convenient to <a>flip</a> argument order of composite
--   functions.
--   
--   <pre>
--   &gt;&gt;&gt; over _2 ?? ("hello","world") $ length
--   ("hello",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over ?? length ?? ("hello","world") $ _2
--   ("hello",5)
--   </pre>
(??) :: Functor f => f (a -> b) -> a -> f b

-- | This can be used to chain lens operations using <tt>op=</tt> syntax
--   rather than <tt>op~</tt> syntax for simple non-type-changing cases.
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ 30 &amp; _2 .~ 40
--   (30,40)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp;~ do _1 .= 30; _2 .= 40
--   (30,40)
--   </pre>
--   
--   This does not support type-changing assignment, <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ "hello"
--   ("hello",20)
--   </pre>
(&~) :: s -> State s a -> s

-- | Merge two lenses, getters, setters, folds or traversals.
--   
--   <pre>
--   <a>chosen</a>  <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>choosing</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s' a     -&gt; <a>Getter</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Fold</a> s a       -&gt; <a>Fold</a> s' a       -&gt; <a>Fold</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s' a      -&gt; <a>Lens'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> s' a -&gt; <a>Traversal'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> s' a    -&gt; <a>Setter'</a> (<a>Either</a> s s') a
--   </pre>
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b

-- | This is a <a>Lens</a> that updates either side of an <a>Either</a>,
--   where both sides have the same type.
--   
--   <pre>
--   <a>chosen</a>  <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello"^.chosen
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a &amp; chosen *~ b
--   Right (a * b)
--   </pre>
--   
--   <pre>
--   <a>chosen</a> :: <a>Lens</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   <a>chosen</a> f (<a>Left</a> a)  = <a>Left</a> <a>&lt;$&gt;</a> f a
--   <a>chosen</a> f (<a>Right</a> a) = <a>Right</a> <a>&lt;$&gt;</a> f a
--   </pre>
chosen :: IndexPreservingLens (Either a a) (Either b b) a b

-- | <a>alongside</a> makes a <a>Lens</a> from two other lenses or a
--   <a>Getter</a> from two other getters by executing them on their
--   respective halves of a product.
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b)^.alongside chosen chosen
--   (a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b) &amp; alongside chosen chosen .~ (c,d)
--   (Left c,Right d)
--   </pre>
--   
--   <pre>
--   <a>alongside</a> :: <a>Lens</a>   s t a b -&gt; <a>Lens</a>   s' t' a' b' -&gt; <a>Lens</a>   (s,s') (t,t') (a,a') (b,b')
--   <a>alongside</a> :: <a>Getter</a> s t a b -&gt; <a>Getter</a> s' t' a' b' -&gt; <a>Getter</a> (s,s') (t,t') (a,a') (b,b')
--   </pre>
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')

-- | Lift a <a>Lens</a> so it can run under a function (or other
--   corepresentable profunctor).
--   
--   <pre>
--   <a>inside</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> (e -&gt; s) (e -&gt; t) (e -&gt; a) (e -&gt; b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (\x -&gt; (x-1,x+1)) ^. inside _1 $ 5
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runState (modify (1:) &gt;&gt; modify (2:)) ^. (inside _2) $ []
--   [2,1]
--   </pre>
inside :: Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)

-- | Modify the target of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the addition, (<a>%~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) :: <a>Monoid</a> b =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%~) :: Profunctor p => Optical p q ((,) b) s t a b -> p a b -> q s (b, t)

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the addition, (<a>+~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<+~) :: Num a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the subtraction, (<a>-~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<-~) :: Num a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the multiplication, (<a>*~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<*~) :: Num a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Divide the target of a fractionally valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the division, (<a>//~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<//~) :: Fractional a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^~) :: (Num a, Integral e) => Optical (->) q ((,) a) s t a a -> e -> q s (a, t)

-- | Raise the target of a fractionally valued <a>Lens</a> to an
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^^~) :: (Fractional a, Integral e) => Optical (->) q ((,) a) s t a a -> e -> q s (a, t)

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<**~) :: Floating a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>||~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<||~) :: Optical (->) q ((,) Bool) s t Bool Bool -> Bool -> q s (Bool, t)

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;~</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<&&~) :: Optical (->) q ((,) Bool) s t Bool Bool -> Bool -> q s (Bool, t)

-- | <a>mappend</a> a monoidal value onto the end of the target of a
--   <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;~</a>)
--   is more flexible.
(<<>~) :: Monoid m => Optical (->) q ((,) m) s t m m -> m -> q s (m, t)

-- | Modify the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>%~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%~) :: Strong p => Optical p q ((,) a) s t a b -> p a b -> q s (a, t)

-- | Replace the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>.~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.~</a>) ::             <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) ::             <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<.~) :: Optical (->) q ((,) a) s t a b -> b -> q s (a, t)

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>+~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;+~ c
--   (a,(a + c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;+~ c
--   (b,(a,b + c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<+~) :: Num a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;-~ c
--   (a,(a - c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;-~ c
--   (b,(a,b - c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<-~) :: Num a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;*~ c
--   (a,(a * c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;*~ c
--   (b,(a,b * c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<*~) :: Num a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Divide the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>//~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;//~ c
--   (a,(a / c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 &lt;&lt;//~ 2
--   (10.0,("Hawaii",5.0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<//~) :: Fractional a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<<^~) :: (Num a, Integral e) => Optical' (->) q ((,) a) s a -> e -> q s (a, s)

-- | Raise the target of a fractionally valued <a>Lens</a> to an integral
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; S -&gt; (a, s)
--   </pre>
(<<^^~) :: (Fractional a, Integral e) => Optical' (->) q ((,) a) s a -> e -> q s (a, s)

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the old value.
--   
--   When you do not need the old value, (<a>**~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;**~ c
--   (a,(a**c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;**~ c
--   (b,(a,b**c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<**~) :: Floating a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Logically <a>||</a> the target of a <a>Bool</a>-valued <a>Lens</a> and
--   return the old value.
--   
--   When you do not need the old value, (<a>||~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;||~ True
--   (False,(True,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;||~ False
--   (True,("hello",True))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<<||~) :: Optical' (->) q ((,) Bool) s Bool -> Bool -> q s (Bool, s)

-- | Logically <a>&amp;&amp;</a> the target of a <a>Bool</a>-valued
--   <a>Lens</a> and return the old value.
--   
--   When you do not need the old value, (<a>&amp;&amp;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;&amp;&amp;~ True
--   (False,(False,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;&amp;&amp;~ False
--   (True,("hello",False))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   </pre>
(<<&&~) :: Optical' (->) q ((,) Bool) s Bool -> Bool -> q s (Bool, s)

-- | Modify the target of a monoidally valued <a>Lens</a> by
--   <a>mappend</a>ing a new value and return the old value.
--   
--   When you do not need the old value, (<a>&lt;&gt;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&lt;&lt;&gt;~ Sum c
--   (Sum {getSum = a},(Sum {getSum = a + c},b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;&lt;&gt;~ ", 007" $ ("James", "Bond")
--   ("Bond",("James","Bond, 007"))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Monoid</a> r =&gt; <a>Lens'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Monoid</a> r =&gt; <a>Iso'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   </pre>
(<<<>~) :: Monoid r => Optical' (->) q ((,) r) s r -> r -> q s (r, s)

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the result.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the intermediate results.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
(<%=) :: (Profunctor p, MonadState s m) => Over p ((,) b) s s a b -> p a b -> m b

-- | Add to the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the addition, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Subtract from the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the subtraction, (<a>-=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Multiply the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the multiplication, (<a>*=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Divide the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the division, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a

-- | Raise the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to a non-negative <a>Integral</a> power and
--   return the result.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Raise the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an <a>Integral</a> power and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Iso'</a> s a  -&gt; e -&gt; m a
--   </pre>
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Raise the target of a floating-point valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | <a>mappend</a> a monoidal value onto the end of the target of a
--   <a>Lens</a> into your <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
(<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m =&gt; <a>LensLike</a> ((,)a) s s a b -&gt; (a -&gt; b) -&gt; m a
--   </pre>
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with a user supplied value and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>.=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> t) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   adding a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   subtracting a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>-=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   multipling a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>*=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <a>Monad</a>s state by
--   dividing by a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by a non-negative power and return the <i>old</i> value
--   that was replaced.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an integral power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an arbitrary power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>||</a> with a value and return the <i>old</i>
--   value that was replaced.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>&amp;&amp;</a> with a value and return the
--   <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   <a>mappend</a>ing a value and return the <i>old</i> value that was
--   replaced.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Lens'</a> s r -&gt; r -&gt; m r
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Iso'</a> s r -&gt; r -&gt; m r
--   </pre>
(<<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r

-- | Run a monadic action, and set the target of <a>Lens</a> to its result.
--   
--   <pre>
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b   -&gt; m b -&gt; m b
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b  -&gt; m b -&gt; m b
--   </pre>
--   
--   NB: This is limited to taking an actual <a>Lens</a> than admitting a
--   <a>Traversal</a> because there are potential loss of state issues
--   otherwise.
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b

-- | Cloning a <a>Lens</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Traversal</a> and can be used as a way
--   to pass around lenses that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let example l x = set (cloneLens l) (x^.cloneLens l + 1) x in example _2 ("hello",1,"you")
--   ("hello",2,"you")
--   </pre>
cloneLens :: ALens s t a b -> Lens s t a b

-- | Clone a <a>Lens</a> as an <tt>IndexedPreservingLens</tt> that just
--   passes through whatever index is on any <a>IndexedLens</a>,
--   <a>IndexedFold</a>, <a>IndexedGetter</a> or <a>IndexedTraversal</a> it
--   is composed with.
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b

-- | Clone an <a>IndexedLens</a> as an <a>IndexedLens</a> with the same
--   index.
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b

-- | <a>over</a> for Arrows.
--   
--   Unlike <a>over</a>, <a>overA</a> can't accept a simple <a>Setter</a>,
--   but requires a full lens, or close enough.
--   
--   <pre>
--   overA :: Arrow ar =&gt; Lens s t a b -&gt; ar a b -&gt; ar s t
--   </pre>
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t

-- | A version of <a>set</a> that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; storing _2 "world" ("hello","there")
--   ("hello","world")
--   </pre>
storing :: ALens s t a b -> b -> s -> t

-- | A version of (<a>^.</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^#_2
--   "world"
--   </pre>
(^#) :: s -> ALens s t a b -> a

-- | A version of (<a>.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 #~ "world"
--   ("hello","world")
--   </pre>
(#~) :: ALens s t a b -> b -> s -> t

-- | A version of (<a>%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%~ length
--   ("hello",5)
--   </pre>
(#%~) :: ALens s t a b -> (a -> b) -> s -> t

-- | A version of (<a>%%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%%~ \x -&gt; (length x, x ++ "!")
--   (5,("hello","world!"))
--   </pre>
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t

-- | A version of (<a>&lt;.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 &lt;#~ "world"
--   ("world",("hello","world"))
--   </pre>
(<#~) :: ALens s t a b -> b -> s -> (b, t)

-- | A version of (<a>&lt;%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 &lt;#%~ length
--   (5,("hello",5))
--   </pre>
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)

-- | A version of (<a>.=</a>) that works on <a>ALens</a>.
(#=) :: MonadState s m => ALens s s a b -> b -> m ()

-- | A version of (<a>%=</a>) that works on <a>ALens</a>.
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()

-- | A version of (<a>%%=</a>) that works on <a>ALens</a>.
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r

-- | A version of (<a>&lt;.=</a>) that works on <a>ALens</a>.
(<#=) :: MonadState s m => ALens s s a b -> b -> m b

-- | A version of (<a>&lt;%=</a>) that works on <a>ALens</a>.
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b

-- | There is a field for every type in the <a>Void</a>. Very zen.
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; mapped.devoid +~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; mapped.devoid %~ abs
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>devoid</a> :: <a>Lens'</a> <a>Void</a> a
--   </pre>
devoid :: Over p f Void Void a b

-- | We can always retrieve a <tt>()</tt> from any type.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.united
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &amp; united .~ ()
--   "hello"
--   </pre>
united :: Lens' a ()

-- | The indexed store can be used to characterize a <a>Lens</a> and is
--   used by <a>clone</a>.
--   
--   <tt><a>Context</a> a b t</tt> is isomorphic to <tt>newtype
--   <a>Context</a> a b t = <a>Context</a> { runContext :: forall f.
--   <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; f t }</tt>, and to
--   <tt>exists s. (s, <a>Lens</a> s t a b)</tt>.
--   
--   A <a>Context</a> is like a <a>Lens</a> that has already been applied
--   to a some structure.
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | <pre>
--   type <a>Context'</a> a s = <a>Context</a> a a s
--   </pre>
type Context' a = Context a a

-- | This <a>Lens</a> lets you <tt>view</tt> the current <tt>pos</tt> of
--   any indexed store comonad and <tt>seek</tt> to a new position. This
--   reduces the API for working these instances to a single <a>Lens</a>.
--   
--   <pre>
--   <a>ipos</a> w  w <a>^.</a> <a>locus</a>
--   <a>iseek</a> s w  w <a>&amp;</a> <a>locus</a> <a>.~</a> s
--   <a>iseeks</a> f w  w <a>&amp;</a> <a>locus</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   <a>locus</a> :: <a>Lens'</a> (<a>Context'</a> a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>Pretext'</a> p a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>PretextT'</a> p g a s) a
--   </pre>
locus :: IndexedComonadStore p => Lens (p a c s) (p b c s) a b

-- | Fuse a composition of lenses using <a>Yoneda</a> to provide
--   <a>fmap</a> fusion.
--   
--   In general, given a pair of lenses <tt>foo</tt> and <tt>bar</tt>
--   
--   <pre>
--   fusing (foo.bar) = foo.bar
--   </pre>
--   
--   however, <tt>foo</tt> and <tt>bar</tt> are either going to <a>fmap</a>
--   internally or they are trivial.
--   
--   <a>fusing</a> exploits the <a>Yoneda</a> lemma to merge these separate
--   uses into a single <a>fmap</a>.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Lens</a> <tt>foo.bar</tt> in
--   the above description is recursive or complex enough to prevent
--   inlining.
--   
--   <pre>
--   <a>fusing</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> s t a b
--   </pre>
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b


module Control.Lens.Tuple

-- | Provides access to 1st field of a tuple.
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where _1 = ix proxyN0
_1 :: Field1 s t a b => Lens s t a b

-- | Provides access to the 2nd field of a tuple.
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s where _2 = ix proxyN1
_2 :: Field2 s t a b => Lens s t a b

-- | Provides access to the 3rd field of a tuple.
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s where _3 = ix proxyN2
_3 :: Field3 s t a b => Lens s t a b

-- | Provide access to the 4th field of a tuple.
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s where _4 = ix proxyN3
_4 :: Field4 s t a b => Lens s t a b

-- | Provides access to the 5th field of a tuple.
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s where _5 = ix proxyN4
_5 :: Field5 s t a b => Lens s t a b

-- | Provides access to the 6th element of a tuple.
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s where _6 = ix proxyN5
_6 :: Field6 s t a b => Lens s t a b

-- | Provide access to the 7th field of a tuple.
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s where _7 = ix proxyN6
_7 :: Field7 s t a b => Lens s t a b

-- | Provide access to the 8th field of a tuple.
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s where _8 = ix proxyN7
_8 :: Field8 s t a b => Lens s t a b

-- | Provides access to the 9th field of a tuple.
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s where _9 = ix proxyN8
_9 :: Field9 s t a b => Lens s t a b

-- | Strict version of <a>_1</a>
_1' :: Field1 s t a b => Lens s t a b

-- | Strict version of <a>_2</a>
_2' :: Field2 s t a b => Lens s t a b

-- | Strict version of <a>_3</a>
_3' :: Field3 s t a b => Lens s t a b

-- | Strict version of <a>_4</a>
_4' :: Field4 s t a b => Lens s t a b

-- | Strict version of <a>_5</a>
_5' :: Field5 s t a b => Lens s t a b

-- | Strict version of <a>_6</a>
_6' :: Field6 s t a b => Lens s t a b

-- | Strict version of <a>_7</a>
_7' :: Field7 s t a b => Lens s t a b

-- | Strict version of <a>_8</a>
_8' :: Field8 s t a b => Lens s t a b

-- | Strict version of <a>_9</a>
_9' :: Field9 s t a b => Lens s t a b
instance (GT (GSize s) n ~ F, n' ~ Subtract (GSize s) n, GIxed n' s' t' a b) => GIxed' F n s s' s t' a b
instance (GT (GSize s) n ~ T, GT (GSize t) n ~ T, GIxed n s t a b) => GIxed' T n s s' t s' a b
instance (p ~ GT (GSize s) n, p ~ GT (GSize t) n, GIxed' p n s s' t t' a b) => GIxed n (s :*: s') (t :*: t') a b
instance GIxed n s t a b => GIxed n (M1 i c s) (M1 i c t) a b
instance GIxed N0 (K1 i a) (K1 i b) a b
instance Field9 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h, i') i i'
instance Field8 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h', i) h h'
instance Field8 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g, h') h h'
instance Field7 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g', h, i) g g'
instance Field7 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g', h) g g'
instance Field7 (a, b, c, d, e, f, g) (a, b, c, d, e, f, g') g g'
instance Field6 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f', g, h, i) f f'
instance Field6 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f', g, h) f f'
instance Field6 (a, b, c, d, e, f, g) (a, b, c, d, e, f', g) f f'
instance Field6 (a, b, c, d, e, f) (a, b, c, d, e, f') f f'
instance Field5 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e', f, g, h, i) e e'
instance Field5 (a, b, c, d, e, f, g, h) (a, b, c, d, e', f, g, h) e e'
instance Field5 (a, b, c, d, e, f, g) (a, b, c, d, e', f, g) e e'
instance Field5 (a, b, c, d, e, f) (a, b, c, d, e', f) e e'
instance Field5 (a, b, c, d, e) (a, b, c, d, e') e e'
instance Field4 (a, b, c, d, e, f, g, h, i) (a, b, c, d', e, f, g, h, i) d d'
instance Field4 (a, b, c, d, e, f, g, h) (a, b, c, d', e, f, g, h) d d'
instance Field4 (a, b, c, d, e, f, g) (a, b, c, d', e, f, g) d d'
instance Field4 (a, b, c, d, e, f) (a, b, c, d', e, f) d d'
instance Field4 (a, b, c, d, e) (a, b, c, d', e) d d'
instance Field4 (a, b, c, d) (a, b, c, d') d d'
instance Field3 (a, b, c, d, e, f, g, h, i) (a, b, c', d, e, f, g, h, i) c c'
instance Field3 (a, b, c, d, e, f, g, h) (a, b, c', d, e, f, g, h) c c'
instance Field3 (a, b, c, d, e, f, g) (a, b, c', d, e, f, g) c c'
instance Field3 (a, b, c, d, e, f) (a, b, c', d, e, f) c c'
instance Field3 (a, b, c, d, e) (a, b, c', d, e) c c'
instance Field3 (a, b, c, d) (a, b, c', d) c c'
instance Field3 (a, b, c) (a, b, c') c c'
instance Field2 (a, b, c, d, e, f, g, h, i) (a, b', c, d, e, f, g, h, i) b b'
instance Field2 (a, b, c, d, e, f, g, h) (a, b', c, d, e, f, g, h) b b'
instance Field2 (a, b, c, d, e, f, g) (a, b', c, d, e, f, g) b b'
instance Field2 (a, b, c, d, e, f) (a, b', c, d, e, f) b b'
instance Field2 (a, b, c, d, e) (a, b', c, d, e) b b'
instance Field2 (a, b, c, d) (a, b', c, d) b b'
instance Field2 (a, b, c) (a, b', c) b b'
instance Field2 (a, b) (a, b') b b'
instance Field2 ((:*:) f g p) ((:*:) f g' p) (g p) (g' p)
instance Field2 (Product f g a) (Product f g' a) (g a) (g' a)
instance Field1 (a, b, c, d, e, f, g, h, i) (a', b, c, d, e, f, g, h, i) a a'
instance Field1 (a, b, c, d, e, f, g, h) (a', b, c, d, e, f, g, h) a a'
instance Field1 (a, b, c, d, e, f, g) (a', b, c, d, e, f, g) a a'
instance Field1 (a, b, c, d, e, f) (a', b, c, d, e, f) a a'
instance Field1 (a, b, c, d, e) (a', b, c, d, e) a a'
instance Field1 (a, b, c, d) (a', b, c, d) a a'
instance Field1 (a, b, c) (a', b, c) a a'
instance Field1 (a, b) (a', b) a a'
instance Field1 ((:*:) f g p) ((:*:) f' g p) (f p) (f' p)
instance Field1 (Product f g a) (Product f' g a) (f a) (f' a)
instance Field1 (Identity a) (Identity b) a b


-- | A <tt><a>Getter</a> s a</tt> is just any function <tt>(s -&gt;
--   a)</tt>, which we've flipped into continuation passing style, <tt>(a
--   -&gt; r) -&gt; s -&gt; r</tt> and decorated with <a>Const</a> to
--   obtain:
--   
--   <pre>
--   type <a>Getting</a> r s a = (a -&gt; <a>Const</a> r a) -&gt; s -&gt; <a>Const</a> r s
--   </pre>
--   
--   If we restrict access to knowledge about the type <tt>r</tt>, we could
--   get:
--   
--   <pre>
--   type <a>Getter</a> s a = forall r. <a>Getting</a> r s a
--   </pre>
--   
--   However, for <a>Getter</a> (but not for <a>Getting</a>) we actually
--   permit any functor <tt>f</tt> which is an instance of both
--   <a>Functor</a> and <a>Contravariant</a>:
--   
--   <pre>
--   type <a>Getter</a> s a = forall f. (<a>Contravariant</a> f, <a>Functor</a> f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s
--   </pre>
--   
--   Everything you can do with a function, you can do with a
--   <a>Getter</a>, but note that because of the continuation passing style
--   (<a>.</a>) composes them in the opposite order.
--   
--   Since it is only a function, every <a>Getter</a> obviously only
--   retrieves a single value for a given input.
module Control.Lens.Getter

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s

-- | Every <a>IndexedGetter</a> is a valid <a>IndexedFold</a> and can be
--   used for <a>Getting</a> like a <a>Getter</a>.
type IndexedGetter i s a = forall p f. (Indexable i p, Contravariant f, Functor f) => p a (f a) -> s -> f s

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | Used to consume an <a>IndexedFold</a>.
type IndexedGetting i m s a = Indexed i a (Const m a) -> s -> Const m s

-- | This is a convenient alias used when consuming (indexed) getters and
--   (indexed) folds in a highly general fashion.
type Accessing p m s a = p a (Const m a) -> s -> Const m s

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g  <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f  f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optical' p p f s a

-- | <pre>
--   <a>ito</a> :: (s -&gt; (i, a)) -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Optical' p (->) f s a

-- | Build an constant-valued (index-preserving) <a>Getter</a> from an
--   arbitrary Haskell value.
--   
--   <pre>
--   <a>like</a> a <a>.</a> <a>like</a> b  <a>like</a> b
--   a <a>^.</a> <a>like</a> b  b
--   a <a>^.</a> <a>like</a> b  a <a>^.</a> <a>to</a> (<a>const</a> b)
--   </pre>
--   
--   This can be useful as a second case <tt>failing</tt> a <a>Fold</a>
--   e.g. <tt>foo <tt>failing</tt> <a>like</a> 0</tt>
--   
--   <pre>
--   <a>like</a> :: a -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
like :: (Profunctor p, Contravariant f) => a -> Optical' p p f s a

-- | <pre>
--   <a>ilike</a> :: i -&gt; a -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ilike :: (Indexable i p, Contravariant f) => i -> a -> Optical' p (->) f s a

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a>  <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | View a function of the value pointed to by a <a>Getter</a> or
--   <a>Lens</a> or the result of folding over the result of mapping the
--   targets of a <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>views</a> l f  <a>view</a> (l <a>.</a> <a>to</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views (to f) g a
--   g (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views _2 length (1,"hello")
--   5
--   </pre>
--   
--   As <a>views</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>views</a> ::             <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m) -&gt; s -&gt; m
--   <a>views</a> ::             <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> ::             <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m) -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m =&gt; <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
views :: (Profunctor p, MonadReader s m) => Optical p (->) (Const r) s s a a -> p a r -> m r

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) (a,b)
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) ("hello","world")
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s r       -&gt; m r
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s r -&gt; m r
--   </pre>
use :: MonadState s m => Getting a s a -> m a

-- | Use the target of a <a>Lens</a>, <a>Iso</a> or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (uses _1 length) ("hello","world")
--   5
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m =&gt; <a>Getting</a> r s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
uses :: (Profunctor p, MonadState s m) => Optical p (->) (Const r) s s a a -> p a r -> m r

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Fold</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Traversal'</a> w u -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Prism'</a> w u     -&gt; m a -&gt; m (a, u)
--   </pre>
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Fold</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Traversal'</a> w u -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Prism'</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)

-- | View the index and value of an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>.
--   
--   This is the same operation as <a>iview</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   (<a>^@.</a>) :: s -&gt; <a>IndexedGetter</a> i s a -&gt; (i, a)
--   (<a>^@.</a>) :: s -&gt; <a>IndexedLens'</a> i s a  -&gt; (i, a)
--   </pre>
--   
--   The result probably doesn't have much meaning when applied to an
--   <a>IndexedFold</a>.
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)

-- | View the index and value of an <a>IndexedGetter</a> into the current
--   environment as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | View a function of the index and value of an <a>IndexedGetter</a> into
--   the current environment.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
--   
--   <pre>
--   <a>iviews</a>  <a>ifoldMapOf</a>
--   </pre>
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | Use the index and value of an <a>IndexedGetter</a> into the current
--   state as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | Use a function of the index and value of an <a>IndexedGetter</a> into
--   the current state.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> i w u     -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> i w u      -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedFold</a> i w u       -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedTraversal'</a> i w u -&gt; m a -&gt; m (a, (i, u))
--   </pre>
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> w u     -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> w u      -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedFold</a> w u       -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedTraversal'</a> w u -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)
class Contravariant (f :: * -> *)
contramap :: Contravariant f => (a -> b) -> f b -> f a
(>$) :: Contravariant f => b -> f b -> f a

-- | A <a>Functor</a> you can <a>coerce</a> ignores its argument, which it
--   carries solely as a phantom type parameter.
--   
--   By the <a>Functor</a> and <a>Contravariant</a> laws, an instance of
--   both will necessarily satisfy:
--   
--   <pre>
--   <a>id</a> = <a>fmap</a> f = <a>coerce</a> = <a>contramap</a> g
--   </pre>
coerce :: (Contravariant f, Functor f) => f a -> f b

-- | Coerce a <a>Getter</a>-compatible <a>LensLike</a> to a
--   <a>LensLike'</a>. This is useful when using a <a>Traversal</a> that is
--   not simple as a <a>Getter</a> or a <a>Fold</a>.
coerced :: (Functor f, Contravariant f) => LensLike f s t a b -> LensLike' f s a
newtype Const a b :: * -> * -> *
Const :: a -> Const a b
getConst :: Const a b -> a


-- | A <a>Review</a> is a type-restricted form of a <a>Prism</a> that can
--   only be used for writing back via <a>re</a>, <a>review</a>,
--   <a>reuse</a>.
module Control.Lens.Review

-- | This is a limited form of a <a>Prism</a> that can only be used for
--   <a>re</a> operations.
--   
--   Like with a <a>Getter</a>, there are no laws to state for a
--   <a>Review</a>.
--   
--   You can generate a <a>Review</a> by using <a>unto</a>. You can also
--   use any <a>Prism</a> or <a>Iso</a> directly as a <a>Review</a>.
type Review t b = forall p f. (Choice p, Bifunctor p, Settable f) => Optic' p f t b

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged Identity t b

-- | An analogue of <a>to</a> for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> :: (b -&gt; t) -&gt; <tt>Review'</tt> t b
--   </pre>
--   
--   <pre>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b

-- | Turn a <a>Getter</a> around to get a <a>Review</a>
--   
--   <pre>
--   <a>un</a> = <a>unto</a> . <a>view</a>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; un (to length) # [1,2,3]
--   3
--   </pre>
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s

-- | Turn a <a>Prism</a> or <a>Iso</a> around to build a <a>Getter</a>.
--   
--   If you have an <a>Iso</a>, <a>from</a> is a more powerful version of
--   this function that will return an <a>Iso</a> instead of a mere
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^.re _Left
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 ^.re (_Left.unto succ)
--   Left 7
--   </pre>
--   
--   <pre>
--   <a>review</a>   <a>view</a>  <a>.</a> <a>re</a>
--   <a>reviews</a>  <a>views</a> <a>.</a> <a>re</a>
--   <a>reuse</a>    <a>use</a>   <a>.</a> <a>re</a>
--   <a>reuses</a>   <a>uses</a>  <a>.</a> <a>re</a>
--   </pre>
--   
--   <pre>
--   <a>re</a> :: <a>Prism</a> s t a b -&gt; <a>Getter</a> b t
--   <a>re</a> :: <a>Iso</a> s t a b   -&gt; <a>Getter</a> b t
--   </pre>
re :: Contravariant f => AReview t b -> LensLike' f b t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>review</a>  <a>view</a> <a>.</a> <a>re</a>
--   <a>review</a> . <a>unto</a>  <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review _Left "mustard"
--   Left "mustard"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review (unto succ) 5
--   6
--   </pre>
--   
--   Usually <a>review</a> is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>Iso'</a> s a   -&gt; a -&gt; s
--   <a>review</a> :: <a>Prism'</a> s a -&gt; a -&gt; s
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   </pre>
review :: MonadReader b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way, applying a function.
--   
--   <pre>
--   <a>reviews</a>  <a>views</a> <a>.</a> <a>re</a>
--   <a>reviews</a> (<a>unto</a> f) g  g <a>.</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews _Left isRight "mustard"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews (unto succ) (*2) 3
--   8
--   </pre>
--   
--   Usually this function is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; a -&gt; r
--   <a>reviews</a> :: <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; a -&gt; r
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>reuse</a>  <a>use</a> <a>.</a> <a>re</a>
--   <a>reuse</a> <a>.</a> <a>unto</a>  <a>gets</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse _Left) 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse (unto succ)) 5
--   6
--   </pre>
--   
--   <pre>
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   </pre>
reuse :: MonadState b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> the current state through it the other way, applying a
--   function.
--   
--   <pre>
--   <a>reuses</a>  <a>uses</a> <a>.</a> <a>re</a>
--   <a>reuses</a> (<a>unto</a> f) g  <a>gets</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuses _Left isLeft) (5 :: Int)
--   True
--   </pre>
--   
--   <pre>
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x  f x
--   l # x  x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t

-- | Minimal definition either <a>bimap</a> or <a>first</a> and
--   <a>second</a>
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a>  <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a>  <a>id</a>
--   <a>second</a> <a>id</a>  <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g  <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i)  <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g)  <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g)  <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: * -> * -> *)
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | This is a profunctor used internally to implement <a>Review</a>
--   
--   It plays a role similar to that of <a>Accessor</a> or <tt>Const</tt>
--   do for <a>Control.Lens.Getter</a>
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b

-- | This class is provided mostly for backwards compatibility with lens
--   3.8, but it can also shorten type signatures.
class (Profunctor p, Bifunctor p) => Reviewable p


module Control.Lens.Prism

-- | A <a>Prism</a> <tt>l</tt> is a <a>Traversal</a> that can also be
--   turned around with <a>re</a> to obtain a <a>Getter</a> in the opposite
--   direction.
--   
--   There are two laws that a <a>Prism</a> should satisfy:
--   
--   First, if I <a>re</a> or <a>review</a> a value with a <a>Prism</a> and
--   then <a>preview</a> or use (<a>^?</a>), I will get it back:
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b)  <tt>Just</tt> b
--   </pre>
--   
--   Second, if you can extract a value <tt>a</tt> using a <a>Prism</a>
--   <tt>l</tt> from a value <tt>s</tt>, then the value <tt>s</tt> is
--   completely described by <tt>l</tt> and <tt>a</tt>:
--   
--   If <tt><a>preview</a> l s  <tt>Just</tt> a</tt> then
--   <tt><a>review</a> l a  s</tt>
--   
--   These two laws imply that the <a>Traversal</a> laws hold for every
--   <a>Prism</a> and that we <a>traverse</a> at most 1 element:
--   
--   <pre>
--   <a>lengthOf</a> l x <tt>&lt;=</tt> 1
--   </pre>
--   
--   It may help to think of this as a <a>Iso</a> that can be partial in
--   one direction.
--   
--   Every <a>Prism</a> is a valid <a>Traversal</a>.
--   
--   Every <a>Iso</a> is a valid <a>Prism</a>.
--   
--   For example, you might have a <tt><a>Prism'</a> <tt>Integer</tt>
--   <a>Natural</a></tt> allows you to always go from a <a>Natural</a> to
--   an <tt>Integer</tt>, and provide you with tools to check if an
--   <tt>Integer</tt> is a <a>Natural</a> and/or to edit one if it is.
--   
--   <pre>
--   <tt>nat</tt> :: <a>Prism'</a> <tt>Integer</tt> <a>Natural</a>
--   <tt>nat</tt> = <a>prism</a> <tt>toInteger</tt> <tt>$</tt> \ i -&gt;
--      if i <tt>&lt;</tt> 0
--      then <tt>Left</tt> i
--      else <tt>Right</tt> (<tt>fromInteger</tt> i)
--   </pre>
--   
--   Now we can ask if an <tt>Integer</tt> is a <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5^?nat
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-5)^?nat
--   Nothing
--   </pre>
--   
--   We can update the ones that are:
--   
--   <pre>
--   &gt;&gt;&gt; (-3,4) &amp; both.nat *~ 2
--   (-3,8)
--   </pre>
--   
--   And we can then convert from a <a>Natural</a> to an <tt>Integer</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^. re nat -- :: Natural
--   5
--   </pre>
--   
--   Similarly we can use a <a>Prism</a> to <a>traverse</a> the
--   <tt>Left</tt> half of an <tt>Either</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" &amp; _Left %~ length
--   Left 5
--   </pre>
--   
--   or to construct an <tt>Either</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
--   
--   such that if you query it with the <a>Prism</a>, you will get your
--   original input back.
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left ^? _Left
--   Just 5
--   </pre>
--   
--   Another interesting way to think of a <a>Prism</a> is as the
--   categorical dual of a <a>Lens</a> -- a co-<a>Lens</a>, so to speak.
--   This is what permits the construction of <a>outside</a>.
--   
--   Note: Composition with a <a>Prism</a> is index-preserving.
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Prism</a>.
type APrism s t a b = Market a b a (Identity b) -> Market a b s (Identity t)

-- | <pre>
--   type APrism' = <a>Simple</a> <a>APrism</a>
--   </pre>
type APrism' s a = APrism s s a a

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b

-- | Convert <a>APrism</a> to the pair of functions that characterize it.
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

-- | Clone a <a>Prism</a> so that you can reuse the same monomorphically
--   typed <a>Prism</a> for different purposes.
--   
--   See <a>cloneLens</a> and <a>cloneTraversal</a> for examples of why you
--   might want to do this.
clonePrism :: APrism s t a b -> Prism s t a b

-- | Use a <a>Prism</a> as a kind of first-class pattern.
--   
--   <pre>
--   <a>outside</a> :: <a>Prism</a> s t a b -&gt; <a>Lens</a> (t -&gt; r) (s -&gt; r) (b -&gt; r) (a -&gt; r)
--   </pre>
outside :: Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)

-- | Use a <a>Prism</a> to work over part of a structure.
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)

-- | Given a pair of prisms, project sums.
--   
--   Viewing a <a>Prism</a> as a co-<a>Lens</a>, this combinator can be
--   seen to be dual to <a>alongside</a>.
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)

-- | <tt>lift</tt> a <a>Prism</a> through a <a>Traversable</a> functor,
--   giving a Prism that matches only if all the elements of the container
--   match the <a>Prism</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [Left 1, Right "foo", Left 4, Right "woot"]^..below _Right
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [Right "hail hydra!", Right "foo", Right "blah", Right "woot"]^..below _Right
--   [["hail hydra!","foo","blah","woot"]]
--   </pre>
below :: Traversable f => APrism' s a -> Prism' (f s) (f a)

-- | Check to see if this <a>Prism</a> doesn't match.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Left 12)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty []
--   False
--   </pre>
isn't :: APrism s t a b -> s -> Bool

-- | Retrieve the value targeted by a <a>Prism</a> or return the original
--   value while allowing the type to change if it does not match.
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Just 12)
--   Right 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Nothing :: Maybe Int) :: Either (Maybe Bool) Int
--   Left Nothing
--   </pre>
matching :: APrism s t a b -> s -> Either t a

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Left 2)
--   Left 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Right 2)
--   Right 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 42 ^._Left :: String
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Left
--   "hello"
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
_Left :: Prism (Either a c) (Either b c) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Left 2)
--   Left 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Right 2)
--   Right 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello" ^._Right
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Right :: [Double]
--   []
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Right # 5
--   Right 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Right
--   Right 5
--   </pre>
_Right :: Prism (Either c a) (Either c b) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a>  m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | This <a>Prism</a> provides the <a>Traversal</a> of a <a>Nothing</a> in
--   a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Nothing
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just () ^? _Nothing
--   Nothing
--   </pre>
--   
--   But you can turn it around and use it to construct <a>Nothing</a> as
--   well:
--   
--   <pre>
--   &gt;&gt;&gt; _Nothing # ()
--   Nothing
--   </pre>
_Nothing :: Prism' (Maybe a) ()

-- | <a>Void</a> is a logically uninhabited data type.
--   
--   This is a <a>Prism</a> that will always fail to match.
_Void :: Prism s s a Void

-- | This is an improper prism for text formatting based on <a>Read</a> and
--   <a>Show</a>.
--   
--   This <a>Prism</a> is "improper" in the sense that it normalizes the
--   text formatting, but round tripping is idempotent given sane
--   'Read'/'Show' instances.
--   
--   <pre>
--   &gt;&gt;&gt; _Show # 2
--   "2"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "EQ" ^? _Show :: Maybe Ordering
--   Just EQ
--   </pre>
--   
--   <pre>
--   <a>_Show</a>  <a>prism'</a> <a>show</a> <tt>readMaybe</tt>
--   </pre>
_Show :: (Read a, Show a) => Prism' String a

-- | This <a>Prism</a> compares for exact equality with a given value.
--   
--   <pre>
--   &gt;&gt;&gt; only 4 # ()
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^? only 4
--   Nothing
--   </pre>
only :: Eq a => a -> Prism' a ()

-- | This <a>Prism</a> compares for approximate equality with a given value
--   and a predicate for testing.
--   
--   To comply with the <a>Prism</a> laws the arguments you supply to
--   <tt>nearly a p</tt> are somewhat constrained.
--   
--   We assume <tt>p x</tt> holds iff <tt>x  a</tt>. Under that assumption
--   then this is a valid <a>Prism</a>.
--   
--   This is useful when working with a type where you can test equality
--   for only a subset of its values, and the prism selects such a value.
nearly :: a -> (a -> Bool) -> Prism' a ()
class Profunctor p => Choice (p :: * -> * -> *)
left' :: Choice p => p a b -> p (Either a c) (Either b c)
right' :: Choice p => p a b -> p (Either c a) (Either c b)


module Control.Lens.Zoom

-- | This class allows us to use <a>magnify</a> part of the environment,
--   changing the environment supplied by many different <a>Monad</a>
--   transformers. Unlike <a>zoom</a> this can change the environment of a
--   deeply nested <a>Monad</a> transformer.
--   
--   Also, unlike <a>zoom</a>, this can be used with any valid
--   <a>Getter</a>, but cannot be used with a <a>Traversal</a> or
--   <a>Fold</a>.
class (Magnified m ~ Magnified n, MonadReader b m, MonadReader a n) => Magnify m n b a | m -> b, n -> a, m a -> n, n b -> m
magnify :: Magnify m n b a => LensLike' (Magnified m c) a b -> m c -> n c

-- | This class allows us to use <a>zoom</a> in, changing the <a>State</a>
--   supplied by many different <a>Monad</a> transformers, potentially
--   quite deep in a <a>Monad</a> transformer stack.
class (Zoomed m ~ Zoomed n, MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
instance Magnify m n b a => Magnify (IdentityT m) (IdentityT n) b a
instance (Monad m, Monoid w) => Magnify (RWST b w s m) (RWST a w s m) b a
instance (Monad m, Monoid w) => Magnify (RWST b w s m) (RWST a w s m) b a
instance Magnify ((->) b) ((->) a) b a
instance Monad m => Magnify (ReaderT b m) (ReaderT a m) b a
instance Zoom m n s t => Zoom (ExceptT e m) (ExceptT e n) s t
instance (Error e, Zoom m n s t) => Zoom (ErrorT e m) (ErrorT e n) s t
instance Zoom m n s t => Zoom (MaybeT m) (MaybeT n) s t
instance Zoom m n s t => Zoom (ListT m) (ListT n) s t
instance (Monoid w, Zoom m n s t) => Zoom (WriterT w m) (WriterT w n) s t
instance (Monoid w, Zoom m n s t) => Zoom (WriterT w m) (WriterT w n) s t
instance (Monoid w, Monad z) => Zoom (RWST r w s z) (RWST r w t z) s t
instance (Monoid w, Monad z) => Zoom (RWST r w s z) (RWST r w t z) s t
instance Zoom m n s t => Zoom (IdentityT m) (IdentityT n) s t
instance Zoom m n s t => Zoom (ReaderT e m) (ReaderT e n) s t
instance Monad z => Zoom (StateT s z) (StateT t z) s t
instance Monad z => Zoom (StateT s z) (StateT t z) s t


module Data.Set.Lens

-- | This <a>Setter</a> can be used to change the type of a <a>Set</a> by
--   mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <a>Set</a>, but
--   you can manipulate it by reading using <a>folded</a> and reindexing it
--   via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: Ord j => IndexPreservingSetter (Set i) (Set j) i j

-- | Construct a set from a <a>Getter</a>, <a>Fold</a>, <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded._2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>setOf</a> ::          <a>Getter</a> s a     -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> ::          <a>Iso'</a> s a       -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> ::          <a>Lens'</a> s a      -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Set</a> a
--   </pre>
setOf :: Getting (Set a) s a -> s -> Set a


module Data.HashSet.Lens

-- | This <a>Setter</a> can be used to change the type of a <a>HashSet</a>
--   by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <tt>Set</tt>,
--   but you can manipulate it by reading using <a>folded</a> and
--   reindexing it via <a>setmapped</a>.
setmapped :: (Eq j, Hashable j) => IndexPreservingSetter (HashSet i) (HashSet j) i j

-- | Construct a set from a <a>Getter</a>, <a>Fold</a>, <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   <a>setOf</a> :: <a>Hashable</a> a         =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: (<a>Eq</a> a, <a>Hashable</a> a) =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: <a>Hashable</a> a         =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: <a>Hashable</a> a         =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: (<a>Eq</a> a, <a>Hashable</a> a) =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>HashSet</a> a
--   </pre>
setOf :: Hashable a => Getting (HashSet a) s a -> s -> HashSet a


-- | A <tt><a>Fold</a> s a</tt> is a generalization of something
--   <a>Foldable</a>. It allows you to extract multiple results from a
--   container. A <a>Foldable</a> container can be characterized by the
--   behavior of <tt><a>foldMap</a> :: (<a>Foldable</a> t, <a>Monoid</a> m)
--   =&gt; (a -&gt; m) -&gt; t a -&gt; m</tt>. Since we want to be able to
--   work with monomorphic containers, we could generalize this signature
--   to <tt>forall m. <a>Monoid</a> m =&gt; (a -&gt; m) -&gt; s -&gt;
--   m</tt>, and then decorate it with <a>Const</a> to obtain
--   
--   <pre>
--   type <a>Fold</a> s a = forall m. <a>Monoid</a> m =&gt; <a>Getting</a> m s a
--   </pre>
--   
--   Every <a>Getter</a> is a valid <a>Fold</a> that simply doesn't use the
--   <a>Monoid</a> it is passed.
--   
--   In practice the type we use is slightly more complicated to allow for
--   better error messages and for it to be transformed by certain
--   <a>Applicative</a> transformers.
--   
--   Everything you can do with a <a>Foldable</a> container, you can with
--   with a <a>Fold</a> and there are combinators that generalize the usual
--   <a>Foldable</a> operations here.
module Control.Lens.Fold

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s

-- | Every <a>IndexedFold</a> is a valid <a>Fold</a> and can be used for
--   <a>Getting</a>.
type IndexedFold i s a = forall p f. (Indexable i p, Contravariant f, Applicative f) => p a (f a) -> s -> f s

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs  xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>)  <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Fold</a> s a       -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   <pre>
--   (<a>^?</a>)  <a>flip</a> <a>preview</a>
--   </pre>
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a

-- | Perform an *UNSAFE* <a>head</a> of a <a>Fold</a> or <a>Traversal</a>
--   assuming that it is there.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?! _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^?! ix 3
--   'l'
--   </pre>
--   
--   <pre>
--   (<a>^?!</a>) :: s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Fold</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; a
--   </pre>
(^?!) :: s -> Getting (Endo a) s a -> a

-- | This converts a <a>Fold</a> to a <a>IndexPreservingGetter</a> that
--   returns the first element, if it exists, as a <a>Maybe</a>.
--   
--   <pre>
--   <a>pre</a> :: <a>Getter</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Fold</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Traversal'</a> s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Lens'</a> s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Iso'</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Prism'</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   </pre>
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)

-- | This converts an <a>IndexedFold</a> to an <a>IndexPreservingGetter</a>
--   that returns the first index and element, if they exist, as a
--   <a>Maybe</a>.
--   
--   <pre>
--   <a>ipre</a> :: <a>IndexedGetter</a> i s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedFold</a> i s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedTraversal'</a> i s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedLens'</a> i s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   </pre>
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>). See
--   also (<a>^?</a>).
--   
--   <pre>
--   <a>listToMaybe</a> <a>.</a> <a>toList</a>  <a>preview</a> <a>folded</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>preview</a> = <a>view</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preview</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>).
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>). See also (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreview</a> = <a>view</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreview</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; <a>Maybe</a> (i, a)
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or <a>Just</a> the
--   result from an <a>IndexedGetter</a> or <a>IndexedLens</a>). See also
--   (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreviews</a> = <a>views</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreviews</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>) into
--   the current state.
--   
--   <pre>
--   <a>preuse</a> = <a>use</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>) into the current state.
--   
--   <pre>
--   <a>preuses</a> = <a>uses</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> (or <a>Just</a> the index and result from
--   an <a>IndexedGetter</a> or <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuse</a> = <a>use</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or a function of
--   <a>Just</a> the index and result from an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuses</a> = <a>uses</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> matches 1 or more
--   entries.
--   
--   <pre>
--   &gt;&gt;&gt; has (element 0) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>has</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> has no matches.
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Left 12)
--   False
--   </pre>
hasn't :: Getting All s a -> s -> Bool

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..folding tail
--   [2,3,4]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
--   
--   <pre>
--   &gt;&gt;&gt; Just 3^..folded
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing^..folded
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)]^..folded.both
--   [1,2,3,4]
--   </pre>
folded :: Foldable f => IndexedFold Int (f a) a

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
folded64 :: Foldable f => IndexedFold Int64 (f a) a

-- | Build a <a>Fold</a> that unfolds its values from a seed.
--   
--   <pre>
--   <a>unfoldr</a>  <a>toListOf</a> <a>.</a> <a>unfolded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10^..unfolded (\b -&gt; if b == 0 then Nothing else Just (b, b-1))
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfolded :: (b -> Maybe (a, b)) -> Fold b a

-- | <tt>x <a>^.</a> <a>iterated</a> f</tt> returns an infinite
--   <a>Fold1</a> of repeated applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   <a>toListOf</a> (<a>iterated</a> f) a  <a>iterate</a> f a
--   </pre>
--   
--   <pre>
--   <a>iterated</a> :: (a -&gt; a) -&gt; <a>Fold1</a> a a
--   </pre>
iterated :: Apply f => (a -> a) -> LensLike' f a a

-- | Obtain an <a>Fold</a> that can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   Note: This is <i>not</i> a legal <a>Traversal</a>, unless you are very
--   careful not to invalidate the predicate on the target.
--   
--   Note: This is also <i>not</i> a legal <a>Prism</a>, unless you are
--   very careful not to inject a value that matches the predicate.
--   
--   As a counter example, consider that given <tt>evens = <a>filtered</a>
--   <a>even</a></tt> the second <a>Traversal</a> law is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   <pre>
--   &gt;&gt;&gt; [1..10]^..folded.filtered even
--   [2,4,6,8,10]
--   </pre>
--   
--   This will preserve an index if it is present.
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a

-- | This allows you to <a>traverse</a> the elements of a pretty much any
--   <a>LensLike</a> construction in the opposite order.
--   
--   This will preserve indexes on <a>Indexed</a> types and will give you
--   the elements of a (finite) <a>Fold</a> or <a>Traversal</a> in the
--   opposite order.
--   
--   This has no practical impact on a <a>Getter</a>, <a>Setter</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <i>NB:</i> To write back through an <a>Iso</a>, you want to use
--   <a>from</a>. Similarly, to write back through an <a>Prism</a>, you
--   want to use <a>re</a>.
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b

-- | Form a <a>Fold1</a> by repeating the input forever.
--   
--   <pre>
--   <a>repeat</a>  <a>toListOf</a> <a>repeated</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ 5^..taking 20 repeated
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
--   
--   <pre>
--   <a>repeated</a> :: <a>Fold1</a> a a
--   </pre>
repeated :: Apply f => LensLike' f a a

-- | A <a>Fold</a> that replicates its input <tt>n</tt> times.
--   
--   <pre>
--   <a>replicate</a> n  <a>toListOf</a> (<a>replicated</a> n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^..replicated 20
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
replicated :: Int -> Fold a a

-- | Transform a non-empty <a>Fold</a> into a <a>Fold1</a> that loops over
--   its elements over and over.
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1,2,3]^..taking 7 (cycled traverse)
--   [1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   <a>cycled</a> :: <a>Fold1</a> s a -&gt; <a>Fold1</a> s a
--   </pre>
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b

-- | Obtain a <a>Fold</a> by taking elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>takeWhile</a> p  <a>toListOf</a> (<a>takingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ toListOf (takingWhile (&lt;=3) folded) [1..]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   <i>Note:</i> When applied to a <a>Traversal</a>, <a>takingWhile</a>
--   yields something that can be used as if it were a <a>Traversal</a>,
--   but which is not a <a>Traversal</a> per the laws, unless you are
--   careful to ensure that you do not invalidate the predicate when
--   writing back through it.
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a

-- | Obtain a <a>Fold</a> by dropping elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>dropWhile</a> p  <a>toListOf</a> (<a>droppingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1..6]
--   [4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1,6,1]
--   [6,1]
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a                -- see notes
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingTraversal'</a> s a    -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingLens'</a> s a         -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingFold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s a
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Many uses of this combinator will yield something that meets the
--   types, but not the laws of a valid <a>Traversal</a> or
--   <a>IndexedTraversal</a>. The <a>Traversal</a> and
--   <a>IndexedTraversal</a> laws are only satisfied if the new values you
--   assign also pass the predicate! Otherwise subsequent traversals will
--   visit fewer elements and <a>Traversal</a> fusion is not sound.
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | A <a>Fold</a> over the individual <a>words</a> of a <a>String</a>.
--   
--   <pre>
--   <a>worded</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>worded</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   whitespace characters while traversing, and if your original
--   <a>String</a> contains only isolated space characters (and no other
--   characters that count as space, such as non-breaking spaces).
worded :: Applicative f => IndexedLensLike' Int f String String

-- | A <a>Fold</a> over the individual <a>lines</a> of a <a>String</a>.
--   
--   <pre>
--   <a>lined</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>lined</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   newline characters while traversing, and if your original
--   <a>String</a> contains only isolated newline characters.
lined :: Applicative f => IndexedLensLike' Int f String String

-- | Map each part of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> to a monoid and combine
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMapOf (folded . both . _Just) Sum [(Just 21, Just 21)]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>foldMap</a> = <a>foldMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a>  <a>views</a>
--   <a>ifoldMapOf</a> l = <a>foldMapOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ::             <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::             <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::             <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> :: <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
foldMapOf :: Profunctor p => Accessing p r s a -> p a r -> s -> r

-- | Combine the elements of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> using a monoid.
--   
--   <pre>
--   &gt;&gt;&gt; foldOf (folded.folded) [[Sum 1,Sum 4],[Sum 8, Sum 8],[Sum 21]]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>fold</a> = <a>foldOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a>  <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ::             <a>Getter</a> s m     -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Lens'</a> s m      -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Iso'</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Prism'</a> s m     -&gt; s -&gt; m
--   </pre>
foldOf :: Getting a s a -> s -> a

-- | Right-associative fold of parts of a structure that are viewed through
--   a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldr</a>  <a>foldrOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> l  <a>foldrOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getting</a> (<a>Endo</a> r) s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf :: Profunctor p => Accessing p (Endo r) s a -> p a (r -> r) -> r -> s -> r

-- | Left-associative fold of the parts of a structure that are viewed
--   through a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldl</a>  <a>foldlOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Prism'</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | Extract a list of the targets of a <a>Fold</a>. See also (<a>^..</a>).
--   
--   <pre>
--   <a>toList</a>  <a>toListOf</a> <a>folded</a>
--   (<a>^..</a>)  <a>flip</a> <a>toListOf</a>
--   </pre>
toListOf :: Getting (Endo [a]) s a -> s -> [a]

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf both (=='x') ('x','y')
--   True
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; anyOf biplate (== "world") (((),2::Int),"hello",("world",11::Int))
--   True
--   </pre>
--   
--   <pre>
--   <a>any</a>  <a>anyOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> l  <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
anyOf :: Profunctor p => Accessing p Any s a -> p a Bool -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf both (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a>  <a>allOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> l = <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>allOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
allOf :: Profunctor p => Accessing p All s a -> p a Bool -> s -> Bool

-- | Returns <a>True</a> only if no targets of a <a>Fold</a> satisfy a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; noneOf each (is _Nothing) (Just 3, Just 4, Just 5)
--   True
--   
--   &gt;&gt;&gt; noneOf (folded.folded) (&lt;10) [[13,99,20],[3,71,42]]
--   False
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> l = <a>noneOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>noneOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
noneOf :: Profunctor p => Accessing p Any s a -> p a Bool -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andOf both (True,False)
--   False
--   
--   &gt;&gt;&gt; andOf both (True,True)
--   True
--   </pre>
--   
--   <pre>
--   <a>and</a>  <a>andOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>andOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
andOf :: Getting All s Bool -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orOf both (True,False)
--   True
--   
--   &gt;&gt;&gt; orOf both (False,False)
--   False
--   </pre>
--   
--   <pre>
--   <a>or</a>  <a>orOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>orOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
orOf :: Getting Any s Bool -> s -> Bool

-- | Calculate the <a>Product</a> of every number targeted by a
--   <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; productOf both (4,5)
--   20
--   
--   &gt;&gt;&gt; productOf folded [1,2,3,4,5]
--   120
--   </pre>
--   
--   <pre>
--   <a>product</a>  <a>productOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <a>Product</a> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Calculate the <a>Sum</a> of every number targeted by a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf both (5,6)
--   11
--   
--   &gt;&gt;&gt; sumOf folded [1,2,3,4]
--   10
--   
--   &gt;&gt;&gt; sumOf (folded.both) [(1,2),(3,4)]
--   10
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; sumOf biplate [(1::Int,[]),(2,[(3::Int,4::Int)])] :: Int
--   10
--   </pre>
--   
--   <pre>
--   <a>sum</a>  <a>sumOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <a>Sum</a> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>sumOf</a> <tt>_1</tt> :: <a>Num</a> a =&gt; (a, b) -&gt; a
--   <a>sumOf</a> (<a>folded</a> <a>.</a> <a>_1</a>) :: (<a>Foldable</a> f, <a>Num</a> a) =&gt; f (a, b) -&gt; a
--   </pre>
--   
--   <pre>
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>traverseOf</a> do not construct a new structure.
--   <a>traverseOf_</a> generalizes <a>traverse_</a> to work over any
--   <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>traverseOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>traverseOf_</a>
--   requires an <a>Applicative</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>traverse_</a>  <a>traverseOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf_</a> <tt>_2</tt> :: <a>Functor</a> f =&gt; (c -&gt; f r) -&gt; (d, c) -&gt; f ()
--   <a>traverseOf_</a> <a>_Left</a> :: <a>Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a>Either</a> a c -&gt; f ()
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> l  <a>traverseOf_</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   The rather specific signature of <a>traverseOf_</a> allows it to be
--   used as if the signature was any of:
--   
--   <pre>
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverseOf_ :: (Profunctor p, Functor f) => Accessing p (Traversed r f) s a -> p a (f r) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>forOf</a> do not construct a new structure. <a>forOf_</a>
--   generalizes <a>for_</a> to work over any <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>forOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>forOf_</a> requires
--   an <a>Applicative</a>.
--   
--   <pre>
--   <a>for_</a>  <a>forOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; forOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   The rather specific signature of <a>forOf_</a> allows it to be used as
--   if the signature was any of:
--   
--   <pre>
--   <a>iforOf_</a> l s  <a>forOf_</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
forOf_ :: (Profunctor p, Functor f) => Accessing p (Traversed r f) s a -> s -> p a (f r) -> f ()

-- | Evaluate each action in observed by a <a>Fold</a> on a structure from
--   left to right, ignoring the results.
--   
--   <pre>
--   <a>sequenceA_</a>  <a>sequenceAOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f ()
--   </pre>
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()

-- | Map each target of a <a>Fold</a> on a structure to a monadic action,
--   evaluate these actions from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>mapM_</a>  <a>mapMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
mapMOf_ :: (Profunctor p, Monad m) => Accessing p (Sequenced r m) s a -> p a (m r) -> s -> m ()

-- | <a>forMOf_</a> is <a>mapMOf_</a> with two of its arguments flipped.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>forM_</a>  <a>forMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   </pre>
forMOf_ :: (Profunctor p, Monad m) => Accessing p (Sequenced r m) s a -> s -> p a (m r) -> m ()

-- | Evaluate each monadic action referenced by a <a>Fold</a> on the
--   structure from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequence_</a>  <a>sequenceOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m ()
--   </pre>
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>asum</a>  <a>asumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f a
--   </pre>
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; msumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>msum</a>  <a>msumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m a
--   </pre>
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a

-- | Map a function over all the targets of a <a>Fold</a> of a container
--   and concatenate the resulting lists.
--   
--   <pre>
--   &gt;&gt;&gt; concatMapOf both (\x -&gt; [x, x + 1]) (1,3)
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   <a>concatMap</a>  <a>concatMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>concatMapOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
concatMapOf :: Profunctor p => Accessing p [r] s a -> p a [r] -> s -> [r]

-- | Concatenate all of the lists targeted by a <a>Fold</a> into a longer
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; concatOf both ("pan","ama")
--   "panama"
--   </pre>
--   
--   <pre>
--   <a>concat</a>  <a>concatOf</a> <a>folded</a>
--   <a>concatOf</a>  <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>concatOf</a> :: <a>Getter</a> s [r]     -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Fold</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Iso'</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Lens'</a> s [r]      -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Traversal'</a> s [r] -&gt; s -&gt; [r]
--   </pre>
concatOf :: Getting [r] s [r] -> s -> [r]

-- | Does the element occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; elemOf both "hello" ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>elem</a>  <a>elemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool

-- | Does the element not occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'd' ('a','b','c')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'a' ('a','b','c')
--   False
--   </pre>
--   
--   <pre>
--   <a>notElem</a>  <a>notElemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool

-- | Calculate the number of targets there are for a <a>Fold</a> in a given
--   container.
--   
--   <i>Note:</i> This can be rather inefficient for large containers and
--   just like <a>length</a>, this will not terminate for infinite folds.
--   
--   <pre>
--   <a>length</a>  <a>lengthOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf _1 ("hello",())
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf traverse [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf (traverse.traverse) [[1,2],[3,4],[5,6]]
--   6
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> (<a>folded</a> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a) -&gt; <a>Int</a>
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Int</a>
--   </pre>
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has no
--   targets in the given container.
--   
--   Note: <a>nullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>False</a>.
--   
--   <pre>
--   <a>null</a>  <a>nullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <a>null</a> check of
--   many containers.
--   
--   <pre>
--   &gt;&gt;&gt; nullOf _1 (1,2)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf ignored ()
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf traverse []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf (element 20) [1..10]
--   True
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
nullOf :: Getting All s a -> s -> Bool

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has any
--   targets in the given container.
--   
--   A more "conversational" alias for this combinator is <a>has</a>.
--   
--   Note: <a>notNullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>True</a>.
--   
--   <pre>
--   <a>null</a>  <a>notNullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <tt><a>not</a> <a>.</a>
--   <a>null</a></tt> check of many containers.
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf _1 (1,2)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf traverse [1..10]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf folded []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf (element 20) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notNullOf :: Getting Any s a -> s -> Bool

-- | Retrieve the <a>First</a> entry of a <a>Fold</a> or <a>Traversal</a>
--   or retrieve <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><tt>ala</tt> <a>First</a> <a>.</a> <a>foldMapOf</a></tt> and gives
--   you back access to the outermost <a>Just</a> constructor more quickly,
--   but may have worse constant factors.
--   
--   <pre>
--   &gt;&gt;&gt; firstOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf both (1,2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>firstOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a

-- | Retrieve the <a>Last</a> entry of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><tt>ala</tt> <a>Last</a> <a>.</a> <a>foldMapOf</a></tt> and gives
--   you back access to the outermost <a>Just</a> constructor more quickly,
--   but may have worse constant factors.
--   
--   <pre>
--   &gt;&gt;&gt; lastOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf both (1,2)
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>lastOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>maximumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 6
--   </pre>
--   
--   <pre>
--   <a>maximum</a>  <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <a>getMax</a>
--   (<a>foldMapOf</a> l <a>Max</a>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>minimumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>minimum</a>  <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <a>getMin</a>
--   (<a>foldMapOf</a> l <a>Min</a>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "mustard"
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   <a>maximumBy</a> cmp  <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>maximumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a> or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   &gt;&gt;&gt; minimumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "ham"
--   </pre>
--   
--   <pre>
--   <a>minimumBy</a> cmp  <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>minimumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | The <a>findOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a predicate and a
--   structure and returns the leftmost element of the structure matching
--   the predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findOf each even (1,3,4,6)
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findOf folded even [1,3,5,7]
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>find</a>  <a>findOf</a> <a>folded</a>
--   <a>ifindOf</a> l  <a>findOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findOf</a> :: <a>Getting</a> (<a>Endo</a> (<a>Maybe</a> a)) s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> l p = <a>foldrOf</a> l (a y -&gt; if p a then <a>Just</a> a else y) <a>Nothing</a>
--   </pre>
findOf :: Conjoined p => Accessing p (Endo (Maybe a)) s a -> p a Bool -> s -> Maybe a

-- | The <a>findMOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a monadic predicate and
--   a structure and returns in the monad the leftmost element of the
--   structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,4,6)
--   "Checking 1"
--   "Checking 3"
--   "Checking 4"
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,5,7)
--   "Checking 1"
--   "Checking 3"
--   "Checking 5"
--   "Checking 7"
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Getter</a> s a)     -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Fold</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Iso'</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Lens'</a> s a)      -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Traversal'</a> s a) -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> <a>folded</a> :: (Monad m, Foldable f) =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (Maybe a)
--   <a>ifindMOf</a> l  <a>findMOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findMOf</a> :: Monad m =&gt; <a>Getting</a> (<a>Endo</a> (m (<a>Maybe</a> a))) s a -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> l p = <a>foldrOf</a> l (a y -&gt; p a &gt;&gt;= x -&gt; if x then return (<a>Just</a> a) else y) $ return <a>Nothing</a>
--   </pre>
findMOf :: (Monad m, Conjoined p) => Accessing p (Endo (m (Maybe a))) s a -> p a (m Bool) -> s -> m (Maybe a)

-- | Strictly fold right over the elements of a structure.
--   
--   <pre>
--   <a>foldr'</a>  <a>foldrOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r

-- | Fold over the elements of a structure, associating to the left, but
--   strictly.
--   
--   <pre>
--   <a>foldl'</a>  <a>foldlOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf'</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | A variant of <a>foldrOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> l f  <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldr1</a>  <a>foldr1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of :: Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldlOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> l f  <a>foldl1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldl1</a>  <a>foldl1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of :: Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldrOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldr1Of</a> l f  <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldr1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of' :: Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldlOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldl1Of'</a> l f  <a>foldl1'</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldl1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of' :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
--   
--   <pre>
--   <a>foldrM</a>  <a>foldrMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
--   
--   <pre>
--   <a>foldlM</a>  <a>foldlMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r

-- | An infix version of <a>itoListOf</a>.
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]

-- | Perform a safe <a>head</a> (with index) of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> or retrieve <a>Just</a> the index and result
--   from an <a>IndexedGetter</a> or <a>IndexedLens</a>.
--   
--   When using a <a>IndexedTraversal</a> as a partial <a>IndexedLens</a>,
--   or an <a>IndexedFold</a> as a partial <a>IndexedGetter</a> this can be
--   a convenient way to extract the optional value.
--   
--   <pre>
--   (<a>^@?</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; <a>Maybe</a> (i, a)
--   </pre>
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)

-- | Perform an *UNSAFE* <a>head</a> (with index) of an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> assuming that it is there.
--   
--   <pre>
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; (i, a)
--   </pre>
(^@?!) :: s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)

-- | Fold an <a>IndexedFold</a> or <a>IndexedTraversal</a> by mapping
--   indices and values to an arbitrary <a>Monoid</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMapOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMapOf</a> l  <a>ifoldMapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldMapOf</a> ::             <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> ::             <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   </pre>
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m

-- | Right-associative fold of parts of a structure that are viewed through
--   an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldrOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf</a> l  <a>ifoldrOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Left-associative fold of the parts of a structure that are viewed
--   through an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access
--   to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldlOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf</a> l  <a>ifoldlOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Return whether or not any element viewed through an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> satisfy a predicate, with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>anyOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>anyOf</a> l  <a>ianyOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not all elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>allOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>allOf</a> l  <a>iallOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not none of the elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>noneOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>noneOf</a> l  <a>inoneOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <a>traverseOf_</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>traverseOf_</a> l  <a>itraverseOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforOf_</a>  <a>flip</a> <a>.</a> <a>itraverseOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forOf_</a> l a  <a>iforOf_</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   </pre>
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>mapMOf_</a> l  <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforMOf_</a>  <a>flip</a> <a>.</a> <a>imapMOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forMOf_</a> l a  <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   </pre>
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()

-- | Concatenate the results of a function of the elements of an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you don't need access to the index then <a>concatMapOf</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>concatMapOf</a> l  <a>iconcatMapOf</a> l <a>.</a> <a>const</a>
--   <a>iconcatMapOf</a>  <a>ifoldMapOf</a>
--   </pre>
--   
--   <pre>
--   <a>iconcatMapOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]

-- | The <a>ifindOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a predicate that is also supplied the index,
--   a structure and returns the left-most element of the structure
--   matching the predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findOf</a> l  <a>ifindOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a

-- | The <a>ifindMOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a monadic predicate that is also supplied the
--   index, a structure and returns in the monad the left-most element of
--   the structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   When you don't need access to the index then <a>findMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findMOf</a> l  <a>ifindMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)

-- | <i>Strictly</i> fold right over the elements of a structure with an
--   index.
--   
--   When you don't need access to the index then <a>foldrOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf'</a> l  <a>ifoldrOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf'</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf'</a> l  <a>ifoldlOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf'</a> :: <a>IndexedGetter</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedFold</a> i s a         -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedLens'</a> i s a        -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedTraversal'</a> i s a   -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <a>foldrMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrMOf</a> l  <a>ifoldrMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <a>foldlMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlMOf</a> l  <a>ifoldlMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <a>toListOf</a> is more flexible in what it accepts.
--   
--   <pre>
--   <a>toListOf</a> l  <a>map</a> <a>fst</a> <a>.</a> <a>itoListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>itoListOf</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [(i,a)]
--   </pre>
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which is equal to a given value.
--   
--   <pre>
--   <a>elemIndex</a>  <a>elemIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which are equal to a given value.
--   
--   <pre>
--   <a>elemIndices</a>  <a>elemIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; [i]
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; [i]
--   </pre>
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which satisfies a predicate.
--   
--   <pre>
--   <a>findIndex</a>  <a>findIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndexOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   <a>findIndexOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which satisfy a predicate.
--   
--   <pre>
--   <a>findIndices</a>  <a>findIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndicesOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   <a>findIndicesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   </pre>
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]

-- | Filter an <a>IndexedFold</a> or <a>IndexedGetter</a>, obtaining an
--   <a>IndexedFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,0,0,5,5,5]^..traversed.ifiltered (\i a -&gt; i &lt;= a)
--   [0,5,5,5]
--   </pre>
--   
--   Compose with <a>filtered</a> to filter another <a>IndexedLens</a>,
--   <tt>IndexedIso</tt>, <a>IndexedGetter</a>, <a>IndexedFold</a> (or
--   <a>IndexedTraversal</a>) with access to both the value and the index.
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a

-- | Obtain an <a>IndexedFold</a> by taking elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Const (Endo (f s))) s s a a -> Optical p q f s s a a

-- | Obtain an <a>IndexedFold</a> by dropping elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Applying <a>idroppingWhile</a> to an <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> will still allow you to use it as a
--   pseudo-<a>IndexedTraversal</a>, but if you change the value of the
--   targets to ones where the predicate returns <a>True</a>, then you will
--   break the <a>Traversal</a> laws and <a>Traversal</a> fusion will no
--   longer be sound.
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | Used for <a>preview</a>.
data Leftmost a

-- | Used for <a>lastOf</a>.
data Rightmost a

-- | Used internally by <a>traverseOf_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
data Traversed a f

-- | Used internally by <a>mapM_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
data Sequenced a m
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a
foldByOf :: (forall i. Getting (M a i) s a) -> (a -> a -> a) -> a -> s -> a
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
foldMapByOf :: (forall s. Getting (M r s) t a) -> (r -> r -> r) -> r -> (a -> r) -> t -> r


-- | A <tt><a>Traversal</a> s t a b</tt> is a generalization of
--   <a>traverse</a> from <a>Traversable</a>. It allows you to
--   <a>traverse</a> over a structure and change out its contents with
--   monadic or <a>Applicative</a> side-effects. Starting from
--   
--   <pre>
--   <a>traverse</a> :: (<a>Traversable</a> t, <a>Applicative</a> f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
--   </pre>
--   
--   we monomorphize the contents and result to obtain
--   
--   <pre>
--   type <a>Traversal</a> s t a b = forall f. <a>Applicative</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   While a <a>Traversal</a> isn't quite a <a>Fold</a>, it _can_ be used
--   for <a>Getting</a> like a <a>Fold</a>, because given a <a>Monoid</a>
--   <tt>m</tt>, we have an <a>Applicative</a> for <tt>(<a>Const</a>
--   m)</tt>. Everything you know how to do with a <a>Traversable</a>
--   container, you can with with a <a>Traversal</a>, and here we provide
--   combinators that generalize the usual <a>Traversable</a> operations.
module Control.Lens.Traversal

-- | A <a>Traversal</a> can be used directly as a <a>Setter</a> or a
--   <a>Fold</a> (but not as a <a>Lens</a>) and provides the ability to
--   both read and update multiple fields, subject to some relatively weak
--   <a>Traversal</a> laws.
--   
--   These have also been known as multilenses, but they have the signature
--   and spirit of
--   
--   <pre>
--   <a>traverse</a> :: <a>Traversable</a> f =&gt; <a>Traversal</a> (f a) (f b) a b
--   </pre>
--   
--   and the more evocative name suggests their application.
--   
--   Most of the time the <a>Traversal</a> you will want to use is just
--   <a>traverse</a>, but you can also pass any <a>Lens</a> or <a>Iso</a>
--   as a <a>Traversal</a>, and composition of a <a>Traversal</a> (or
--   <a>Lens</a> or <a>Iso</a>) with a <a>Traversal</a> (or <a>Lens</a> or
--   <a>Iso</a>) using (<tt>.</tt>) forms a valid <a>Traversal</a>.
--   
--   The laws for a <a>Traversal</a> <tt>t</tt> follow from the laws for
--   <a>Traversable</a> as stated in "The Essence of the Iterator Pattern".
--   
--   <pre>
--   t <a>pure</a>  <a>pure</a>
--   <a>fmap</a> (t f) <tt>.</tt> t g  <a>getCompose</a> <tt>.</tt> t (<a>Compose</a> <tt>.</tt> <a>fmap</a> f <tt>.</tt> g)
--   </pre>
--   
--   One consequence of this requirement is that a <a>Traversal</a> needs
--   to leave the same number of elements as a candidate for subsequent
--   <a>Traversal</a> that it started with. Another testament to the
--   strength of these laws is that the caveat expressed in section 5.5 of
--   the "Essence of the Iterator Pattern" about exotic <a>Traversable</a>
--   instances that <a>traverse</a> the same entry multiple times was
--   actually already ruled out by the second law in that same paper!
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a
type Traversal1 s t a b = forall f. Apply f => (a -> f b) -> s -> f t
type Traversal1' s a = Traversal1 s s a a

-- | Every <a>IndexedTraversal</a> is a valid <a>Traversal</a> or
--   <a>IndexedFold</a>.
--   
--   The <a>Indexed</a> constraint is used to allow an
--   <a>IndexedTraversal</a> to be used directly as a <a>Traversal</a>.
--   
--   The <a>Traversal</a> laws are still required to hold.
--   
--   In addition, the index <tt>i</tt> should satisfy the requirement that
--   it stays unchanged even when modifying the value <tt>a</tt>, otherwise
--   traversals like <tt>indices</tt> break the <a>Traversal</a> laws.
type IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall p f. (Indexable i p, Apply f) => p a (f b) -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal</a>.
type ATraversal s t a b = LensLike (Bazaar (->) a b) s t a b

-- | <pre>
--   type <a>ATraversal'</a> = <a>Simple</a> <a>ATraversal</a>
--   </pre>
type ATraversal' s a = ATraversal s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal1</a>.
type ATraversal1 s t a b = LensLike (Bazaar1 (->) a b) s t a b

-- | <pre>
--   type <a>ATraversal1'</a> = <a>Simple</a> <a>ATraversal1</a>
--   </pre>
type ATraversal1' s a = ATraversal1 s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal</a>.
type AnIndexedTraversal i s t a b = Over (Indexed i) (Bazaar (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedTraversal'</a> = <a>Simple</a> (<a>AnIndexedTraversal</a> i)
--   </pre>
type AnIndexedTraversal' i s a = AnIndexedTraversal i s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal1</a>.
type AnIndexedTraversal1 i s t a b = Over (Indexed i) (Bazaar1 (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedTraversal1'</a> = <a>Simple</a> (<a>AnIndexedTraversal1</a> i)
--   </pre>
type AnIndexedTraversal1' i s a = AnIndexedTraversal1 i s s a a

-- | When you see this as an argument to a function, it expects
--   
--   <ul>
--   <li>to be indexed if <tt>p</tt> is an instance of <a>Indexed</a>
--   i,</li>
--   <li>to be unindexed if <tt>p</tt> is <tt>(-&gt;)</tt>,</li>
--   <li>a <a>Traversal</a> if <tt>f</tt> is <a>Applicative</a>,</li>
--   <li>a <a>Getter</a> if <tt>f</tt> is only a <a>Functor</a> and
--   <tt>Contravariant</tt>,</li>
--   <li>a <a>Lens</a> if <tt>p</tt> is only a <a>Functor</a>,</li>
--   <li>a <a>Fold</a> if <tt>f</tt> is <a>Functor</a>,
--   <tt>Contravariant</tt> and <a>Applicative</a>.</li>
--   </ul>
type Traversing p f s t a b = Over p (BazaarT p f a b) s t a b

-- | <pre>
--   type <a>Traversing'</a> f = <a>Simple</a> (<a>Traversing</a> f)
--   </pre>
type Traversing' p f s a = Traversing p f s s a a
type Traversing1 p f s t a b = Over p (BazaarT1 p f a b) s t a b
type Traversing1' p f s a = Traversing1 p f s s a a

-- | Map each element of a structure targeted by a <a>Lens</a> or
--   <a>Traversal</a>, evaluate these actions from left to right, and
--   collect the results.
--   
--   This function is only provided for consistency, <a>id</a> is strictly
--   more general.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf each print (1,2,3)
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a>  <a>id</a>
--   <a>itraverseOf</a> l  <a>traverseOf</a> l <a>.</a> <a>Indexed</a>
--   <a>itraverseOf</a> <tt>itraversed</tt>  <tt>itraverse</tt>
--   </pre>
--   
--   This yields the obvious law:
--   
--   <pre>
--   <a>traverse</a>  <a>traverseOf</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t a b      -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
traverseOf :: Over p f s t a b -> p a (f b) -> s -> f t

-- | A version of <a>traverseOf</a> with the arguments flipped, such that:
--   
--   <pre>
--   &gt;&gt;&gt; forOf each (1,2,3) print
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   This function is only provided for consistency, <a>flip</a> is
--   strictly more general.
--   
--   <pre>
--   <a>forOf</a>  <a>flip</a>
--   <a>forOf</a>  <a>flip</a> . <a>traverseOf</a>
--   </pre>
--   
--   <pre>
--   <a>for</a>  <a>forOf</a> <a>traverse</a>
--   <a>ifor</a> l s  <a>for</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   </pre>
forOf :: Over p f s t a b -> s -> p a (f b) -> f t

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf both ([1,2],[3,4])
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>sequenceA</a>  <a>sequenceAOf</a> <a>traverse</a>  <a>traverse</a> <a>id</a>
--   <a>sequenceAOf</a> l  <a>traverseOf</a> l <a>id</a>  l <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t (f b) b       -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t (f b) b      -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t (f b) b -&gt; s -&gt; f t
--   </pre>
sequenceAOf :: LensLike f s t (f b) b -> s -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf both (\x -&gt; [x, x + 1]) (1,3)
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>mapM</a>  <a>mapMOf</a> <a>traverse</a>
--   <a>imapMOf</a> l  <a>forM</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
mapMOf :: Profunctor p => Over p (WrappedMonad m) s t a b -> p a (m b) -> s -> m t

-- | <a>forMOf</a> is a flipped version of <a>mapMOf</a>, consistent with
--   the definition of <a>forM</a>.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf both (1,3) $ \x -&gt; [x, x + 1]
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>forM</a>  <a>forMOf</a> <a>traverse</a>
--   <a>forMOf</a> l  <a>flip</a> (<a>mapMOf</a> l)
--   <a>iforMOf</a> l s  <a>forM</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   </pre>
forMOf :: Profunctor p => Over p (WrappedMonad m) s t a b -> s -> p a (m b) -> m t

-- | Sequence the (monadic) effects targeted by a <a>Lens</a> in a
--   container from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf each ([1,2],[3,4],[5,6])
--   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
--   </pre>
--   
--   <pre>
--   <a>sequence</a>  <a>sequenceOf</a> <a>traverse</a>
--   <a>sequenceOf</a> l  <a>mapMOf</a> l <a>id</a>
--   <a>sequenceOf</a> l  <a>unwrapMonad</a> <a>.</a> l <a>WrapMonad</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t (m b) b       -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t (m b) b      -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t (m b) b -&gt; s -&gt; m t
--   </pre>
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t

-- | This generalizes <a>transpose</a> to an arbitrary <a>Traversal</a>.
--   
--   Note: <a>transpose</a> handles ragged inputs more intelligently, but
--   for non-ragged inputs:
--   
--   <pre>
--   &gt;&gt;&gt; transposeOf traverse [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   <pre>
--   <a>transpose</a>  <a>transposeOf</a> <a>traverse</a>
--   </pre>
--   
--   Since every <a>Lens</a> is a <a>Traversal</a>, we can use this as a
--   form of monadic strength as well:
--   
--   <pre>
--   <a>transposeOf</a> <a>_2</a> :: (b, [a]) -&gt; [(b, a)]
--   </pre>
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]

-- | This generalizes <a>mapAccumL</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumL</a>  <a>mapAccumLOf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumLOf</a> accumulates <a>State</a> from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>LensLike</a> (<a>State</a> acc) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> l f acc0 s = <a>swap</a> (<a>runState</a> (l (a -&gt; <a>state</a> (acc -&gt; <a>swap</a> (f acc a))) s) acc0)
--   </pre>
mapAccumLOf :: Conjoined p => Over p (State acc) s t a b -> p acc (a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This generalizes <a>mapAccumR</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumR</a>  <a>mapAccumROf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumROf</a> accumulates <a>State</a> from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>LensLike</a> (<a>Backwards</a> (<a>State</a> acc)) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
mapAccumROf :: Conjoined p => Over p (Backwards (State acc)) s t a b -> p acc (a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanr1</a>  <a>scanr1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanr1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanl1</a>  <a>scanl1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanl1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t

-- | Try to map a function over this <a>Traversal</a>, failing if the
--   <a>Traversal</a> has no targets.
--   
--   <pre>
--   &gt;&gt;&gt; failover (element 3) (*2) [1,2] :: Maybe [Int]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Left (*2) (Right 4) :: Maybe (Either Int Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Right (*2) (Right 4) :: Maybe (Either Int Int)
--   Just (Right 8)
--   </pre>
--   
--   <pre>
--   <a>failover</a> :: Alternative m =&gt; Traversal s t a b -&gt; (a -&gt; b) -&gt; s -&gt; m t
--   </pre>
failover :: (Profunctor p, Alternative m) => Over p ((,) Any) s t a b -> p a b -> s -> m t

-- | Try to map a function which uses the index over this
--   <a>IndexedTraversal</a>, failing if the <a>IndexedTraversal</a> has no
--   targets.
--   
--   <pre>
--   <a>ifailover</a> :: Alternative m =&gt; IndexedTraversal i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; m t
--   </pre>
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t

-- | A <a>Traversal</a> is completely characterized by its behavior on a
--   <a>Bazaar</a>.
--   
--   Cloning a <a>Traversal</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Fold</a> and can be used as a way to
--   pass around traversals that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Traversal</a> (or <a>Lens</a>). To
--   clone a <a>Lens</a> as such, use <a>cloneLens</a>.
--   
--   Note: It is usually better to use <a>ReifiedTraversal</a> and
--   <a>runTraversal</a> than to <a>cloneTraversal</a>. The former can
--   execute at full speed, while the latter needs to round trip through
--   the <a>Bazaar</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let foo l a = (view (coerced (cloneTraversal l)) a, set (cloneTraversal l) 10 a)
--   
--   &gt;&gt;&gt; foo both ("hello","world")
--   ("helloworld",(10,10))
--   </pre>
--   
--   <pre>
--   <a>cloneTraversal</a> :: <a>LensLike</a> (<a>Bazaar</a> (-&gt;) a b) s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
cloneTraversal :: ATraversal s t a b -> Traversal s t a b

-- | Clone a <a>Traversal</a> yielding an <a>IndexPreservingTraversal</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b

-- | Clone an <a>IndexedTraversal</a> yielding an <a>IndexedTraversal</a>
--   with the same index.
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | A <a>Traversal1</a> is completely characterized by its behavior on a
--   <a>Bazaar1</a>.
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b

-- | Clone a <a>Traversal1</a> yielding an <a>IndexPreservingTraversal1</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b

-- | Clone an <a>IndexedTraversal1</a> yielding an <a>IndexedTraversal1</a>
--   with the same index.
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b

-- | <a>partsOf</a> turns a <a>Traversal</a> into a <a>Lens</a> that
--   resembles an early version of the <a>uniplate</a> (or <a>biplate</a>)
--   type.
--   
--   <i>Note:</i> You should really try to maintain the invariant of the
--   number of children in the list.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y,z]
--   (x,y,z)
--   </pre>
--   
--   Any extras will be lost. If you do not supply enough, then the
--   remainder will come from the original structure.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [w,x,y,z]
--   (w,x,y)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y]
--   (x,y,c)
--   </pre>
--   
--   So technically, this is only a <a>Lens</a> if you do not change the
--   number of results it returns.
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>.
--   
--   <pre>
--   <a>partsOf</a> :: <a>Iso'</a> s a       -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Traversal'</a> s a -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Fold</a> s a       -&gt; <a>Getter</a> s [a]
--   <a>partsOf</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s [a]
--   </pre>
partsOf :: Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]

-- | A type-restricted version of <a>partsOf</a> that can only be used with
--   a <a>Traversal</a>.
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]

-- | <a>unsafePartsOf</a> turns a <a>Traversal</a> into a <a>uniplate</a>
--   (or <a>biplate</a>) family.
--   
--   If you do not need the types of <tt>s</tt> and <tt>t</tt> to be
--   different, it is recommended that you use <a>partsOf</a>.
--   
--   It is generally safer to traverse with the <a>Bazaar</a> rather than
--   use this combinator. However, it is sometimes convenient.
--   
--   This is unsafe because if you don't supply at least as many
--   <tt>b</tt>'s as you were given <tt>a</tt>'s, then the reconstruction
--   of <tt>t</tt> <i>will</i> result in an error!
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>
--   (and becomes safe).
--   
--   <pre>
--   <a>unsafePartsOf</a> :: <a>Iso</a> s t a b       -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Lens</a> s t a b      -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Traversal</a> s t a b -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Fold</a> s a          -&gt; <a>Getter</a> s [a]
--   <a>unsafePartsOf</a> :: <a>Getter</a> s a        -&gt; <a>Getter</a> s [a]
--   </pre>
unsafePartsOf :: Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]

-- | The one-level version of <a>contextsOf</a>. This extracts a list of
--   the immediate children according to a given <a>Traversal</a> as
--   editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren l x = childrenOf l x <a>==</a> <a>map</a> <a>pos</a> (<a>holesOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holesOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holesOf</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   <a>holesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   </pre>
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | This converts a <a>Traversal</a> that you "know" will target one or
--   more elements to a <a>Lens</a>. It can also be used to transform a
--   non-empty <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   supplied <a>Traversal</a> returns no results.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. singular _head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^. singular _head
--   *** Exception: singular: empty traversal
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^. singular _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^. singular (ix 7)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; singular traverse .~ 0
--   []
--   </pre>
--   
--   <pre>
--   <a>singular</a> :: <a>Traversal</a> s t a a          -&gt; <a>Lens</a> s t a a
--   <a>singular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>singular</a> :: <a>IndexedTraversal</a> i s t a a -&gt; <a>IndexedLens</a> i s t a a
--   <a>singular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
singular :: (Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a

-- | This converts a <a>Traversal</a> that you "know" will target only one
--   element to a <a>Lens</a>. It can also be used to transform a
--   <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   <a>Traversal</a> targets nothing or more than one element.
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; unsafeSingular traverse .~ 0
--   *** Exception: unsafeSingular: empty traversal
--   </pre>
--   
--   <pre>
--   <a>unsafeSingular</a> :: <a>Traversal</a> s t a b          -&gt; <a>Lens</a> s t a b
--   <a>unsafeSingular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>unsafeSingular</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedLens</a> i s t a b
--   <a>unsafeSingular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
unsafeSingular :: (Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   Minimal complete definition: <a>traverse</a> or <a>sequenceA</a>.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Indentity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: * -> *)
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
class (Foldable1 t, Traversable t) => Traversable1 (t :: * -> *)
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)

-- | Traverse both parts of a <a>Bitraversable</a> container with matching
--   types.
--   
--   Usually that type will be a pair.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; both *~ 10
--   (10,20)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both length ("hello","world")
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.both
--   "helloworld"
--   </pre>
--   
--   <pre>
--   <a>both</a> :: <a>Traversal</a> (a, a)       (b, b)       a b
--   <a>both</a> :: <a>Traversal</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both :: Bitraversable r => Traversal (r a a) (r b b) a b

-- | Apply a different <a>Traversal</a> or <a>Fold</a> to each side of a
--   <a>Bitraversable</a> container.
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (r s s') (r t t') a b
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Lens</a> s t a b                     -&gt; <a>Lens</a> s' t' a b                     -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Fold</a> s a                         -&gt; <a>Fold</a> s' a                          -&gt; <a>Fold</a> (s,s') a
--   <a>beside</a> :: <a>Getter</a> s a                       -&gt; <a>Getter</a> s' a                        -&gt; <a>Fold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedLens</a> i s t a b            -&gt; <a>IndexedLens</a> i s' t' a b            -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s' a                 -&gt; <a>IndexedFold</a> i (s,s') a
--   <a>beside</a> :: <a>IndexedGetter</a> i s a              -&gt; <a>IndexedGetter</a> i s' a               -&gt; <a>IndexedFold</a> i (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingLens</a> s t a b      -&gt; <a>IndexPreservingLens</a> s' t' a b      -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s' a           -&gt; <a>IndexPreservingFold</a> (s,s') a
--   <a>beside</a> :: <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingGetter</a> s' a         -&gt; <a>IndexPreservingFold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",["world","!!!"])^..beside id traverse
--   ["hello","world","!!!"]
--   </pre>
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b

-- | Visit the first <i>n</i> targets of a <a>Traversal</a>, <a>Fold</a>,
--   <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [("hello","world"),("!!!","!!!")]^.. taking 2 (traverse.both)
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1..] ^.. taking 3 traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (taking 5 traverse) succ "hello world"
--   "ifmmp world"
--   </pre>
--   
--   <pre>
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a

-- | Visit all but the first <i>n</i> targets of a <a>Traversal</a>,
--   <a>Fold</a>, <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") ^? dropping 1 both
--   Just "world"
--   </pre>
--   
--   Dropping works on infinite traversals as well:
--   
--   <pre>
--   &gt;&gt;&gt; [1..] ^? dropping 1 folded
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a

-- | Try the first <a>Traversal</a> (or <a>Fold</a>), falling back on the
--   second <a>Traversal</a> (or <a>Fold</a>) if it returns no entries.
--   
--   This is only a valid <a>Traversal</a> if the second <a>Traversal</a>
--   is disjoint from the result of the first or returns exactly the same
--   results. These conditions are trivially met when given a <a>Lens</a>,
--   <a>Iso</a>, <a>Getter</a>, <a>Prism</a> or "affine" Traversal -- one
--   that has 0 or 1 target.
--   
--   Mutatis mutandis for <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 1) (ix 2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 42) (ix 2)
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>failing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Prism</a> s t a b     -&gt; <a>Prism</a> s t a b     -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Fold</a> s a          -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>Lens</a> s t a b      -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Iso</a> s t a b       -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Equality</a> s t a b  -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Getter</a> s a        -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   If both of the inputs are indexed, the result is also indexed, so you
--   can apply this to a pair of indexed traversals or indexed folds,
--   obtaining an indexed traversal or indexed fold.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedGetter</a> i s a        -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b

-- | Try the second traversal. If it returns no entries, try again with all
--   entries from the first traversal, recursively.
--   
--   <pre>
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>Fold</a> s a                   -&gt; <a>Fold</a> s a
--   <a>deepOf</a> :: <a>Traversal'</a> s s    -&gt; <a>Traversal'</a> s a             -&gt; <a>Traversal'</a> s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>Traversal</a> s t a b          -&gt; <a>Traversal</a> s t a b
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   </pre>
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b

-- | This is the trivial empty <a>Traversal</a>.
--   
--   <pre>
--   <a>ignored</a> :: <a>IndexedTraversal</a> i s s a b
--   </pre>
--   
--   <pre>
--   <a>ignored</a>  <a>const</a> <a>pure</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: Applicative f => pafb -> s -> f s

-- | Allows <a>IndexedTraversal</a> the value at the smallest index.
class Ord k => TraverseMin k m | m -> k
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v

-- | Allows <a>IndexedTraversal</a> of the value at the largest index.
class Ord k => TraverseMax k m | m -> k
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b

-- | Traverse any <a>Traversable1</a> container. This is an
--   <a>IndexedTraversal1</a> that is indexed by ordinal position.
traversed1 :: Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed64 :: Traversable f => IndexedTraversal Int64 (f a) (f b) a b

-- | Traverse the <i>nth</i> <a>elementOf</a> a <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a> if it exists.
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] &amp; elementOf (traverse.traverse) 1 .~ 5
--   [[1],[5,4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] ^? elementOf (folded.folded) 1
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ ['a'..] ^?! elementOf folded 5
--   'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ take 10 $ elementOf traverse 3 .~ 16 $ [0..]
--   [0,1,2,16,4,5,6,7,8,9]
--   </pre>
--   
--   <pre>
--   <a>elementOf</a> :: <a>Traversal'</a> s a -&gt; <a>Int</a> -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementOf</a> :: <a>Fold</a> s a       -&gt; <a>Int</a> -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementOf :: Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a

-- | Traverse the <i>nth</i> element of a <a>Traversable</a> container.
--   
--   <pre>
--   <a>element</a>  <a>elementOf</a> <a>traverse</a>
--   </pre>
element :: Traversable t => Int -> IndexedTraversal' Int (t a) a

-- | Traverse (or fold) selected elements of a <a>Traversal</a> (or
--   <a>Fold</a>) where their ordinal positions match a predicate.
--   
--   <pre>
--   <a>elementsOf</a> :: <a>Traversal'</a> s a -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementsOf</a> :: <a>Fold</a> s a       -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementsOf :: Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a

-- | Traverse elements of a <a>Traversable</a> container where their
--   ordinal positions match a predicate.
--   
--   <pre>
--   <a>elements</a>  <a>elementsOf</a> <a>traverse</a>
--   </pre>
elements :: Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a

-- | An indexed version of <a>partsOf</a> that receives the entire list of
--   indices as its index.
ipartsOf :: (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]

-- | A type-restricted version of <a>ipartsOf</a> that can only be used
--   with an <a>IndexedTraversal</a>.
ipartsOf' :: (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]

-- | An indexed version of <a>unsafePartsOf</a> that receives the entire
--   list of indices as its index.
iunsafePartsOf :: (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]
iunsafePartsOf' :: Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]

-- | Traversal with an index.
--   
--   <i>NB:</i> When you don't need access to the index then you can just
--   apply your <a>IndexedTraversal</a> directly as a function!
--   
--   <pre>
--   <a>itraverseOf</a>  <a>withIndex</a>
--   <a>traverseOf</a> l = <a>itraverseOf</a> l <a>.</a> <a>const</a> = <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <tt>Apply</tt> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <a>forOf</a> l a  <a>iforOf</a> l a <a>.</a> <a>const</a>
--   <a>iforOf</a>  <a>flip</a> <a>.</a> <a>itraverseOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <tt>Apply</tt> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   </pre>
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position.
--   
--   When you don't need access to the index <a>mapMOf</a> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <a>mapMOf</a> l  <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a>       i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a>  i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <tt>Bind</tt>  m =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
imapMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> (i -> a -> m b) -> s -> m t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position (and the arguments flipped).
--   
--   <pre>
--   <a>forMOf</a> l a  <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   <a>iforMOf</a>  <a>flip</a> <a>.</a> <a>imapMOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a> i s t a b      -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   </pre>
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t

-- | Generalizes <a>mapAccumR</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> l  <a>imapAccumROf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumROf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumROf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Generalizes <a>mapAccumL</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> l  <a>imapAccumLOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumLOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumLOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar</a> a b t</tt>
--   holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar</a> holds many stores and you can easily add
--   more.
--   
--   This is a final encoding of <a>Bazaar</a>.
newtype Bazaar p a b t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
runBazaar :: Bazaar p a b t -> forall f. Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar'</a> p a t = <a>Bazaar</a> p a a t
--   </pre>
type Bazaar' p a = Bazaar p a a

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar1</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar1</a> a b
--   t</tt> holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar1</a> holds many stores and you can easily
--   add more.
--   
--   This is a final encoding of <a>Bazaar1</a>.
newtype Bazaar1 p a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
runBazaar1 :: Bazaar1 p a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar1'</a> p a t = <a>Bazaar1</a> p a a t
--   </pre>
type Bazaar1' p a = Bazaar1 p a a

-- | This <a>Traversal</a> allows you to <a>traverse</a> the individual
--   stores in a <a>Bazaar</a>.
loci :: Traversal (Bazaar (->) a c s) (Bazaar (->) b c s) a b

-- | This <a>IndexedTraversal</a> allows you to <a>traverse</a> the
--   individual stores in a <a>Bazaar</a> with access to their indices.
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b

-- | <a>Fuse</a> a <a>Traversal</a> by reassociating all of the
--   <tt>\&lt;*\&gt;</tt> operations to the left and fusing all of the
--   <a>fmap</a> calls into one. This is particularly useful when
--   constructing a <a>Traversal</a> using operations from GHC.Generics.
--   
--   Given a pair of <a>Traversal</a>s <tt>foo</tt> and <tt>bar</tt>,
--   
--   <pre>
--   <a>confusing</a> (foo.bar) = foo.bar
--   </pre>
--   
--   However, <tt>foo</tt> and <tt>bar</tt> are each going to use the
--   <a>Applicative</a> they are given.
--   
--   <a>confusing</a> exploits the <a>Yoneda</a> lemma to merge their
--   separate uses of <a>fmap</a> into a single <a>fmap</a>. and it further
--   exploits an interesting property of the right Kan lift (or
--   <a>Rift</a>) to left associate all of the uses of '(<a>*</a>)' to make
--   it possible to fuse together more fmaps.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Traversal</a>
--   <tt>foo.bar</tt> in the above description is recursive or complex
--   enough to prevent inlining.
--   
--   <a>fusing</a> is a version of this combinator suitable for fusing
--   lenses.
--   
--   <pre>
--   <a>confusing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
confusing :: Applicative f => LensLike (Rift (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b
instance Ord k => TraverseMax k (Map k)
instance TraverseMax Int IntMap
instance Ord k => TraverseMin k (Map k)
instance TraverseMin Int IntMap


-- | (The classes in here need to be defined together for
--   <tt>DefaultSignatures</tt> to work.)
module Control.Lens.Indexed

-- | This class permits overloading of function application for things that
--   also admit a notion of a key or index.
class Conjoined p => Indexable i p
indexed :: Indexable i p => p a b -> i -> a -> b

-- | This is a <a>Profunctor</a> that is both <a>Corepresentable</a> by
--   <tt>f</tt> and <a>Representable</a> by <tt>g</tt> such that <tt>f</tt>
--   is left adjoint to <tt>g</tt>. From this you can derive a lot of
--   structure due to the preservation of limits and colimits.
class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p where distrib = tabulate . collect . sieve conjoined _ r = r
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r

-- | A function with access to a index. This constructor may be useful when
--   you need to store an <a>Indexable</a> in a container to avoid
--   <tt>ImpredicativeTypes</tt>.
--   
--   <pre>
--   index :: Indexed i a b -&gt; i -&gt; a -&gt; b
--   </pre>
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
runIndexed :: Indexed i a b -> i -> a -> b

-- | Compose an <a>Indexed</a> function with a non-indexed function.
--   
--   Mnemonically, the <tt>&lt;</tt> points to the indexing we want to
--   preserve.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.itraversed).withIndex
--   [(1,"one,ten"),(1,"one,twenty"),(2,"two,thirty"),(2,"two,forty")]
--   </pre>
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r

-- | Composition of <a>Indexed</a> functions.
--   
--   Mnemonically, the <tt>&lt;</tt> and <tt>&gt;</tt> points to the fact
--   that we want to preserve the indices.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.&gt;itraversed).withIndex
--   [((1,10),"one,ten"),((1,20),"one,twenty"),((2,30),"two,thirty"),((2,40),"two,forty")]
--   </pre>
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r

-- | Compose a non-indexed function with an <a>Indexed</a> function.
--   
--   Mnemonically, the <tt>&gt;</tt> points to the indexing we want to
--   preserve.
--   
--   This is the same as <tt>(<a>.</a>)</tt>.
--   
--   <tt>f <a>.</a> g</tt> (and <tt>f <a>.&gt;</a> g</tt>) gives you the
--   index of <tt>g</tt> unless <tt>g</tt> is index-preserving, like a
--   <a>Prism</a>, <a>Iso</a> or <a>Equality</a>, in which case it'll pass
--   through the index of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed.&gt;itraversed).withIndex
--   [(10,"one,ten"),(20,"one,twenty"),(30,"two,thirty"),(40,"two,forty")]
--   </pre>
(.>) :: (st -> r) -> (kab -> st) -> kab -> r

-- | Use a value itself as its own index. This is essentially an indexed
--   version of <a>id</a>.
--   
--   Note: When used to modify the value, this can break the index
--   requirements assumed by <a>indices</a> and similar, so this is only
--   properly an <a>IndexedGetter</a>, but it can be used as more.
--   
--   <pre>
--   <a>selfIndex</a> ::<a>IndexedGetter</a> a a b
--   </pre>
selfIndex :: Indexable a p => p a fb -> a -> fb

-- | Remap the index.
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r

-- | Composition of <a>Indexed</a> functions with a user supplied function
--   for combining indices.
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   <pre>
--   <a>indexing</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int</a>  s t a b
--   <a>indexing</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   <a>indexing</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing</a> :: <a>Indexable</a> <a>Int</a> p =&gt; <a>LensLike</a> (<a>Indexing</a> f) s t a b -&gt; <a>Optical</a> p (-&gt;) f s t a b
--   </pre>
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   This combinator is like <a>indexing</a> except that it handles large
--   traversals and folds gracefully.
--   
--   <pre>
--   <a>indexing64</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int64</a> s a
--   <a>indexing64</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int64</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing64</a> :: <a>Indexable</a> <a>Int64</a> p =&gt; <a>LensLike</a> (<a>Indexing64</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g  <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a)  <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i f | f -> i where imap = iover itraversed imapped = conjoined mapped (isets imap)
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i f | f -> i where ifoldMap = ifoldMapOf itraversed ifolded = conjoined folded $ \ f -> coerce . getFolding . ifoldMap (\ i -> Folding #. indexed f i) ifoldr f z t = appEndo (ifoldMap (\ i -> Endo #. f i) t) z ifoldl f z t = appEndo (getDual (ifoldMap (\ i -> Dual #. Endo #. flip (f i)) t)) z ifoldr' f z0 xs = ifoldl f' id xs z0 where f' i k x z = k $! f i x z ifoldl' f z0 xs = ifoldr f' id xs z0 where f' i x k z = k $! f i z x
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | Return whether or not any element in a container satisfies a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>any</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>any</a>  <a>iany</a> <a>.</a> <a>const</a>
--   </pre>
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not all elements in a container satisfy a predicate,
--   with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>all</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>all</a>  <a>iall</a> <a>.</a> <a>const</a>
--   </pre>
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not none of the elements in a container satisfy a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>none</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>none</a>  <a>inone</a> <a>.</a> <a>const</a>
--   <a>inone</a> f  <a>not</a> <a>.</a> <a>iany</a> f
--   </pre>
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Determines whether no elements of the structure satisfy the predicate.
--   
--   <pre>
--   <a>none</a> f  <a>not</a> <a>.</a> <a>any</a> f
--   </pre>
none :: Foldable f => (a -> Bool) -> f a -> Bool

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <a>traverse_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>traverse_</a> l = <a>itraverse</a> <a>.</a> <a>const</a>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a>  <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>for_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>for_</a> a  <a>ifor_</a> a <a>.</a> <a>const</a>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>mapM_</a>  <a>imapM</a> <a>.</a> <a>const</a>
--   </pre>
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforM_</a>  <a>flip</a> <a>imapM_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forMOf_</a> l a  <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   </pre>
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()

-- | Concatenate the results of a function of the elements of an indexed
--   container with access to the index.
--   
--   When you don't need access to the index then <a>concatMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>concatMap</a>  <a>iconcatMap</a> <a>.</a> <a>const</a>
--   <a>iconcatMap</a>  <a>ifoldMap</a>
--   </pre>
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]

-- | Searches a container with a predicate that is also supplied the index,
--   returning the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>find</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>find</a>  <a>ifind</a> <a>.</a> <a>const</a>
--   </pre>
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <a>foldrM</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrM</a>  <a>ifoldrM</a> <a>.</a> <a>const</a>
--   </pre>
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <a>foldlM</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlM</a>  <a>ifoldlM</a> <a>.</a> <a>const</a>
--   </pre>
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <a>toList</a> is more flexible in what it accepts.
--   
--   <pre>
--   <a>toList</a>  <a>map</a> <a>snd</a> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]

-- | Fold a container with indices returning both the indices and the
--   values.
--   
--   The result is only valid to compose in a <tt>Traversal</tt>, if you
--   don't edit the index as edits to the index have no effect.
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)

-- | When composed with an <tt>IndexedFold</tt> or
--   <tt>IndexedTraversal</tt> this yields an (<a>Indexed</a>)
--   <tt>Fold</tt> of the indices.
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on a predicate on
--   the indices.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^..traversed.indices even
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traversed.indices (&gt;0)) Prelude.reverse $ ["He","was","stressed","o_O"]
--   ["He","saw","desserts","O_o"]
--   </pre>
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on an index.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^?traversed.index 2
--   Just "world"
--   </pre>
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<a>const</a> <a>Identity</a>)  <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g  <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i t | t -> i where itraverse = traversed .# Indexed itraversed = conjoined traverse (itraverse . indexed)
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <a>for</a> a  <a>ifor</a> a <a>.</a> <a>const</a>
--   <a>ifor</a>  <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access the
--   index.
--   
--   When you don't need access to the index <a>mapM</a> is more liberal in
--   what it can accept.
--   
--   <pre>
--   <a>mapM</a>  <a>imapM</a> <a>.</a> <a>const</a>
--   </pre>
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access its
--   position (and the arguments flipped).
--   
--   <pre>
--   <a>forM</a> a  <a>iforM</a> a <a>.</a> <a>const</a>
--   <a>iforM</a>  <a>flip</a> <a>imapM</a>
--   </pre>
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)

-- | Generalizes <a>mapAccumR</a> to add access to the index.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumR</a>  <a>imapAccumR</a> <a>.</a> <a>const</a>
--   </pre>
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Generalizes <a>mapAccumL</a> to add access to the index.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a>  <a>imapAccumL</a> <a>.</a> <a>const</a>
--   </pre>
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r
ifoldMapByOf :: (forall s. IndexedGetting i (M r s) t a) -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
instance TraversableWithIndex [Int] Tree
instance FoldableWithIndex [Int] Tree
instance FunctorWithIndex [Int] Tree
instance FunctorWithIndex i w => FunctorWithIndex (s, i) (TracedT s w)
instance FunctorWithIndex i m => FunctorWithIndex (e, i) (ReaderT e m)
instance (TraversableWithIndex i f, TraversableWithIndex j g) => TraversableWithIndex (Either i j) (Product f g)
instance (FoldableWithIndex i f, FoldableWithIndex j g) => FoldableWithIndex (Either i j) (Product f g)
instance (FunctorWithIndex i f, FunctorWithIndex j g) => FunctorWithIndex (Either i j) (Product f g)
instance TraversableWithIndex i m => TraversableWithIndex i (IdentityT m)
instance FoldableWithIndex i m => FoldableWithIndex i (IdentityT m)
instance FunctorWithIndex i m => FunctorWithIndex i (IdentityT m)
instance (TraversableWithIndex i f, TraversableWithIndex j g) => TraversableWithIndex (i, j) (Compose f g)
instance (FoldableWithIndex i f, FoldableWithIndex j g) => FoldableWithIndex (i, j) (Compose f g)
instance (FunctorWithIndex i f, FunctorWithIndex j g) => FunctorWithIndex (i, j) (Compose f g)
instance TraversableWithIndex i f => TraversableWithIndex [i] (Cofree f)
instance FoldableWithIndex i f => FoldableWithIndex [i] (Cofree f)
instance FunctorWithIndex i f => FunctorWithIndex [i] (Cofree f)
instance Ix i => TraversableWithIndex i (Array i)
instance Ix i => FoldableWithIndex i (Array i)
instance Ix i => FunctorWithIndex i (Array i)
instance TraversableWithIndex i f => TraversableWithIndex [i] (Free f)
instance FoldableWithIndex i f => FoldableWithIndex [i] (Free f)
instance FunctorWithIndex i f => FunctorWithIndex [i] (Free f)
instance TraversableWithIndex i (Magma i t b)
instance FoldableWithIndex i (Magma i t b)
instance FunctorWithIndex i (Magma i t b)
instance TraversableWithIndex i (Level i)
instance FoldableWithIndex i (Level i)
instance FunctorWithIndex i (Level i)
instance FunctorWithIndex r ((->) r)
instance (Eq k, Hashable k) => TraversableWithIndex k (HashMap k)
instance (Eq k, Hashable k) => FoldableWithIndex k (HashMap k)
instance (Eq k, Hashable k) => FunctorWithIndex k (HashMap k)
instance TraversableWithIndex k (Map k)
instance FoldableWithIndex k (Map k)
instance FunctorWithIndex k (Map k)
instance TraversableWithIndex Int IntMap
instance FoldableWithIndex Int IntMap
instance FunctorWithIndex Int IntMap
instance TraversableWithIndex Int Vector
instance FoldableWithIndex Int Vector
instance FunctorWithIndex Int Vector
instance TraversableWithIndex Int Seq
instance FoldableWithIndex Int Seq
instance FunctorWithIndex Int Seq
instance TraversableWithIndex () Maybe
instance FoldableWithIndex () Maybe
instance FunctorWithIndex () Maybe
instance TraversableWithIndex Int NonEmpty
instance FoldableWithIndex Int NonEmpty
instance FunctorWithIndex Int NonEmpty
instance TraversableWithIndex Int []
instance FoldableWithIndex Int []
instance FunctorWithIndex Int []
instance TraversableWithIndex k ((,) k)
instance FoldableWithIndex k ((,) k)
instance FunctorWithIndex k ((,) k)
instance TraversableWithIndex () Identity
instance FoldableWithIndex () Identity
instance FunctorWithIndex () Identity
instance TraversableWithIndex i f => TraversableWithIndex i (Reverse f)
instance FoldableWithIndex i f => FoldableWithIndex i (Reverse f)
instance FunctorWithIndex i f => FunctorWithIndex i (Reverse f)
instance TraversableWithIndex i f => TraversableWithIndex i (Backwards f)
instance FoldableWithIndex i f => FoldableWithIndex i (Backwards f)
instance FunctorWithIndex i f => FunctorWithIndex i (Backwards f)


-- | This module provides combinators for breadth-first searching within
--   arbitrary traversals.
module Control.Lens.Level

-- | This data type represents a path-compressed copy of one level of a
--   source data structure. We can safely use path-compression because we
--   know the depth of the tree.
--   
--   Path compression is performed by viewing a <a>Level</a> as a PATRICIA
--   trie of the paths into the structure to leaves at a given depth,
--   similar in many ways to a <a>IntMap</a>, but unlike a regular PATRICIA
--   trie we do not need to store the mask bits merely the depth of the
--   fork.
--   
--   One invariant of this structure is that underneath a <a>Two</a> node
--   you will not find any <a>Zero</a> nodes, so <a>Zero</a> can only occur
--   at the root.
data Level i a

-- | This provides a breadth-first <a>Traversal</a> of the individual
--   <a>levels</a> of any other <a>Traversal</a> via iterative deepening
--   depth-first search. The levels are returned to you in a compressed
--   format.
--   
--   This can permit us to extract the <a>levels</a> directly:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse)
--   [Zero,Zero,One () 'h',Two 0 (One () 'e') (One () 'w'),Two 0 (One () 'l') (One () 'o'),Two 0 (One () 'l') (One () 'r'),Two 0 (One () 'o') (One () 'l'),One () 'd']
--   </pre>
--   
--   But we can also traverse them in turn:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse).traverse
--   "hewlolrold"
--   </pre>
--   
--   We can use this to traverse to a fixed depth in the tree of
--   (<a>&lt;*&gt;</a>) used in the <a>Traversal</a>:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse)).traverse %~ toUpper
--   ["HEllo","World"]
--   </pre>
--   
--   Or we can use it to traverse the first <tt>n</tt> elements in found in
--   that <a>Traversal</a> regardless of the depth at which they were
--   found.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse).traverse) %~ toUpper
--   ["HELlo","World"]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the <a>levels</a> which is indexed
--   by the depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..levels (traverse.traverse) &lt;. traverse
--   [(2,'d'),(3,'o'),(3,'c'),(4,'g'),(4,'a'),(5,'t')]
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
levels :: ATraversal s t a b -> IndexedTraversal Int s t (Level () a) (Level () b)

-- | This provides a breadth-first <a>Traversal</a> of the individual
--   levels of any other <a>Traversal</a> via iterative deepening
--   depth-first search. The levels are returned to you in a compressed
--   format.
--   
--   This is similar to <a>levels</a>, but retains the index of the
--   original <a>IndexedTraversal</a>, so you can access it when traversing
--   the levels later on.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed).itraversed
--   [((0,0),'d'),((0,1),'o'),((1,0),'c'),((0,2),'g'),((1,1),'a'),((1,2),'t')]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the levels which is indexed by the
--   depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed)&lt;.&gt;itraversed
--   [((2,(0,0)),'d'),((3,(0,1)),'o'),((3,(1,0)),'c'),((4,(0,2)),'g'),((4,(1,1)),'a'),((5,(1,2)),'t')]
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
ilevels :: AnIndexedTraversal i s t a b -> IndexedTraversal Int s t (Level i a) (Level j b)


module Control.Lens.Reified

-- | Reify a <a>Lens</a> so it can be stored safely in a container.
newtype ReifiedLens s t a b
Lens :: Lens s t a b -> ReifiedLens s t a b
runLens :: ReifiedLens s t a b -> Lens s t a b

-- | <pre>
--   type <a>ReifiedLens'</a> = <a>Simple</a> <a>ReifiedLens</a>
--   </pre>
type ReifiedLens' s a = ReifiedLens s s a a

-- | Reify an <a>IndexedLens</a> so it can be stored safely in a container.
newtype ReifiedIndexedLens i s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
runIndexedLens :: ReifiedIndexedLens i s t a b -> IndexedLens i s t a b

-- | <pre>
--   type <a>ReifiedIndexedLens'</a> i = <a>Simple</a> (<a>ReifiedIndexedLens</a> i)
--   </pre>
type ReifiedIndexedLens' i s a = ReifiedIndexedLens i s s a a

-- | Reify an <a>IndexedTraversal</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedTraversal i s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
runIndexedTraversal :: ReifiedIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | <pre>
--   type <a>ReifiedIndexedTraversal'</a> i = <a>Simple</a> (<a>ReifiedIndexedTraversal</a> i)
--   </pre>
type ReifiedIndexedTraversal' i s a = ReifiedIndexedTraversal i s s a a

-- | A form of <a>Traversal</a> that can be stored monomorphically in a
--   container.
newtype ReifiedTraversal s t a b
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
runTraversal :: ReifiedTraversal s t a b -> Traversal s t a b

-- | <pre>
--   type <a>ReifiedTraversal'</a> = <a>Simple</a> <a>ReifiedTraversal</a>
--   </pre>
type ReifiedTraversal' s a = ReifiedTraversal s s a a

-- | Reify a <a>Getter</a> so it can be stored safely in a container.
--   
--   This can also be useful when combining getters in novel ways, as
--   <a>ReifiedGetter</a> is isomorphic to '(-&gt;)' and provides similar
--   instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world","!!!")^.runGetter ((,) &lt;$&gt; Getter _2 &lt;*&gt; Getter (_1.to length))
--   ("world",5)
--   </pre>
newtype ReifiedGetter s a
Getter :: Getter s a -> ReifiedGetter s a
runGetter :: ReifiedGetter s a -> Getter s a

-- | Reify an <a>IndexedGetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedGetter i s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
runIndexedGetter :: ReifiedIndexedGetter i s a -> IndexedGetter i s a

-- | Reify a <a>Fold</a> so it can be stored safely in a container.
--   
--   This can also be useful for creatively combining folds as
--   <tt><a>ReifiedFold</a> s</tt> is isomorphic to <tt>ReaderT s []</tt>
--   and provides similar instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^..runFold ((,) &lt;$&gt; Fold _2 &lt;*&gt; Fold both)
--   [("world","hello"),("world","world")]
--   </pre>
newtype ReifiedFold s a
Fold :: Fold s a -> ReifiedFold s a
runFold :: ReifiedFold s a -> Fold s a
newtype ReifiedIndexedFold i s a
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
runIndexedFold :: ReifiedIndexedFold i s a -> IndexedFold i s a

-- | Reify a <a>Setter</a> so it can be stored safely in a container.
newtype ReifiedSetter s t a b
Setter :: Setter s t a b -> ReifiedSetter s t a b
runSetter :: ReifiedSetter s t a b -> Setter s t a b

-- | <pre>
--   type <a>ReifiedSetter'</a> = <a>Simple</a> <a>ReifiedSetter</a>
--   </pre>
type ReifiedSetter' s a = ReifiedSetter s s a a

-- | Reify an <a>IndexedSetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedSetter i s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
runIndexedSetter :: ReifiedIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | <pre>
--   type <a>ReifiedIndexedSetter'</a> i = <a>Simple</a> (<a>ReifiedIndexedSetter</a> i)
--   </pre>
type ReifiedIndexedSetter' i s a = ReifiedIndexedSetter i s s a a

-- | Reify an <a>Iso</a> so it can be stored safely in a container.
newtype ReifiedIso s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
runIso :: ReifiedIso s t a b -> Iso s t a b

-- | <pre>
--   type <a>ReifiedIso'</a> = <a>Simple</a> <a>ReifiedIso</a>
--   </pre>
type ReifiedIso' s a = ReifiedIso s s a a

-- | Reify a <a>Prism</a> so it can be stored safely in a container.
newtype ReifiedPrism s t a b
Prism :: Prism s t a b -> ReifiedPrism s t a b
runPrism :: ReifiedPrism s t a b -> Prism s t a b

-- | <pre>
--   type <a>ReifiedPrism'</a> = <a>Simple</a> <a>ReifiedPrism</a>
--   </pre>
type ReifiedPrism' s a = ReifiedPrism s s a a
instance Strong (ReifiedIndexedFold i)
instance Representable (ReifiedIndexedFold i)
instance Sieve (ReifiedIndexedFold i) (Compose [] ((,) i))
instance Profunctor (ReifiedIndexedFold i)
instance Functor (ReifiedIndexedFold i s)
instance Plus (ReifiedIndexedFold i s)
instance Alt (ReifiedIndexedFold i s)
instance Monoid (ReifiedIndexedFold i s a)
instance Semigroup (ReifiedIndexedFold i s a)
instance Plus (ReifiedFold s)
instance Alt (ReifiedFold s)
instance Monoid (ReifiedFold s a)
instance Semigroup (ReifiedFold s a)
instance MonadReader s (ReifiedFold s)
instance MonadPlus (ReifiedFold s)
instance Monad (ReifiedFold s)
instance Bind (ReifiedFold s)
instance Alternative (ReifiedFold s)
instance Applicative (ReifiedFold s)
instance Apply (ReifiedFold s)
instance Functor (ReifiedFold s)
instance ArrowApply ReifiedFold
instance ArrowChoice ReifiedFold
instance Arrow ReifiedFold
instance Category ReifiedFold
instance Choice ReifiedFold
instance Strong ReifiedFold
instance Representable ReifiedFold
instance Sieve ReifiedFold []
instance Profunctor ReifiedFold
instance Semigroup i => Apply (ReifiedIndexedGetter i s)
instance Functor (ReifiedIndexedGetter i s)
instance Strong (ReifiedIndexedGetter i)
instance Representable (ReifiedIndexedGetter i)
instance Sieve (ReifiedIndexedGetter i) ((,) i)
instance Profunctor (ReifiedIndexedGetter i)
instance ArrowLoop ReifiedGetter
instance ArrowChoice ReifiedGetter
instance ArrowApply ReifiedGetter
instance Arrow ReifiedGetter
instance Category ReifiedGetter
instance Choice ReifiedGetter
instance Strong ReifiedGetter
instance Conjoined ReifiedGetter
instance Costrong ReifiedGetter
instance Representable ReifiedGetter
instance Sieve ReifiedGetter Identity
instance Corepresentable ReifiedGetter
instance Cosieve ReifiedGetter Identity
instance Profunctor ReifiedGetter
instance MonadReader s (ReifiedGetter s)
instance Monad (ReifiedGetter s)
instance Bind (ReifiedGetter s)
instance Applicative (ReifiedGetter s)
instance Apply (ReifiedGetter s)
instance Monoid s => ComonadApply (ReifiedGetter s)
instance Monoid s => Comonad (ReifiedGetter s)
instance Semigroup s => Extend (ReifiedGetter s)
instance Functor (ReifiedGetter s)
instance Distributive (ReifiedGetter s)


-- | Smart and nave generic traversals given <a>Data</a> instances.
--   
--   <a>template</a>, <a>uniplate</a>, and <a>biplate</a> each build up
--   information about what types can be contained within another type to
--   speed up <a>Traversal</a>.
module Data.Data.Lens

-- | Find every occurrence of a given type <tt>a</tt> recursively that
--   doesn't require passing through something of type <tt>a</tt> using
--   <a>Data</a>, while avoiding traversal of areas that cannot contain a
--   value of type <tt>a</tt>.
--   
--   This is <a>uniplate</a> with a more liberal signature.
template :: (Data s, Typeable a) => Traversal' s a

-- | Nave <a>Traversal</a> using <a>Data</a>. This does not attempt to
--   optimize the traversal.
--   
--   This is primarily useful when the children are immediately obvious,
--   and for benchmarking.
tinplate :: (Data s, Typeable a) => Traversal' s a

-- | Find descendants of type <tt>a</tt> non-transitively, while avoiding
--   computation of areas that cannot contain values of type <tt>a</tt>
--   using <a>Data</a>.
--   
--   <a>uniplate</a> is a useful default definition for <a>plate</a>
uniplate :: Data a => Traversal' a a

-- | <a>biplate</a> performs like <a>template</a>, except when <tt>s ~
--   a</tt>, it returns itself and nothing else.
biplate :: (Data s, Typeable a) => Traversal' s a

-- | This automatically constructs a <a>Traversal'</a> from an function.
--   
--   <pre>
--   &gt;&gt;&gt; (2,4) &amp; upon fst *~ 5
--   (10,4)
--   </pre>
--   
--   There are however, caveats on how this function can be used!
--   
--   First, the user supplied function must access only one field of the
--   specified type. That is to say the target must be a single element
--   that would be visited by <tt><tt>holesOnOf</tt> <a>template</a>
--   <a>uniplate</a></tt>
--   
--   Note: this even permits a number of functions to be used directly.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; upon head .~ 0
--   [0,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; upon last .~ 5
--   [1,2,3,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] ^? upon tail
--   Just [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? upon tail
--   Nothing
--   </pre>
--   
--   Accessing parents on the way down to children is okay:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; upon (tail.tail) .~ [10,20]
--   [1,2,10,20]
--   </pre>
--   
--   Second, the structure must not contain strict or unboxed fields of the
--   same type that will be visited by <a>Data</a>
--   
--   <pre>
--   <a>upon</a> :: (<a>Data</a> s, <a>Data</a> a) =&gt; (s -&gt; a) -&gt; <a>IndexedTraversal'</a> [Int] s a
--   </pre>
upon :: (Indexable [Int] p, Applicative f, Data s, Data a) => (s -> a) -> p a (f a) -> s -> f s

-- | The design of <a>onceUpon'</a> doesn't allow it to search inside of
--   values of type <tt>a</tt> for other values of type <tt>a</tt>.
--   <a>upon'</a> provides this additional recursion.
--   
--   Like <a>onceUpon'</a>, <a>upon'</a> trusts the user supplied function
--   more than <a>upon</a> using it directly as the accessor. This enables
--   reading from the resulting <a>Lens</a> to be considerably faster at
--   the risk of generating an illegal lens.
--   
--   <pre>
--   &gt;&gt;&gt; upon' (tail.tail) .~ [10,20] $ [1,2,3,4]
--   [1,2,10,20]
--   </pre>
upon' :: (Data s, Data a) => (s -> a) -> IndexedLens' [Int] s a

-- | This automatically constructs a <a>Traversal'</a> from a field
--   accessor.
--   
--   The index of the <a>Traversal</a> can be used as an offset into
--   <tt><a>elementOf</a> (<a>indexing</a> <a>template</a>)</tt> or into
--   the list returned by <tt><a>holesOf</a> <a>template</a></tt>.
--   
--   The design of <a>onceUpon</a> doesn't allow it to search inside of
--   values of type <tt>a</tt> for other values of type <tt>a</tt>.
--   <a>upon</a> provides this additional recursion, but at the expense of
--   performance.
--   
--   <pre>
--   &gt;&gt;&gt; onceUpon (tail.tail) .~ [10,20] $ [1,2,3,4] -- BAD
--   [1,10,20]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; upon (tail.tail) .~ [10,20] $ [1,2,3,4] -- GOOD
--   [1,2,10,20]
--   </pre>
--   
--   When in doubt, use <a>upon</a> instead.
onceUpon :: (Data s, Typeable a) => (s -> a) -> IndexedTraversal' Int s a

-- | This more trusting version of <a>upon</a> uses your function directly
--   as the getter for a <a>Lens</a>.
--   
--   This means that reading from <a>upon'</a> is considerably faster than
--   <a>upon</a>.
--   
--   However, you pay for faster access in two ways:
--   
--   <ol>
--   <li>When passed an illegal field accessor, <a>upon'</a> will give you
--   a <a>Lens</a> that quietly violates the laws, unlike <a>upon</a>,
--   which will give you a legal <a>Traversal</a> that avoids modifying the
--   target.</li>
--   <li>Modifying with the lens is slightly slower, since it has to go
--   back and calculate the index after the fact.</li>
--   </ol>
--   
--   When given a legal field accessor, the index of the <a>Lens</a> can be
--   used as an offset into <tt><a>elementOf</a> (<a>indexed</a>
--   <a>template</a>)</tt> or into the list returned by <tt><a>holesOf</a>
--   <a>template</a></tt>.
--   
--   When in doubt, use <a>upon'</a> instead.
onceUpon' :: (Data s, Typeable a) => (s -> a) -> IndexedLens' Int s a

-- | A generic applicative transformation that maps over the immediate
--   subterms.
--   
--   <a>gtraverse</a> is to <a>traverse</a> what <a>gmapM</a> is to
--   <a>mapM</a>
--   
--   This really belongs in <tt>Data.Data</tt>.
gtraverse :: (Applicative f, Data a) => (forall d. Data d => d -> f d) -> a -> f a
instance Typeable FieldException
instance Typeable a => Exception (FieldException a)
instance Show (FieldException a)


-- | The name "plate" stems originally from "boilerplate", which was the
--   term used by the "Scrap Your Boilerplate" papers, and later inherited
--   by Neil Mitchell's "Uniplate".
--   
--   <a>http://community.haskell.org/~ndm/uniplate/</a>
--   
--   The combinators in here are designed to be compatible with and subsume
--   the <tt>uniplate</tt> API with the notion of a <a>Traversal</a>
--   replacing a <a>uniplate</a> or <a>biplate</a>.
--   
--   By implementing these combinators in terms of <a>plate</a> instead of
--   <a>uniplate</a> additional type safety is gained, as the user is no
--   longer responsible for maintaining invariants such as the number of
--   children they received.
--   
--   Note: The <tt>Biplate</tt> is <i>deliberately</i> excluded from the
--   API here, with the intention that you replace them with either
--   explicit traversals, or by using the <tt>On</tt> variants of the
--   combinators below with <a>biplate</a> from <tt>Data.Data.Lens</tt>. As
--   a design, it forced the user into too many situations where they had
--   to choose between correctness and ease of use, and it was brittle in
--   the face of competing imports.
--   
--   The sensible use of these combinators makes some simple assumptions.
--   Notably, any of the <tt>On</tt> combinators are expecting a
--   <a>Traversal</a>, <a>Setter</a> or <a>Fold</a> to play the role of the
--   <a>biplate</a> combinator, and so when the types of the contents and
--   the container match, they should be the <a>id</a> <a>Traversal</a>,
--   <a>Setter</a> or <a>Fold</a>.
--   
--   It is often beneficial to use the combinators in this module with the
--   combinators from <tt>Data.Data.Lens</tt> or <tt>GHC.Generics.Lens</tt>
--   to make it easier to automatically derive definitions for
--   <a>plate</a>, or to derive custom traversals.
module Control.Lens.Plated

-- | A <a>Plated</a> type is one where we know how to extract its immediate
--   self-similar children.
--   
--   <i>Example 1</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Expr
--     = Val <a>Int</a>
--     | Neg Expr
--     | Add Expr Expr
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>,<a>Typeable</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> f (Neg e) = Neg <a>&lt;$&gt;</a> f e
--     <a>plate</a> f (Add a b) = Add <a>&lt;$&gt;</a> f a <a>&lt;*&gt;</a> f b
--     <a>plate</a> _ a = <a>pure</a> a
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   <i>Example 2</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Tree a
--     = Bin (Tree a) (Tree a)
--     | Tip a
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>,<a>Typeable</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> (Tree a) where
--     <a>plate</a> f (Bin l r) = Bin <a>&lt;$&gt;</a> f l <a>&lt;*&gt;</a> f r
--     <a>plate</a> _ t = <a>pure</a> t
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Data</a> a =&gt; <a>Plated</a> (Tree a) where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   Note the big distinction between these two implementations.
--   
--   The former will only treat children directly in this tree as
--   descendents, the latter will treat trees contained in the values under
--   the tips also as descendants!
--   
--   When in doubt, pick a <a>Traversal</a> and just use the various
--   <tt>...Of</tt> combinators rather than pollute <a>Plated</a> with
--   orphan instances!
--   
--   If you want to find something unplated and non-recursive with
--   <a>biplate</a> use the <tt>...OnOf</tt> variant with <a>ignored</a>,
--   though those usecases are much better served in most cases by using
--   the existing <a>Lens</a> combinators! e.g.
--   
--   <pre>
--   <a>toListOf</a> <a>biplate</a>  <a>universeOnOf</a> <a>biplate</a> <a>ignored</a>
--   </pre>
--   
--   This same ability to explicitly pass the <a>Traversal</a> in question
--   is why there is no analogue to uniplate's <tt>Biplate</tt>.
--   
--   Moreover, since we can allow custom traversals, we implement
--   reasonable defaults for polymorphic data types, that only
--   <a>traverse</a> into themselves, and <i>not</i> their polymorphic
--   arguments.
class Plated a where plate = uniplate
plate :: Plated a => Traversal' a a

-- | Extract the immediate descendants of a <a>Plated</a> container.
--   
--   <pre>
--   <a>children</a>  <a>toListOf</a> <a>plate</a>
--   </pre>
children :: Plated a => a -> [a]

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universe</a> (<a>rewrite</a> r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>a -&gt; f a
--   <tt>mplus</tt> g a</tt> which performs both rewrites until a fixed
--   point.
rewrite :: Plated a => (a -> Maybe a) -> a -> a

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewriteOf l r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universeOf</a> l (<a>rewriteOf</a> l r x))
--   </pre>
--   
--   Usually <a>transformOf</a> is more appropriate, but <a>rewriteOf</a>
--   can give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>a -&gt; f a
--   <tt>mplus</tt> g a</tt> which performs both rewrites until a fixed
--   point.
--   
--   <pre>
--   <a>rewriteOf</a> :: <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   </pre>
rewriteOf :: ASetter' a a -> (a -> Maybe a) -> a -> a

-- | Rewrite recursively over part of a larger structure.
--   
--   <pre>
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>ASetter'</a> s a   -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t

-- | Rewrite recursively over part of a larger structure using a specified
--   <a>Setter</a>.
--   
--   <pre>
--   <a>rewriteOnOf</a> :: <a>Plated</a> a =&gt; <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Plated</a> a =&gt; <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Plated</a> a =&gt; <a>Setter'</a> s a    -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOnOf :: ASetter s t a a -> ASetter' a a -> (a -> Maybe a) -> s -> t

-- | Rewrite by applying a monadic rule everywhere you can. Ensures that
--   the rule cannot be applied anywhere in the result.
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a

-- | Rewrite by applying a monadic rule everywhere you recursing with a
--   user-specified <a>Traversal</a>. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOf :: Monad m => LensLike' (WrappedMonad m) a a -> (a -> m (Maybe a)) -> a -> m a

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>. Ensures that the rule
--   cannot be applied anywhere in the result.
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>, using a user-specified
--   <a>Traversal</a> for recursion. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a a -> LensLike' (WrappedMonad m) a a -> (a -> m (Maybe a)) -> s -> m t

-- | Retrieve all of the transitive descendants of a <a>Plated</a>
--   container, including itself.
universe :: Plated a => a -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including
--   itself.
--   
--   <pre>
--   <a>universeOf</a> :: <a>Fold</a> a a -&gt; a -&gt; [a]
--   </pre>
universeOf :: Getting [a] a a -> a -> [a]

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container retrieve them and all of their descendants, recursively.
universeOn :: Plated a => Getting [a] s a -> s -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including itself
--   that lie in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>toListOf</a> l  <a>universeOnOf</a> l <a>ignored</a>
--   </pre>
universeOnOf :: Getting [a] s a -> Getting [a] a a -> s -> [a]

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = <a>transform</a> $ \x -&gt; case x of
--     Neg (Lit i) -&gt; Lit (<a>negate</a> i)
--     _           -&gt; x
--   </pre>
transform :: Plated a => (a -> a) -> a -> a

-- | Transform every element by recursively applying a given <a>Setter</a>
--   in a bottom-up manner.
--   
--   <pre>
--   <a>transformOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; a -&gt; a
--   <a>transformOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; a -&gt; a
--   </pre>
transformOf :: ASetter' a a -> (a -> a) -> a -> a

-- | Transform every element in the tree in a bottom-up manner over a
--   region indicated by a <a>Setter</a>.
--   
--   <pre>
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t

-- | Transform every element in a region indicated by a <a>Setter</a> by
--   recursively applying another <a>Setter</a> in a bottom-up manner.
--   
--   <pre>
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOnOf :: ASetter s t a a -> ASetter' a a -> (a -> a) -> s -> t

-- | Transform every element in the tree, in a bottom-up manner,
--   monadically.
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a

-- | Transform every element in a tree using a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; a -&gt; m a
--   </pre>
transformMOf :: Monad m => LensLike' (WrappedMonad m) a a -> (a -> m a) -> a -> m a

-- | Transform every element in the tree in a region indicated by a
--   supplied <a>Traversal</a>, in a bottom-up manner, monadically.
--   
--   <pre>
--   <a>transformMOn</a> :: (<a>Monad</a> m, <a>Plated</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t

-- | Transform every element in a tree that lies in a region indicated by a
--   supplied <a>Traversal</a>, walking with a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOnOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a a -> LensLike' (WrappedMonad m) a a -> (a -> m a) -> s -> m t

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively.
--   
--   <pre>
--   propUniverse x = <a>universe</a> x <a>==</a> <a>map</a> <a>pos</a> (<a>contexts</a> x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contexts</a> x]
--   </pre>
--   
--   <pre>
--   <a>contexts</a>  <a>contextsOf</a> <a>plate</a>
--   </pre>
contexts :: Plated a => a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively, using a user-specified <a>Traversal</a> to
--   walk each layer.
--   
--   <pre>
--   propUniverse l x = <a>universeOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>contextsOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contextsOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>contextsOf</a> :: <a>Traversal'</a> a a -&gt; a -&gt; [<a>Context</a> a a a]
--   </pre>
contextsOf :: ATraversal' a a -> a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using <a>plate</a>.
--   
--   <pre>
--   <a>contextsOn</a> b  <a>contextsOnOf</a> b <a>plate</a>
--   </pre>
--   
--   <pre>
--   <a>contextsOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using another user-supplied
--   <a>Traversal</a> to walk each layer.
--   
--   <pre>
--   <a>contextsOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]

-- | The one-level version of <a>context</a>. This extracts a list of the
--   immediate children as editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren x = <a>children</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holes</a> l x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holes</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holes</a> = <a>holesOf</a> <a>plate</a>
--   </pre>
holes :: Plated a => a -> [Pretext (->) a a a]

-- | An alias for <a>holesOf</a>, provided for consistency with the other
--   combinators.
--   
--   <pre>
--   <a>holesOn</a>  <a>holesOf</a>
--   </pre>
--   
--   <pre>
--   <a>holesOn</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOn</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOn :: Conjoined p => Optical p (->) (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | Extract one level of <a>holes</a> from a container in a region
--   specified by one <a>Traversal</a>, using another.
--   
--   <pre>
--   <a>holesOnOf</a> b l  <a>holesOf</a> (b <a>.</a> l)
--   </pre>
--   
--   <pre>
--   <a>holesOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>IndexedLens'</a> i a a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>IndexedTraversal'</a> i a a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Optical p (->) (Bazaar p r r) a b r r -> s -> [Pretext p r r t]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>para</a>  <a>paraOf</a> <a>plate</a>
--   </pre>
para :: Plated a => (a -> [r] -> r) -> a -> r

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>paraOf</a> :: <a>Fold</a> a a -&gt; (a -&gt; [r] -&gt; r) -&gt; a -&gt; r
--   </pre>
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r

-- | Compose through a plate
(...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b

-- | Try to apply a traversal to all transitive descendants of a
--   <a>Plated</a> container, but do not recurse through matching
--   descendants.
--   
--   <pre>
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Fold</a> s a                 -&gt; <a>Fold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedFold</a> s a          -&gt; <a>IndexedFold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Traversal</a> s s a b        -&gt; <a>Traversal</a> s s a b
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedTraversal</a> s s a b -&gt; <a>IndexedTraversal</a> s s a b
--   </pre>
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b

-- | Fold the immediate children of a <a>Plated</a> container.
--   
--   <pre>
--   <a>composOpFold</a> z c f = <a>foldrOf</a> <a>plate</a> (c <a>.</a> f) z
--   </pre>
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b

-- | The original <tt>uniplate</tt> combinator, implemented in terms of
--   <a>Plated</a> as a <a>Lens</a>.
--   
--   <pre>
--   <a>parts</a>  <a>partsOf</a> <a>plate</a>
--   </pre>
--   
--   The resulting <a>Lens</a> is safer to use as it ignores
--   'over-application' and deals gracefully with under-application, but it
--   is only a proper <a>Lens</a> if you don't change the list
--   <a>length</a>!
parts :: Plated a => Lens' a [a]

-- | Implement <a>plate</a> operation for a type using its <a>Generic</a>
--   instance.
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a
class GPlated a g
instance [overlap ok] GPlated a V1
instance [overlap ok] GPlated a U1
instance [overlap ok] GPlated a (K1 i b)
instance [overlap ok] GPlated a (K1 i a)
instance [overlap ok] (GPlated a f, GPlated a g) => GPlated a (f :*: g)
instance [overlap ok] (GPlated a f, GPlated a g) => GPlated a (f :+: g)
instance [overlap ok] GPlated a f => GPlated a (M1 i c f)
instance [overlap ok] Plated Pat
instance [overlap ok] Plated Stmt
instance [overlap ok] Plated Type
instance [overlap ok] Plated Con
instance [overlap ok] Plated Dec
instance [overlap ok] Plated Exp
instance [overlap ok] Plated (Tree a)
instance [overlap ok] Traversable f => Plated (Cofree f a)
instance [overlap ok] Traversable f => Plated (F f a)
instance [overlap ok] (Traversable f, Traversable m) => Plated (FreeT f m a)
instance [overlap ok] Traversable f => Plated (Free f a)
instance [overlap ok] Plated [a]


module Control.Lens.Equality

-- | A witness that <tt>(a ~ s, b ~ t)</tt>.
--   
--   Note: Composition with an <a>Equality</a> is index-preserving.
type Equality s t a b = forall p (f :: * -> *). p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Equality</a>.
type Equality' s a = Equality s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>Equality</a>.
type AnEquality s t a b = Identical a (Identity b) a (Identity b) -> Identical a (Identity b) s (Identity t)

-- | A <a>Simple</a> <a>AnEquality</a>.
type AnEquality' s a = AnEquality s s a a

-- | Extract a witness of type <a>Equality</a>.
runEq :: AnEquality s t a b -> Identical s t a b

-- | Substituting types with <a>Equality</a>.
substEq :: AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r

-- | We can use <a>Equality</a> to do substitution into anything.
mapEq :: AnEquality s t a b -> f s -> f a

-- | <a>Equality</a> is symmetric.
fromEq :: AnEquality s t a b -> Equality b a t s

-- | This is an adverb that can be used to modify many other <a>Lens</a>
--   combinators to make them require simple lenses, simple traversals,
--   simple prisms or simple isos as input.
simply :: (Optic' p f s a -> r) -> Optic' p f s a -> r

-- | Composition with this isomorphism is occasionally useful when your
--   <a>Lens</a>, <a>Traversal</a> or <a>Iso</a> has a constraint on an
--   unused argument to force that argument to agree with the type of a
--   used argument and avoid <tt>ScopedTypeVariables</tt> or other
--   ugliness.
simple :: Equality' a a

-- | Provides witness that <tt>(s ~ a, b ~ t)</tt> holds.
data Identical a b s t
Identical :: Identical a b a b


module Control.Lens.Iso

-- | Isomorphism families can be composed with another <a>Lens</a> using
--   (<tt>.</tt>) and <tt>id</tt>.
--   
--   Note: Composition with an <a>Iso</a> is index- and measure-
--   preserving.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>Iso</a>.
type AnIso s t a b = Exchange a b a (Identity b) -> Exchange a b s (Identity t)

-- | A <a>Simple</a> <a>AnIso</a>.
type AnIso' s a = AnIso s s a a

-- | Build a simple isomorphism from a pair of inverse functions.
--   
--   <pre>
--   <a>view</a> (<a>iso</a> f g)  f
--   <a>view</a> (<a>from</a> (<a>iso</a> f g))  g
--   <a>over</a> (<a>iso</a> f g) h  g <a>.</a> h <a>.</a> f
--   <a>over</a> (<a>from</a> (<a>iso</a> f g)) h  f <a>.</a> h <a>.</a> g
--   </pre>
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Invert an isomorphism.
--   
--   <pre>
--   <a>from</a> (<a>from</a> l)  l
--   </pre>
from :: AnIso s t a b -> Iso b a t s

-- | Convert from <a>AnIso</a> back to any <a>Iso</a>.
--   
--   This is useful when you need to store an isomorphism as a data type
--   inside a container and later reconstitute it as an overloaded
--   function.
--   
--   See <a>cloneLens</a> or <a>cloneTraversal</a> for more information on
--   why you might want to do this.
cloneIso :: AnIso s t a b -> Iso s t a b

-- | Extract the two functions, one from <tt>s -&gt; a</tt> and one from
--   <tt>b -&gt; t</tt> that characterize an <a>Iso</a>.
withIso :: AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | Based on <a>ala</a> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum) foldMap [1,2,3,4]
--   10
--   </pre>
au :: AnIso s t a b -> ((b -> t) -> e -> s) -> e -> a

-- | Based on <tt>ala'</tt> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   For a version you pass the name of the <tt>newtype</tt> constructor
--   to, see <a>alaf</a>.
--   
--   Mnemonically, the German <i>auf</i> plays a similar role to <i>
--   la</i>, and the combinator is <a>au</a> with an extra function
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; auf (_Unwrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
auf :: Profunctor p => AnIso s t a b -> (p r a -> e -> b) -> p r s -> e -> t

-- | The opposite of working <a>over</a> a <a>Setter</a> is working
--   <a>under</a> an isomorphism.
--   
--   <pre>
--   <a>under</a>  <a>over</a> <a>.</a> <a>from</a>
--   </pre>
--   
--   <pre>
--   <a>under</a> :: <a>Iso</a> s t a b -&gt; (t -&gt; s) -&gt; b -&gt; a
--   </pre>
under :: AnIso s t a b -> (t -> s) -> b -> a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | Composition with this isomorphism is occasionally useful when your
--   <a>Lens</a>, <a>Traversal</a> or <a>Iso</a> has a constraint on an
--   unused argument to force that argument to agree with the type of a
--   used argument and avoid <tt>ScopedTypeVariables</tt> or other
--   ugliness.
simple :: Equality' a a

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a>  <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 +~ 2
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 -~ 1
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" . non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" . non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . non Map.empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . non Map.empty . at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | <tt><a>non'</a> p</tt> generalizes <tt><a>non</a> (p # ())</tt> to
--   take any unit <a>Prism</a>
--   
--   This function generates an isomorphism between <tt><a>Maybe</a> (a |
--   <a>isn't</a> p a)</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.singleton "hello" Map.empty &amp; at "hello" . non' _Empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . non' _Empty . at "world" .~ Nothing
--   fromList []
--   </pre>
non' :: APrism' a () -> Iso' (Maybe a) a

-- | <tt><a>anon</a> a p</tt> generalizes <tt><a>non</a> a</tt> to take any
--   value and a predicate.
--   
--   This function assumes that <tt>p a</tt> holds <tt><a>True</a></tt> and
--   generates an isomorphism between <tt><a>Maybe</a> (a | <a>not</a> (p
--   a))</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . anon Map.empty Map.null . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . anon Map.empty Map.null . at "world" .~ Nothing
--   fromList []
--   </pre>
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a

-- | This isomorphism can be used to convert to or from an instance of
--   <a>Enum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; LT^.from enum
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 97^.enum :: Char
--   'a'
--   </pre>
--   
--   Note: this is only an isomorphism from the numeric range actually used
--   and it is a bit of a pleasant fiction, since there are questionable
--   <a>Enum</a> instances for <a>Double</a>, and <a>Float</a> that exist
--   solely for <tt>[1.0 .. 4.0]</tt> sugar and the instances for those and
--   <a>Integer</a> don't cover all values in their range.
enum :: Enum a => Iso' Int a

-- | The canonical isomorphism for currying and uncurrying a function.
--   
--   <pre>
--   <a>curried</a> = <a>iso</a> <a>curry</a> <a>uncurry</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (fst^.curried) 3 4
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view curried fst 3 4
--   3
--   </pre>
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)

-- | The canonical isomorphism for uncurrying and currying a function.
--   
--   <pre>
--   <a>uncurried</a> = <a>iso</a> <a>uncurry</a> <a>curry</a>
--   </pre>
--   
--   <pre>
--   <a>uncurried</a> = <a>from</a> <a>curried</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ((+)^.uncurried) (1,2)
--   3
--   </pre>
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)

-- | The isomorphism for flipping a function.
--   
--   <pre>
--   &gt;&gt;&gt; ((,)^.flipped) 1 2
--   (2,1)
--   </pre>
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')

-- | This class provides for symmetric bifunctors.
class Bifunctor p => Swapped p
swapped :: Swapped p => Iso (p a b) (p c d) (p b a) (p d c)

-- | Ad hoc conversion between "strict" and "lazy" versions of a structure,
--   such as <a>Text</a> or <a>ByteString</a>.
class Strict lazy strict | lazy -> strict, strict -> lazy
strict :: Strict lazy strict => Iso' lazy strict

-- | An <a>Iso</a> between the strict variant of a structure and its lazy
--   counterpart.
--   
--   <pre>
--   <a>lazy</a> = <a>from</a> <a>strict</a>
--   </pre>
--   
--   See <a>http://hackage.haskell.org/package/strict-base-types</a> for an
--   example use.
lazy :: Strict lazy strict => Iso' strict lazy

-- | This class provides a generalized notion of list reversal extended to
--   other containers.
class Reversing t
reversing :: Reversing t => t -> t

-- | An <a>Iso</a> between a list, <a>ByteString</a>, <a>Text</a> fragment,
--   etc. and its reversal.
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. reversed
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; reversed %~ ('d':)
--   "lived"
--   </pre>
reversed :: Reversing a => Iso' a a

-- | Given a function that is its own inverse, this gives you an <a>Iso</a>
--   using it in both directions.
--   
--   <pre>
--   <a>involuted</a>  <a>join</a> <a>iso</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. involuted reverse
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; involuted reverse %~ ('d':)
--   "lived"
--   </pre>
involuted :: (a -> a) -> Iso' a a

-- | This isomorphism can be used to inspect a <a>Traversal</a> to see how
--   it associates the structure and it can also be used to bake the
--   <a>Traversal</a> into a <a>Magma</a> so that you can traverse over it
--   multiple times.
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)

-- | This isomorphism can be used to inspect an <a>IndexedTraversal</a> to
--   see how it associates the structure and it can also be used to bake
--   the <a>IndexedTraversal</a> into a <a>Magma</a> so that you can
--   traverse over it multiple times with access to the original indices.
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)

-- | This provides a way to peek at the internal structure of a
--   <a>Traversal</a> or <a>IndexedTraversal</a>
data Magma i t b a

-- | Lift an <a>Iso</a> into a <a>Contravariant</a> functor.
--   
--   <pre>
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (f a) (f b) (f s) (f t)
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (f a) (f s)
--   </pre>
contramapping :: Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)
class Profunctor (p :: * -> * -> *)
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
lmap :: Profunctor p => (a -> b) -> p b c -> p a c
rmap :: Profunctor p => (b -> c) -> p a b -> p a c

-- | Lift two <a>Iso</a>s into both arguments of a <a>Profunctor</a>
--   simultaneously.
--   
--   <pre>
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p a s') (p b t') (p s a') (p t b')
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p a s') (p s a')
--   </pre>
dimapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')

-- | Lift an <a>Iso</a> contravariantly into the left argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p a x) (p b y) (p s x) (p t y)
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p a x) (p s x)
--   </pre>
lmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)

-- | Lift an <a>Iso</a> covariantly into the right argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
rmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)

-- | Lift two <a>Iso</a>s into both arguments of a <a>Bifunctor</a>.
--   
--   <pre>
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p s s') (p t t') (p a a') (p b b')
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p s s') (p a a')
--   </pre>
bimapping :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')
instance Strict (RWST r w s m a) (RWST r w s m a)
instance Strict (WriterT w m a) (WriterT w m a)
instance Strict (StateT s m a) (StateT s m a)
instance Strict Text Text
instance Strict ByteString ByteString
instance Swapped Either
instance Swapped (,)


-- | The <a>Wrapped</a> class provides similar functionality as
--   <tt>Control.Newtype</tt>, from the <tt>newtype</tt> package, but in a
--   more convenient and efficient form.
--   
--   There are a few functions from <tt>newtype</tt> that are not provided
--   here, because they can be done with the <a>Iso</a> directly:
--   
--   <pre>
--   Control.Newtype.over <a>Sum</a> f  <a>_Unwrapping</a> <a>Sum</a> <a>%~</a> f
--   Control.Newtype.under <a>Sum</a> f  <a>_Wrapping</a> <a>Sum</a> <a>%~</a> f
--   Control.Newtype.overF <a>Sum</a> f  <a>mapping</a> (<a>_Unwrapping</a> <a>Sum</a>) <a>%~</a> f
--   Control.Newtype.underF <a>Sum</a> f  <a>mapping</a> (<a>_Wrapping</a> <a>Sum</a>) <a>%~</a> f
--   </pre>
--   
--   <a>under</a> can also be used with <a>_Unwrapping</a> to provide the
--   equivalent of <tt>Control.Newtype.under</tt>. Also, most use cases
--   don't need full polymorphism, so only the single constructor
--   <a>_Wrapping</a> functions would be needed.
--   
--   These equivalences aren't 100% honest, because <tt>newtype</tt>'s
--   operators need to rely on two <tt>Newtype</tt> constraints. This means
--   that the wrapper used for the output is not necessarily the same as
--   the input.
module Control.Lens.Wrapped

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where type family Unwrapped s :: *
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s
class Wrapped s => Rewrapped (s :: *) (t :: *)
class (Rewrapped s t, Rewrapped t s) => Rewrapping s t

-- | Work under a newtype wrapper.
--   
--   <pre>
--   &gt;&gt;&gt; Const "hello" &amp; _Wrapped %~ Prelude.length &amp; getConst
--   5
--   </pre>
--   
--   <pre>
--   <a>_Wrapped</a>    <a>from</a> <a>_Unwrapped</a>
--   <a>_Unwrapped</a>  <a>from</a> <a>_Wrapped</a>
--   </pre>
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)

-- | This is a convenient version of <a>_Unwrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s

-- | Given the constructor for a <a>Wrapped</a> type, return a
--   deconstructor that is its inverse.
--   
--   Assuming the <a>Wrapped</a> instance is legal, these laws hold:
--   
--   <pre>
--   <a>op</a> f <a>.</a> f  <a>id</a>
--   f <a>.</a> <a>op</a> f  <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Identity (Identity 4)
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Const (Const "hello")
--   "hello"
--   </pre>
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s

-- | This combinator is based on <tt>ala</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [False,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [True,False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Product foldMap [1,2,3,4]
--   24
--   </pre>
ala :: Rewrapping s t => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s

-- | This combinator is based on <tt>ala'</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   &gt;&gt;&gt; alaf Sum foldMap Prelude.length ["hello","world"]
--   10
--   </pre>
alaf :: (Profunctor p, Rewrapping s t) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
instance Wrapped ErrorCall
instance t ~ ErrorCall => Rewrapped ErrorCall t
instance Wrapped RecUpdError
instance t ~ RecUpdError => Rewrapped RecUpdError t
instance Wrapped RecSelError
instance t ~ RecSelError => Rewrapped RecSelError t
instance Wrapped RecConError
instance t ~ RecConError => Rewrapped RecConError t
instance Wrapped PatternMatchFail
instance t ~ PatternMatchFail => Rewrapped PatternMatchFail t
instance Wrapped NoMethodError
instance t ~ NoMethodError => Rewrapped NoMethodError t
instance Wrapped AssertionFailed
instance t ~ AssertionFailed => Rewrapped AssertionFailed t
instance Wrapped (Tagged s a)
instance t ~ Tagged s' a' => Rewrapped (Tagged s a) t
instance Wrapped (ComposeCF f g a)
instance t ~ ComposeCF f' g' a' => Rewrapped (ComposeCF f g a) t
instance Wrapped (ComposeFC f g a)
instance t ~ ComposeFC f' g' a' => Rewrapped (ComposeFC f g a) t
instance Wrapped (Compose f g a)
instance t ~ Compose f' g' a' => Rewrapped (Compose f g a) t
instance Wrapped (Op a b)
instance t ~ Op a' b' => Rewrapped (Op a b) t
instance Wrapped (Equivalence a)
instance t ~ Equivalence b => Rewrapped (Equivalence a) t
instance Wrapped (Comparison a)
instance t ~ Comparison b => Rewrapped (Comparison a) t
instance Wrapped (Predicate a)
instance t ~ Predicate b => Rewrapped (Predicate a) t
instance Wrapped (Option a)
instance t ~ Option b => Rewrapped (Option a) t
instance Wrapped (WrappedMonoid a)
instance t ~ WrappedMonoid b => Rewrapped (WrappedMonoid a) t
instance Wrapped (Last a)
instance t ~ Last b => Rewrapped (Last a) t
instance Wrapped (First a)
instance t ~ First b => Rewrapped (First a) t
instance Wrapped (Max a)
instance t ~ Max b => Rewrapped (Max a) t
instance Wrapped (Min a)
instance t ~ Min b => Rewrapped (Min a) t
instance Storable a => Wrapped (Vector a)
instance (Storable a, t ~ Vector a') => Rewrapped (Vector a) t
instance Unbox a => Wrapped (Vector a)
instance (Unbox a, t ~ Vector a') => Rewrapped (Vector a) t
instance Prim a => Wrapped (Vector a)
instance (Prim a, t ~ Vector a') => Rewrapped (Vector a) t
instance Wrapped (Vector a)
instance t ~ Vector a' => Rewrapped (Vector a) t
instance Wrapped (Seq a)
instance t ~ Seq a' => Rewrapped (Seq a) t
instance Ord a => Wrapped (Set a)
instance (t ~ Set a', Ord a) => Rewrapped (Set a) t
instance Ord k => Wrapped (Map k a)
instance (t ~ Map k' a', Ord k) => Rewrapped (Map k a) t
instance Wrapped IntSet
instance t ~ IntSet => Rewrapped IntSet t
instance Wrapped (IntMap a)
instance t ~ IntMap a' => Rewrapped (IntMap a) t
instance (Hashable a, Eq a) => Wrapped (HashSet a)
instance (t ~ HashSet a', Hashable a, Eq a) => Rewrapped (HashSet a) t
instance (Hashable k, Eq k) => Wrapped (HashMap k a)
instance (t ~ HashMap k' a', Hashable k, Eq k) => Rewrapped (HashMap k a) t
instance Wrapped (TracedT m w a)
instance t ~ TracedT m' w' a' => Rewrapped (TracedT m w a) t
instance Wrapped (Coproduct f g a)
instance t ~ Coproduct f' g' a' => Rewrapped (Coproduct f g a) t
instance Wrapped (WriterT w m a)
instance t ~ WriterT w' m' a' => Rewrapped (WriterT w m a) t
instance Wrapped (WriterT w m a)
instance t ~ WriterT w' m' a' => Rewrapped (WriterT w m a) t
instance Wrapped (StateT s m a)
instance t ~ StateT s' m' a' => Rewrapped (StateT s m a) t
instance Wrapped (StateT s m a)
instance t ~ StateT s' m' a' => Rewrapped (StateT s m a) t
instance Wrapped (RWST r w s m a)
instance t ~ RWST r' w' s' m' a' => Rewrapped (RWST r w s m a) t
instance Wrapped (RWST r w s m a)
instance t ~ RWST r' w' s' m' a' => Rewrapped (RWST r w s m a) t
instance Wrapped (Reverse f a)
instance t ~ Reverse g b => Rewrapped (Reverse f a) t
instance Wrapped (ReaderT r m a)
instance t ~ ReaderT r n b => Rewrapped (ReaderT r m a) t
instance Wrapped (MaybeT m a)
instance t ~ MaybeT n b => Rewrapped (MaybeT m a) t
instance Wrapped (ListT m a)
instance t ~ ListT n b => Rewrapped (ListT m a) t
instance Wrapped (IdentityT m a)
instance t ~ IdentityT n b => Rewrapped (IdentityT m a) t
instance Wrapped (Identity a)
instance t ~ Identity b => Rewrapped (Identity a) t
instance Wrapped (ErrorT e m a)
instance t ~ ErrorT e' m' a' => Rewrapped (ErrorT e m a) t
instance Wrapped (ContT r m a)
instance t ~ ContT r' m' a' => Rewrapped (ContT r m a) t
instance Wrapped (Constant a b)
instance t ~ Constant a' b' => Rewrapped (Constant a b) t
instance Wrapped (Compose f g a)
instance t ~ Compose f' g' a' => Rewrapped (Compose f g a) t
instance Wrapped (Backwards f a)
instance t ~ Backwards g b => Rewrapped (Backwards f a) t
instance ArrowApply m => Wrapped (ArrowMonad m a)
instance (t ~ ArrowMonad m' a', ArrowApply m, ArrowApply m') => Rewrapped (ArrowMonad m a) t
instance Wrapped (Last a)
instance t ~ Last b => Rewrapped (Last a) t
instance Wrapped (First a)
instance t ~ First b => Rewrapped (First a) t
instance Wrapped (Endo a)
instance t ~ Endo b => Rewrapped (Endo b) t
instance Wrapped (Dual a)
instance t ~ Dual b => Rewrapped (Dual a) t
instance Wrapped (Const a x)
instance t ~ Const a' x' => Rewrapped (Const a x) t
instance Wrapped (NonEmpty a)
instance t ~ NonEmpty b => Rewrapped (NonEmpty a) t
instance Wrapped (ZipList a)
instance t ~ ZipList b => Rewrapped (ZipList a) t
instance Wrapped (WrappedArrow a b c)
instance t ~ WrappedArrow a' b' c' => Rewrapped (WrappedArrow a b c) t
instance Wrapped (WrappedMonad m a)
instance t ~ WrappedMonad m' a' => Rewrapped (WrappedMonad m a) t
instance Wrapped (Kleisli m a b)
instance t ~ Kleisli m' a' b' => Rewrapped (Kleisli m a b) t
instance Wrapped (Product a)
instance t ~ Product b => Rewrapped (Product a) t
instance Wrapped (Sum a)
instance t ~ Sum b => Rewrapped (Sum a) t
instance Wrapped Any
instance t ~ Any => Rewrapped Any t
instance Wrapped All
instance t ~ All => Rewrapped All t
instance (Rewrapped s t, Rewrapped t s) => Rewrapping s t


module Control.Lens.Empty
class AsEmpty a where _Empty = only mempty
_Empty :: AsEmpty a => Prism' a ()
instance AsEmpty Text
instance AsEmpty Text
instance AsEmpty ByteString
instance AsEmpty ByteString
instance AsEmpty (Seq a)
instance Storable a => AsEmpty (Vector a)
instance Unbox a => AsEmpty (Vector a)
instance AsEmpty (Vector a)
instance AsEmpty IntSet
instance AsEmpty (HashSet a)
instance AsEmpty (Set a)
instance AsEmpty (IntMap a)
instance AsEmpty (HashMap k a)
instance AsEmpty (Map k a)
instance AsEmpty [a]
instance (AsEmpty a, AsEmpty b, AsEmpty c) => AsEmpty (a, b, c)
instance (AsEmpty a, AsEmpty b) => AsEmpty (a, b)
instance AsEmpty a => AsEmpty (Dual a)
instance AsEmpty (First a)
instance AsEmpty (Last a)
instance AsEmpty (Maybe a)
instance (Eq a, Num a) => AsEmpty (Sum a)
instance (Eq a, Num a) => AsEmpty (Product a)
instance AsEmpty Event
instance AsEmpty All
instance AsEmpty Any
instance AsEmpty ()
instance AsEmpty Ordering


module Control.Lens.Each

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   Notably, when applied to a tuple, this generalizes <a>both</a> to
--   arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; each *~ 10
--   (10,20,30)
--   </pre>
--   
--   It can also be used on monomorphic containers like <a>Text</a> or
--   <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over each Char.toUpper ("hello"^.Text.packed)
--   "HELLO"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; each.each %~ Char.toUpper
--   ("HELLO","WORLD")
--   </pre>
class Each s t a b | s -> a, t -> b, s b -> t, t a -> s where each = traverse
each :: Each s t a b => Traversal s t a b
instance (Ix i, IArray UArray a, IArray UArray b, i ~ j) => Each (UArray i a) (UArray j b) a b
instance (Ix i, i ~ j) => Each (Array i a) (Array j b) a b
instance (a ~ Word8, b ~ Word8) => Each ByteString ByteString a b
instance (a ~ Word8, b ~ Word8) => Each ByteString ByteString a b
instance (a ~ Char, b ~ Char) => Each Text Text a b
instance (a ~ Char, b ~ Char) => Each Text Text a b
instance (Unbox a, Unbox b) => Each (Vector a) (Vector b) a b
instance (Storable a, Storable b) => Each (Vector a) (Vector b) a b
instance (Prim a, Prim b) => Each (Vector a) (Vector b) a b
instance Each (Vector a) (Vector b) a b
instance Each (Tree a) (Tree b) a b
instance Each (Seq a) (Seq b) a b
instance Each (Maybe a) (Maybe b) a b
instance Each (Identity a) (Identity b) a b
instance Each (NonEmpty a) (NonEmpty b) a b
instance Each [a] [b] a b
instance c ~ d => Each (HashMap c a) (HashMap d b) a b
instance Each (IntMap a) (IntMap b) a b
instance c ~ d => Each (Map c a) (Map d b) a b
instance Each (Complex a) (Complex b) a b
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, a ~ a9, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6, b ~ b7, b ~ b8, b ~ b9) => Each (a, a2, a3, a4, a5, a6, a7, a8, a9) (b, b2, b3, b4, b5, b6, b7, b8, b9) a b
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6, b ~ b7, b ~ b8) => Each (a, a2, a3, a4, a5, a6, a7, a8) (b, b2, b3, b4, b5, b6, b7, b8) a b
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6, b ~ b7) => Each (a, a2, a3, a4, a5, a6, a7) (b, b2, b3, b4, b5, b6, b7) a b
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, b ~ b2, b ~ b3, b ~ b4, b ~ b5, b ~ b6) => Each (a, a2, a3, a4, a5, a6) (b, b2, b3, b4, b5, b6) a b
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, b ~ b2, b ~ b3, b ~ b4, b ~ b5) => Each (a, a2, a3, a4, a5) (b, b2, b3, b4, b5) a b
instance (a ~ a2, a ~ a3, a ~ a4, b ~ b2, b ~ b3, b ~ b4) => Each (a, a2, a3, a4) (b, b2, b3, b4) a b
instance (a ~ a2, a ~ a3, b ~ b2, b ~ b3) => Each (a, a2, a3) (b, b2, b3) a b
instance (a ~ a', b ~ b') => Each (a, a') (b, b') a b


module Control.Lens.Cons

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList []
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList [b, c]
--   fromList [a,b,c]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons a []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [])
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [b, c])
--   fromList [a,b,c]
--   </pre>
cons :: Cons s s a a => a -> s -> s

-- | Attempt to extract the left-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [a, b, c]
--   Just (a,[b,c])
--   </pre>
uncons :: Cons s s a a => s -> Maybe (a, s)

-- | A <a>Traversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head .~ d
--   [d,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head %~ f
--   [f a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ f
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?!_head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
--   
--   This isn't limited to lists.
--   
--   For instance you can also <a>traverse</a> the head of a <a>Seq</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; _head %~ f
--   fromList [f a,b,c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   <a>_head</a> :: <a>Traversal'</a> [a] a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_head :: Cons s s a a => Traversal' s a

-- | A <a>Traversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _tail .~ [c,d,e]
--   [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d,e] &amp; _tail.traverse %~ f
--   [a,f b,f c,f d,f e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?_tail
--   Just [b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?!_tail
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._tail
--   "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._tail
--   ""
--   </pre>
--   
--   This isn't limited to lists. For instance you can also <a>traverse</a>
--   the tail of a <a>Seq</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b] &amp; _tail .~ Seq.fromList [c,d,e]
--   fromList [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^? _tail
--   Just (fromList [b,c])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _tail
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>_tail</a> :: <a>Traversal'</a> [a] [a]
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_tail :: Cons s s a a => Traversal' s s

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] |&gt; a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [b, c] |&gt; a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; LazyT.pack "hello" |&gt; '!'
--   "hello!"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList []) a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList [b, c]) a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (LazyT.pack "hello") '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "hello!")
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "")
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [b,c,a])
--   Just (fromList [b,c],a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [])
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | A <a>Traversal</a> reading and replacing all but the a last element of
--   a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d]^?_init
--   Just [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _init .~ [c,d,e]
--   [c,d,e,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d] &amp; _init.traverse %~ f
--   [f a,f b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?_init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^?!_init
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._init
--   "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._init
--   ""
--   </pre>
--   
--   <pre>
--   <a>_init</a> :: <a>Traversal'</a> [a] [a]
--   <a>_init</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_init</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_init :: Snoc s s a a => Traversal' s s

-- | A <a>Traversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?!_last
--   c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _last %~ f
--   [a,b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
--   
--   This <a>Traversal</a> is not limited to lists, however. We can also
--   work with other containers, such as a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" ^? _last
--   Just 'e'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.empty ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" &amp; _last .~ 'Q'
--   fromList "abcdQ"
--   </pre>
--   
--   <pre>
--   <a>_last</a> :: <a>Traversal'</a> [a] a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_last :: Snoc s s a a => Traversal' s a
instance Snoc Text Text Char Char
instance Snoc Text Text Char Char
instance Snoc ByteString ByteString Word8 Word8
instance Snoc ByteString ByteString Word8 Word8
instance (Unbox a, Unbox b) => Snoc (Vector a) (Vector b) a b
instance (Storable a, Storable b) => Snoc (Vector a) (Vector b) a b
instance (Prim a, Prim b) => Snoc (Vector a) (Vector b) a b
instance Snoc (Vector a) (Vector b) a b
instance Snoc (Seq a) (Seq b) a b
instance a ~ b => Snoc (NonEmpty a) (NonEmpty b) a b
instance Snoc [a] [b] a b
instance (Unbox a, Unbox b) => Cons (Vector a) (Vector b) a b
instance (Storable a, Storable b) => Cons (Vector a) (Vector b) a b
instance (Prim a, Prim b) => Cons (Vector a) (Vector b) a b
instance Cons (Vector a) (Vector b) a b
instance Cons Text Text Char Char
instance Cons Text Text Char Char
instance Cons ByteString ByteString Word8 Word8
instance Cons ByteString ByteString Word8 Word8
instance Cons (Seq a) (Seq b) a b
instance a ~ b => Cons (NonEmpty a) (NonEmpty b) a b
instance Cons [a] [b] a b


-- | This module is designed to be imported qualified.
module Control.Lens.Internal.Deque

-- | A Banker's deque based on Chris Okasaki's "Purely Functional Data
--   Structures"
data Deque a
BD :: !Int -> [a] -> !Int -> [a] -> Deque a

-- | <i>O(1)</i>. Calculate the size of a <a>Deque</a>
--   
--   <pre>
--   &gt;&gt;&gt; size (fromList [1,4,6])
--   3
--   </pre>
size :: Deque a -> Int

-- | <i>O(n)</i> amortized. Construct a <a>Deque</a> from a list of values.
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2]
--   BD 1 [1] 1 [2]
--   </pre>
fromList :: [a] -> Deque a

-- | <i>O(1)</i>. Determine if a <a>Deque</a> is <a>empty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; null empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (singleton 1)
--   False
--   </pre>
null :: Deque a -> Bool

-- | <i>O(1)</i>. Generate a singleton <a>Deque</a>
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   BD 1 [1] 0 []
--   </pre>
singleton :: a -> Deque a
instance Show a => Show (Deque a)
instance Snoc (Deque a) (Deque b) a b
instance Cons (Deque a) (Deque b) a b
instance Monoid (Deque a)
instance Semigroup (Deque a)
instance TraversableWithIndex Int Deque
instance Traversable Deque
instance FoldableWithIndex Int Deque
instance Foldable Deque
instance MonadPlus Deque
instance Monad Deque
instance Bind Deque
instance Reversing (Deque a)
instance Alternative Deque
instance Plus Deque
instance Alt Deque
instance Applicative Deque
instance Apply Deque
instance FunctorWithIndex Int Deque
instance Functor Deque
instance Ord a => Ord (Deque a)
instance Eq a => Eq (Deque a)


module Control.Lens.At

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k  <a>at</a> k <a>.</a> <a>traverse</a>
--   </pre>
class Ixed m => At m
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k .~ Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | This provides a common notion of a value at an index that is shared by
--   both <a>Ixed</a> and <a>At</a>.

-- | This simple <a>Traversal</a> lets you <a>traverse</a> the value at a
--   given key in a <a>Map</a> or element at an ordinal position in a list
--   or <a>Seq</a>.
class Ixed m
ix :: Ixed m => Index m -> Traversal' m (IxValue m)

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> Traversal' m (IxValue m)

-- | This class provides a simple <tt>IndexedFold</tt> (or
--   <a>IndexedTraversal</a>) that lets you view (and modify) information
--   about whether or not a container contains a given <a>Index</a>.
class Contains m
contains :: Contains m => Index m -> Lens' m Bool
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8, a ~ a9) => Ixed (a, a2, a3, a4, a5, a6, a7, a8, a9)
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7, a ~ a8) => Ixed (a, a2, a3, a4, a5, a6, a7, a8)
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6, a ~ a7) => Ixed (a, a2, a3, a4, a5, a6, a7)
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5, a ~ a6) => Ixed (a, a2, a3, a4, a5, a6)
instance (a ~ a2, a ~ a3, a ~ a4, a ~ a5) => Ixed (a, a2, a3, a4, a5)
instance (a ~ a2, a ~ a3, a ~ a4) => Ixed (a, a2, a3, a4)
instance (a ~ a2, a ~ a3) => Ixed (a, a2, a3)
instance a ~ a2 => Ixed (a, a2)
instance (Eq k, Hashable k) => At (HashSet k)
instance Ord k => At (Set k)
instance At IntSet
instance (Eq k, Hashable k) => At (HashMap k a)
instance Ord k => At (Map k a)
instance At (IntMap a)
instance At (Maybe a)
instance Ixed ByteString
instance Ixed ByteString
instance Ixed Text
instance Ixed Text
instance Unbox a => Ixed (Vector a)
instance Storable a => Ixed (Vector a)
instance Prim a => Ixed (Vector a)
instance Ixed (Vector a)
instance (IArray UArray e, Ix i) => Ixed (UArray i e)
instance Ix i => Ixed (Array i e)
instance (Eq k, Hashable k) => Ixed (HashSet k)
instance Ixed IntSet
instance Ord k => Ixed (Set k)
instance (Eq k, Hashable k) => Ixed (HashMap k a)
instance Ord k => Ixed (Map k a)
instance Ixed (IntMap a)
instance Ixed (Seq a)
instance Ixed (Tree a)
instance Ixed (Identity a)
instance Ixed (NonEmpty a)
instance Ixed [a]
instance Ixed (Maybe a)
instance Eq e => Ixed (e -> a)
instance (Eq a, Hashable a) => Contains (HashSet a)
instance Ord a => Contains (Set a)
instance Contains IntSet


-- | Lenses, Prisms, and Traversals for working with Template Haskell
module Language.Haskell.TH.Lens

-- | Has a <a>Name</a>
class HasName t
name :: HasName t => Lens' t Name

-- | Provides for the extraction of free type variables, and alpha
--   renaming.
class HasTypeVars t
typeVarsEx :: HasTypeVars t => Set Name -> Traversal' t Name

-- | Provides substitution for types
class SubstType t
substType :: SubstType t => Map Name Type -> t -> t

-- | Traverse <i>free</i> type variables
typeVars :: HasTypeVars t => Traversal' t Name

-- | Substitute using a map of names in for <i>free</i> type variables
substTypeVars :: HasTypeVars t => Map Name Name -> t -> t

-- | Provides a <a>Traversal</a> of the types of each field of a
--   constructor.
conFields :: Traversal' Con StrictType

-- | <a>Traversal</a> of the types of the <i>named</i> fields of a
--   constructor.
conNamedFields :: Traversal' Con VarStrictType
locFileName :: Lens' Loc String
locPackage :: Lens' Loc String
locModule :: Lens' Loc String
locStart :: Lens' Loc CharPos
locEnd :: Lens' Loc CharPos
funDepInputs :: Lens' FunDep [Name]
funDepOutputs :: Lens' FunDep [Name]
matchPattern :: Lens' Match Pat
matchBody :: Lens' Match Body
matchDeclarations :: Lens' Match [Dec]
fixityPrecedence :: Lens' Fixity Int
fixityDirection :: Lens' Fixity FixityDirection
clausePattern :: Lens' Clause [Pat]
clauseBody :: Lens' Clause Body
clauseDecs :: Lens' Clause [Dec]
fieldExpName :: Lens' FieldExp Name
fieldExpExpression :: Lens' FieldExp Exp
fieldPatName :: Lens' FieldPat Name
fieldPatPattern :: Lens' FieldPat Pat
tySynEqnPatterns :: Lens' TySynEqn [Type]
tySynEqnResult :: Lens' TySynEqn Type
_ClassI :: Prism' Info (Dec, [InstanceDec])
_ClassOpI :: Prism' Info (Name, Type, ParentName, Fixity)
_TyConI :: Prism' Info Dec
_FamilyI :: Prism' Info (Dec, [InstanceDec])
_PrimTyConI :: Prism' Info (Name, Arity, Unlifted)
_DataConI :: Prism' Info (Name, Type, ParentName, Fixity)
_VarI :: Prism' Info (Name, Type, Maybe Dec, Fixity)
_TyVarI :: Prism' Info (Name, Type)
_FunD :: Prism' Dec (Name, [Clause])
_ValD :: Prism' Dec (Pat, Body, [Dec])
_DataD :: Prism' Dec (Cxt, Name, [TyVarBndr], [Con], [Name])
_NewtypeD :: Prism' Dec (Cxt, Name, [TyVarBndr], Con, [Name])
_TySynD :: Prism' Dec (Name, [TyVarBndr], Type)
_ClassD :: Prism' Dec (Cxt, Name, [TyVarBndr], [FunDep], [Dec])
_InstanceD :: Prism' Dec (Cxt, Type, [Dec])
_SigD :: Prism' Dec (Name, Type)
_ForeignD :: Prism' Dec Foreign
_InfixD :: Prism' Dec (Fixity, Name)
_PragmaD :: Prism' Dec Pragma
_FamilyD :: Prism' Dec (FamFlavour, Name, [TyVarBndr], Maybe Kind)
_DataInstD :: Prism' Dec (Cxt, Name, [Type], [Con], [Name])
_NewtypeInstD :: Prism' Dec (Cxt, Name, [Type], Con, [Name])
_TySynInstD :: Prism' Dec (Name, TySynEqn)
_ClosedTypeFamilyD :: Prism' Dec (Name, [TyVarBndr], Maybe Kind, [TySynEqn])
_RoleAnnotD :: Prism' Dec (Name, [Role])
_NormalC :: Prism' Con (Name, [StrictType])
_RecC :: Prism' Con (Name, [VarStrictType])
_InfixC :: Prism' Con (StrictType, Name, StrictType)
_ForallC :: Prism' Con ([TyVarBndr], Cxt, Con)
_IsStrict :: Prism' Strict ()
_NotStrict :: Prism' Strict ()
_Unpacked :: Prism' Strict ()
_ImportF :: Prism' Foreign (Callconv, Safety, String, Name, Type)
_ExportF :: Prism' Foreign (Callconv, String, Name, Type)
_CCall :: Prism' Callconv ()
_StdCall :: Prism' Callconv ()
_Unsafe :: Prism' Safety ()
_Safe :: Prism' Safety ()
_Interruptible :: Prism' Safety ()
_InlineP :: Prism' Pragma (Name, Inline, RuleMatch, Phases)
_SpecialiseP :: Prism' Pragma (Name, Type, Maybe Inline, Phases)
_SpecialiseInstP :: Prism' Pragma Type
_RuleP :: Prism' Pragma (String, [RuleBndr], Exp, Exp, Phases)
_AnnP :: Prism' Pragma (AnnTarget, Exp)
_NoInline :: Prism' Inline ()
_Inline :: Prism' Inline ()
_Inlinable :: Prism' Inline ()
_ConLike :: Prism' RuleMatch ()
_FunLike :: Prism' RuleMatch ()
_AllPhases :: Prism' Phases ()
_FromPhase :: Prism' Phases Int
_BeforePhase :: Prism' Phases Int
_RuleVar :: Prism' RuleBndr Name
_TypedRuleVar :: Prism' RuleBndr (Name, Type)
_ModuleAnnotation :: Prism' AnnTarget ()
_TypeAnnotation :: Prism' AnnTarget Name
_ValueAnnotation :: Prism' AnnTarget Name
_FunDep :: Prism' FunDep ([Name], [Name])
_TypeFam :: Prism' FamFlavour ()
_DataFam :: Prism' FamFlavour ()
_InfixL :: Prism' FixityDirection ()
_InfixR :: Prism' FixityDirection ()
_InfixN :: Prism' FixityDirection ()
_VarE :: Prism' Exp Name
_ConE :: Prism' Exp Name
_LitE :: Prism' Exp Lit
_AppE :: Prism' Exp (Exp, Exp)
_InfixE :: Prism' Exp (Maybe Exp, Exp, Maybe Exp)
_UInfixE :: Prism' Exp (Exp, Exp, Exp)
_ParensE :: Prism' Exp Exp
_LamE :: Prism' Exp ([Pat], Exp)
_LamCaseE :: Prism' Exp [Match]
_TupE :: Prism' Exp [Exp]
_UnboxedTupE :: Prism' Exp [Exp]
_CondE :: Prism' Exp (Exp, Exp, Exp)
_MultiIfE :: Prism' Exp [(Guard, Exp)]
_LetE :: Prism' Exp ([Dec], Exp)
_CaseE :: Prism' Exp (Exp, [Match])
_DoE :: Prism' Exp [Stmt]
_CompE :: Prism' Exp [Stmt]
_ArithSeqE :: Prism' Exp Range
_ListE :: Prism' Exp [Exp]
_SigE :: Prism' Exp (Exp, Type)
_RecConE :: Prism' Exp (Name, [FieldExp])
_RecUpdE :: Prism' Exp (Exp, [FieldExp])
_GuardedB :: Prism' Body [(Guard, Exp)]
_NormalB :: Prism' Body Exp
_NormalG :: Prism' Guard Exp
_PatG :: Prism' Guard [Stmt]
_BindS :: Prism' Stmt (Pat, Exp)
_LetS :: Prism' Stmt [Dec]
_NoBindS :: Prism' Stmt Exp
_ParS :: Prism' Stmt [[Stmt]]
_FromR :: Prism' Range Exp
_FromThenR :: Prism' Range (Exp, Exp)
_FromToR :: Prism' Range (Exp, Exp)
_FromThenToR :: Prism' Range (Exp, Exp, Exp)
_CharL :: Prism' Lit Char
_StringL :: Prism' Lit String
_IntegerL :: Prism' Lit Integer
_RationalL :: Prism' Lit Rational
_IntPrimL :: Prism' Lit Integer
_WordPrimL :: Prism' Lit Integer
_FloatPrimL :: Prism' Lit Rational
_DoublePrimL :: Prism' Lit Rational
_StringPrimL :: Prism' Lit [Word8]
_LitP :: Prism' Pat Lit
_VarP :: Prism' Pat Name
_TupP :: Prism' Pat [Pat]
_UnboxedTupP :: Prism' Pat [Pat]
_ConP :: Prism' Pat (Name, [Pat])
_InfixP :: Prism' Pat (Pat, Name, Pat)
_UInfixP :: Prism' Pat (Pat, Name, Pat)
_ParensP :: Prism' Pat Pat
_TildeP :: Prism' Pat Pat
_BangP :: Prism' Pat Pat
_AsP :: Prism' Pat (Name, Pat)
_WildP :: Prism' Pat ()
_RecP :: Prism' Pat (Name, [FieldPat])
_ListP :: Prism' Pat [Pat]
_SigP :: Prism' Pat (Pat, Type)
_ViewP :: Prism' Pat (Exp, Pat)
_ForallT :: Prism' Type ([TyVarBndr], Cxt, Type)
_AppT :: Prism' Type (Type, Type)
_SigT :: Prism' Type (Type, Kind)
_VarT :: Prism' Type Name
_ConT :: Prism' Type Name
_PromotedT :: Prism' Type Name
_TupleT :: Prism' Type Int
_UnboxedTupleT :: Prism' Type Int
_ArrowT :: Prism' Type ()
_ListT :: Prism' Type ()
_PromotedTupleT :: Prism' Type Int
_PromotedNilT :: Prism' Type ()
_PromotedConsT :: Prism' Type ()
_StarT :: Prism' Type ()
_ConstraintT :: Prism' Type ()
_LitT :: Prism' Type TyLit
_PlainTV :: Prism' TyVarBndr Name
_KindedTV :: Prism' TyVarBndr (Name, Kind)
_NumTyLit :: Prism' TyLit Integer
_StrTyLit :: Prism' TyLit String
_ClassP :: Prism' Pred (Name, [Type])
_EqualP :: Prism' Pred (Type, Type)
_NominalR :: Prism' Role ()
_RepresentationalR :: Prism' Role ()
instance SubstType Pred
instance SubstType t => SubstType [t]
instance SubstType Type
instance HasTypeVars t => HasTypeVars (Maybe t)
instance HasTypeVars t => HasTypeVars [t]
instance HasTypeVars Con
instance HasTypeVars Pred
instance HasTypeVars Type
instance HasTypeVars Name
instance HasTypeVars TyVarBndr
instance HasName Con
instance HasName Name
instance HasName TyVarBndr


module Control.Lens.Internal.FieldTH
data LensRules
LensRules :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> (Name -> [Name] -> Name -> [DefName]) -> (Name -> Maybe (Name, Name)) -> LensRules
_simpleLenses :: LensRules -> Bool
_generateSigs :: LensRules -> Bool
_generateClasses :: LensRules -> Bool
_allowIsos :: LensRules -> Bool

-- | Allow Lens<i>Traversal (otherwise Getter</i>Fold)
_allowUpdates :: LensRules -> Bool
_lazyPatterns :: LensRules -> Bool

-- | Type Name -&gt; Field Names -&gt; Target Field Name -&gt; Definition
--   Names
_fieldToDef :: LensRules -> Name -> [Name] -> Name -> [DefName]
_classyLenses :: LensRules -> Name -> Maybe (Name, Name)

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definiton name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | Compute the field optics for the type identified by the given type
--   name. Lenses will be computed when possible, Traversals otherwise.
makeFieldOptics :: LensRules -> Name -> DecsQ
makeFieldOpticsForDec :: LensRules -> Dec -> DecsQ
instance Show DefName
instance Eq DefName
instance Ord DefName


module Control.Lens.Internal.PrismTH

-- | Generate a <tt>Prism</tt> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz . _Foo
--     _Bar = _FooBarBaz . _Bar
--     _Baz = _FooBarBaz . _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
makeClassyPrisms :: Name -> DecsQ

-- | Generate prisms for the given <a>Dec</a>
makeDecPrisms :: Bool -> Dec -> DecsQ
instance Eq NCon
instance HasTypeVars NCon


module Control.Lens.TH

-- | Build lenses (and traversals) with a sensible default configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBar
--     = Foo { _x, _y :: <a>Int</a> }
--     | Bar { _x :: <a>Int</a> }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   will create
--   
--   <pre>
--   x :: <a>Lens'</a> FooBar <a>Int</a>
--   x f (Foo a b) = (\a' -&gt; Foo a' b) &lt;$&gt; f a
--   x f (Bar a)   = Bar &lt;$&gt; f a
--   y :: <a>Traversal'</a> FooBar <a>Int</a>
--   y f (Foo a b) = (\b' -&gt; Foo a  b') &lt;$&gt; f b
--   y _ c@(Bar _) = pure c
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ

-- | Derive lenses and traversals, specifying explicit pairings of
--   <tt>(fieldName, lensName)</tt>.
--   
--   If you map multiple names to the same label, and it is present in the
--   same constructor then this will generate a <a>Traversal</a>.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   <a>makeLensesFor</a> [("_foo", "fooLens"), ("baz", "lbaz")] ''Foo
--   <a>makeLensesFor</a> [("_barX", "bar"), ("_barY", "bar")] ''Bar
--   </pre>
makeLensesFor :: [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Foo = Foo { _fooX, _fooY :: <a>Int</a> }
--   <a>makeClassy</a> ''Foo
--   </pre>
--   
--   will create
--   
--   <pre>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--     fooX :: <a>Lens'</a> t <a>Int</a>
--     fooX = foo . go where go f (Foo x y) = (\x' -&gt; Foo x' y) &lt;$&gt; f x
--     fooY :: <a>Lens'</a> t <a>Int</a>
--     fooY = foo . go where go f (Foo x y) = (\y' -&gt; Foo x y') &lt;$&gt; f y
--   instance HasFoo Foo where
--     foo = id
--   </pre>
--   
--   <pre>
--   <a>makeClassy</a> = <a>makeLensesWith</a> <a>classyRules</a>
--   </pre>
makeClassy :: Name -> DecsQ

-- | Derive lenses and traversals, using a named wrapper class, and
--   specifying explicit pairings of <tt>(fieldName, traversalName)</tt>.
--   
--   Example usage:
--   
--   <pre>
--   <a>makeClassyFor</a> "HasFoo" "foo" [("_foo", "fooLens"), ("bar", "lbar")] ''Foo
--   </pre>
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments. Works the same as <a>makeClassy</a> except that
--   (a) it expects that record field names do not begin with an
--   underscore, (b) all record fields are made into lenses, and (c) the
--   resulting lens is prefixed with an underscore.
makeClassy_ :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz . _Foo
--     _Bar = _FooBarBaz . _Bar
--     _Baz = _FooBarBaz . _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
makeClassyPrisms :: Name -> DecsQ

-- | Build <tt>Wrapped</tt> instance for a given newtype
makeWrapped :: Name -> DecsQ

-- | Generate overloaded field accessors.
--   
--   <i>e.g</i>
--   
--   <pre>
--   data Foo a = Foo { _fooX :: <a>Int</a>, _fooY : a }
--   newtype Bar = Bar { _barX :: <a>Char</a> }
--   makeFields ''Foo
--   makeFields ''Bar
--   </pre>
--   
--   will create
--   
--   <pre>
--   _fooXLens :: Lens' (Foo a) Int
--   _fooYLens :: Lens (Foo a) (Foo b) a b
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   instance HasX (Foo a) Int where
--     x = _fooXLens
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   instance HasY (Foo a) a where
--     y = _fooYLens
--   _barXLens :: Iso' Bar Char
--   instance HasX Bar Char where
--     x = _barXLens
--   </pre>
--   
--   For details, see <a>camelCaseFields</a>.
--   
--   <pre>
--   makeFields = <a>makeLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
makeFields :: Name -> DecsQ

-- | Make lenses for all records in the given declaration quote. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareLenses [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   fooX, fooY :: <a>Lens'</a> Foo Int
--   </pre>
declareLenses :: DecsQ -> DecsQ

-- | Similar to <a>makeLensesFor</a>, but takes a declaration quote.
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ

-- | For each record in the declaration quote, make lenses and traversals
--   for it, and create a class when the type has no arguments. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareClassy [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--   instance HasFoo Foo where foo = <a>id</a>
--   fooX, fooY :: HasFoo t =&gt; <a>Lens'</a> t <a>Int</a>
--   </pre>
declareClassy :: DecsQ -> DecsQ

-- | Similar to <a>makeClassyFor</a>, but takes a declaration quote.
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of each data type.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declarePrisms [d|
--     data Exp = Lit Int | Var String | Lambda{ bound::String, body::Exp }
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Exp = Lit Int | Var String | Lambda { bound::String, body::Exp }
--   _Lit :: <tt>Prism'</tt> Exp Int
--   _Var :: <tt>Prism'</tt> Exp String
--   _Lambda :: <tt>Prism'</tt> Exp (String, Exp)
--   </pre>
declarePrisms :: DecsQ -> DecsQ

-- | Build <tt>Wrapped</tt> instance for each newtype.
declareWrapped :: DecsQ -> DecsQ

-- | <pre>
--   declareFields = <a>declareLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
declareFields :: DecsQ -> DecsQ

-- | Build lenses with a custom configuration.
makeLensesWith :: LensRules -> Name -> DecsQ

-- | Declare lenses for each records in the given declarations, using the
--   specified <a>LensRules</a>. Any record syntax in the input will be
--   stripped off.
declareLensesWith :: LensRules -> DecsQ -> DecsQ
defaultFieldRules :: LensRules

-- | Field rules for fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   <b>Note</b>: The <tt>prefix</tt> must be the same as the typename
--   (with the first letter lowercased). This is a change from lens
--   versions before lens 4.5. If you want the old behaviour, use
--   <a>makeLensesWith</a> <a>abbreviatedFields</a>
camelCaseFields :: LensRules

-- | Field rules for fields in the form <tt> _prefix_fieldname </tt>
underscoreFields :: LensRules

-- | Field rules fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   Note that <tt>prefix</tt> may be any string of characters that are not
--   uppercase letters. (In particular, it may be arbitrary string of
--   lowercase letters and numbers) This is the behavior that
--   <a>defaultFieldRules</a> had in lens 4.4 and earlier.
abbreviatedFields :: LensRules
data LensRules

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definiton name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | Rules for making fairly simple partial lenses, ignoring the special
--   cases for isomorphisms and traversals, and not making any classes.
lensRules :: LensRules

-- | Construct a <a>LensRules</a> value for generating top-level
--   definitions using the given map from field names to definition names.
lensRulesFor :: [(String, String)] -> LensRules

-- | Rules for making lenses and traversals that precompose another
--   <a>Lens</a>.
classyRules :: LensRules
classyRules_ :: LensRules

-- | <a>Lens'</a> to access the convention for naming fields in our
--   <a>LensRules</a>.
--   
--   Defaults to stripping the _ off of the field name, lowercasing the
--   name, and skipping the field if it doesn't start with an '_'. The
--   field naming rule provides the names of all fields in the type as well
--   as the current field. This extra generality enables field naming
--   conventions that depend on the full set of names in a type.
--   
--   The field naming rule has access to the type name, the names of all
--   the field of that type (including the field being named), and the name
--   of the field being named.
--   
--   TypeName -&gt; FieldNames -&gt; FieldName -&gt; DefinitionNames
lensField :: Lens' LensRules (Name -> [Name] -> Name -> [DefName])

-- | Retrieve options such as the name of the class and method to put in it
--   to build a class around monomorphic data types. <a>Classy</a> lenses
--   are generated when this naming convention is provided. TypeName -&gt;
--   Maybe (ClassName, MainMethodName)
lensClass :: Lens' LensRules (Name -> Maybe (Name, Name))

-- | Generate "simple" optics even when type-changing optics are possible.
--   (e.g. <a>Lens'</a> instead of <a>Lens</a>)
simpleLenses :: Lens' LensRules Bool

-- | Create the class if the constructor is <a>Simple</a> and the
--   <a>lensClass</a> rule matches.
createClass :: Lens' LensRules Bool

-- | Indicate whether or not to supply the signatures for the generated
--   lenses.
--   
--   Disabling this can be useful if you want to provide a more restricted
--   type signature or if you want to supply hand-written haddocks.
generateSignatures :: Lens' LensRules Bool

-- | Generate "updateable" optics when <a>True</a>. When <a>False</a>,
--   <a>Fold</a>s will be generated instead of <a>Traversal</a>s and
--   <a>Getter</a>s will be generated instead of <a>Lens</a>es. This mode
--   is intended to be used for types with invariants which must be
--   maintained by "smart" constructors.
generateUpdateableOptics :: Lens' LensRules Bool

-- | Generate optics using lazy pattern matches. This can allow fields of
--   an undefined value to be initialized with lenses:
--   
--   <pre>
--   data Foo = Foo {_x :: Int, _y :: Bool}
--     deriving Show
--   
--   <a>makeLensesWith</a> (<a>lensRules</a> &amp; <a>generateLazyPatterns</a> .~ True) ''Foo
--   </pre>
--   
--   <pre>
--   &gt; undefined &amp; x .~ 8 &amp; y .~ True
--   Foo {_x = 8, _y = True}
--   </pre>
--   
--   The downside of this flag is that it can lead to space-leaks and
--   code-size/compile-time increases when generated for large records. By
--   default this flag is turned off, and strict optics are generated.
--   
--   When using lazy optics the strict optic can be recovered by composing
--   with <a>$!</a>:
--   
--   <pre>
--   strictOptic = ($!) . lazyOptic
--   </pre>
generateLazyPatterns :: Lens' LensRules Bool


-- | This module uses dirty tricks to generate a <a>Handler</a> from an
--   arbitrary <a>Fold</a>.
module Control.Lens.Internal.Exception

-- | Both <tt>exceptions</tt> and <a>Control.Exception</a> provide a
--   <a>Handler</a> type.
--   
--   This lets us write combinators to build handlers that are agnostic
--   about the choice of which of these they use.
class Handleable e (m :: * -> *) (h :: * -> *) | h -> e m where handler_ l = handler l . const
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r

-- | There was an <a>Exception</a> caused by abusing the internals of a
--   <a>Handler</a>.
data HandlingException
HandlingException :: HandlingException
instance Typeable HandlingException
instance Typeable Handling
instance Show HandlingException
instance (Reifies s (SomeException -> Maybe a), Typeable (Handling a s m)) => Exception (Handling a s m)
instance Show (Handling a s m)
instance Exception HandlingException
instance Typeable m => Handleable SomeException m (Handler m)
instance Handleable SomeException IO Handler


-- | These are some of the explicit <a>Functor</a> instances that leak into
--   the type signatures of <tt>Control.Lens</tt>. You shouldn't need to
--   import this module directly for most use-cases.
module Control.Lens.Internal


-- | Usage:
--   
--   You can derive lenses automatically for many data types:
--   
--   <pre>
--   import Control.Lens
--   
--   data FooBar a
--     = Foo { _x :: [<a>Int</a>], _y :: a }
--     | Bar { _x :: [<a>Int</a>] }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   This defines the following lenses:
--   
--   <pre>
--   x :: <a>Lens'</a> (FooBar a) [<a>Int</a>]
--   y :: <a>Traversal</a> (FooBar a) (FooBar b) a b
--   </pre>
--   
--   You can then access the value of <tt>_x</tt> with (<a>^.</a>), the
--   value of <tt>_y</tt>  with (<a>^?</a>) or (<a>^?!</a>) (since it can
--   fail), set the values with (<a>.~</a>), modify them with (<a>%~</a>),
--   and use almost any other combinator that is re-exported here on those
--   fields.
--   
--   The combinators here have unusually specific type signatures, so for
--   particularly tricky ones, the simpler type signatures you might want
--   to pretend the combinators have are specified as well.
--   
--   More information on how to use lenses is available on the lens wiki:
--   
--   <a>http://github.com/ekmett/lens/wiki</a>
--   
module Control.Lens


-- | This lets the subset of users who vociferously disagree about the full
--   scope and set of operators that should be exported from lens to not
--   have to look at any operator with which they disagree.
--   
--   <pre>
--   import Control.Lens.Combinators
--   </pre>
module Control.Lens.Combinators


-- | A few extra names that didn't make it into Control.Lens.
module Control.Lens.Extras

-- | Check to see if this <a>Prism</a> matches.
--   
--   <pre>
--   &gt;&gt;&gt; is _Left (Right 12)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; is hex "3f79"
--   True
--   </pre>
is :: APrism s t a b -> s -> Bool


-- | This module spends a lot of time fiddling around with
--   <a>ByteString</a> internals to work around
--   <a>http://hackage.haskell.org/trac/ghc/ticket/7556</a> on older
--   Haskell Platforms and to improve constant and asymptotic factors in
--   our performance.
module Control.Lens.Internal.ByteString

-- | Unpack a strict <a>Bytestring</a>
unpackStrict :: ByteString -> [Word8]

-- | Traverse a strict <a>ByteString</a> in a relatively balanced fashion,
--   as a balanced tree with biased runs of elements at the leaves.
traversedStrictTree :: IndexedTraversal' Int ByteString Word8

-- | Unpack a strict <a>Bytestring</a>, pretending the bytes are chars.
unpackStrict8 :: ByteString -> String

-- | Traverse a strict <a>ByteString</a> in a relatively balanced fashion,
--   as a balanced tree with biased runs of elements at the leaves,
--   pretending the bytes are chars.
traversedStrictTree8 :: IndexedTraversal' Int ByteString Char

-- | Unpack a lazy <tt>Bytestring</tt>
unpackLazy :: ByteString -> [Word8]

-- | An <a>IndexedTraversal</a> of the individual bytes in a lazy
--   <a>ByteString</a>
traversedLazy :: IndexedTraversal' Int64 ByteString Word8

-- | Unpack a lazy <a>ByteString</a> pretending the bytes are chars.
unpackLazy8 :: ByteString -> String

-- | An <a>IndexedTraversal</a> of the individual bytes in a lazy
--   <a>ByteString</a> pretending the bytes are chars.
traversedLazy8 :: IndexedTraversal' Int64 ByteString Char


-- | This module exists for users who like to work with qualified imports
--   but want access to the operators from Lens.
--   
--   <pre>
--   import qualified Control.Lens as L
--   import Control.Lens.Operators
--   </pre>
module Control.Lens.Operators

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList []
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList [b, c]
--   fromList [a,b,c]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] |&gt; a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [b, c] |&gt; a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; LazyT.pack "hello" |&gt; '!'
--   "hello!"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs  xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>)  <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Fold</a> s a       -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; [a]
--   (<a>^..</a>) :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   <pre>
--   (<a>^?</a>)  <a>flip</a> <a>preview</a>
--   </pre>
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a

-- | Perform an *UNSAFE* <a>head</a> of a <a>Fold</a> or <a>Traversal</a>
--   assuming that it is there.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?! _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^?! ix 3
--   'l'
--   </pre>
--   
--   <pre>
--   (<a>^?!</a>) :: s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Fold</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; a
--   </pre>
(^?!) :: s -> Getting (Endo a) s a -> a

-- | An infix version of <a>itoListOf</a>.
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]

-- | Perform a safe <a>head</a> (with index) of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> or retrieve <a>Just</a> the index and result
--   from an <a>IndexedGetter</a> or <a>IndexedLens</a>.
--   
--   When using a <a>IndexedTraversal</a> as a partial <a>IndexedLens</a>,
--   or an <a>IndexedFold</a> as a partial <a>IndexedGetter</a> this can be
--   a convenient way to extract the optional value.
--   
--   <pre>
--   (<a>^@?</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; <a>Maybe</a> (i, a)
--   </pre>
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)

-- | Perform an *UNSAFE* <a>head</a> (with index) of an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> assuming that it is there.
--   
--   <pre>
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; (i, a)
--   </pre>
(^@?!) :: s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a

-- | View the index and value of an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>.
--   
--   This is the same operation as <a>iview</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   (<a>^@.</a>) :: s -&gt; <a>IndexedGetter</a> i s a -&gt; (i, a)
--   (<a>^@.</a>) :: s -&gt; <a>IndexedLens'</a> i s a  -&gt; (i, a)
--   </pre>
--   
--   The result probably doesn't have much meaning when applied to an
--   <a>IndexedFold</a>.
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)

-- | Compose an <a>Indexed</a> function with a non-indexed function.
--   
--   Mnemonically, the <tt>&lt;</tt> points to the indexing we want to
--   preserve.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.itraversed).withIndex
--   [(1,"one,ten"),(1,"one,twenty"),(2,"two,thirty"),(2,"two,forty")]
--   </pre>
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r

-- | Compose a non-indexed function with an <a>Indexed</a> function.
--   
--   Mnemonically, the <tt>&gt;</tt> points to the indexing we want to
--   preserve.
--   
--   This is the same as <tt>(<a>.</a>)</tt>.
--   
--   <tt>f <a>.</a> g</tt> (and <tt>f <a>.&gt;</a> g</tt>) gives you the
--   index of <tt>g</tt> unless <tt>g</tt> is index-preserving, like a
--   <a>Prism</a>, <a>Iso</a> or <a>Equality</a>, in which case it'll pass
--   through the index of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed.&gt;itraversed).withIndex
--   [(10,"one,ten"),(20,"one,twenty"),(30,"two,thirty"),(40,"two,forty")]
--   </pre>
(.>) :: (st -> r) -> (kab -> st) -> kab -> r

-- | Composition of <a>Indexed</a> functions.
--   
--   Mnemonically, the <tt>&lt;</tt> and <tt>&gt;</tt> points to the fact
--   that we want to preserve the indices.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.&gt;itraversed).withIndex
--   [((1,10),"one,ten"),((1,20),"one,twenty"),((2,30),"two,thirty"),((2,40),"two,forty")]
--   </pre>
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r

-- | (<a>%%~</a>) can be used in one of two scenarios:
--   
--   When applied to a <a>Lens</a>, it can edit the target of the
--   <a>Lens</a> in a structure, extracting a functorial result.
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting an applicative summary of its actions.
--   
--   For all that the definition of this combinator is just:
--   
--   <pre>
--   (<a>%%~</a>)  <a>id</a>
--   </pre>
--   
--   It may be beneficial to think about it as if it had these even more
--   restricted types, however:
--   
--   <pre>
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Iso</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Lens</a> s t a b      -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting a supplemental monoidal summary of its actions,
--   by choosing <tt>f = ((,) m)</tt>
--   
--   <pre>
--   (<a>%%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) :: <a>Monoid</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; (m, b)) -&gt; s -&gt; (m, t)
--   </pre>
(%%~) :: Optical p q f s t a b -> p a (f b) -> q s (f t)

-- | Modify the target of a <a>Lens</a> in the current state returning some
--   extra information of type <tt>r</tt> or modify all targets of a
--   <a>Traversal</a> in the current state, extracting extra information of
--   type <tt>r</tt> and return a monoidal summary of the changes.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 %%= \x -&gt; (f x, g x)) (a,b)
--   (f a,(g a,b))
--   </pre>
--   
--   <pre>
--   (<a>%%=</a>)  (<a>state</a> <a>.</a>)
--   </pre>
--   
--   It may be useful to think of (<a>%%=</a>), instead, as having either
--   of the following more restricted type signatures:
--   
--   <pre>
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; (r, b)) -&gt; m r
--   </pre>
(%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r

-- | Passes the result of the left side to the function on the right side
--   (forward pipe operator).
--   
--   This is the flipped version of (<a>$</a>), which is more common in
--   languages like F# as (<tt>|&gt;</tt>) where it is needed for
--   inference. Here it is supplied for notational convenience and given a
--   precedence that allows it to be nested inside uses of (<a>$</a>).
--   
--   <pre>
--   &gt;&gt;&gt; a &amp; f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &amp; length &amp; succ
--   6
--   </pre>
--   
--   This combinator is commonly used when applying multiple <a>Lens</a>
--   operations in sequence.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _1.element 0 .~ 'j' &amp; _1.element 4 .~ 'y'
--   ("jelly","world")
--   </pre>
--   
--   This reads somewhat similar to:
--   
--   <pre>
--   &gt;&gt;&gt; flip execState ("hello","world") $ do _1.element 0 .= 'j'; _1.element 4 .= 'y'
--   ("jelly","world")
--   </pre>
(&) :: a -> (a -> b) -> b

-- | This can be used to chain lens operations using <tt>op=</tt> syntax
--   rather than <tt>op~</tt> syntax for simple non-type-changing cases.
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ 30 &amp; _2 .~ 40
--   (30,40)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp;~ do _1 .= 30; _2 .= 40
--   (30,40)
--   </pre>
--   
--   This does not support type-changing assignment, <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ "hello"
--   ("hello",20)
--   </pre>
(&~) :: s -> State s a -> s

-- | Infix flipped <a>fmap</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b

-- | This is convenient to <a>flip</a> argument order of composite
--   functions.
--   
--   <pre>
--   &gt;&gt;&gt; over _2 ?? ("hello","world") $ length
--   ("hello",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over ?? length ?? ("hello","world") $ _2
--   ("hello",5)
--   </pre>
(??) :: Functor f => f (a -> b) -> a -> f b

-- | Modify the target of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the addition, (<a>%~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) :: <a>Monoid</a> b =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%~) :: Profunctor p => Optical p q ((,) b) s t a b -> p a b -> q s (b, t)

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the addition, (<a>+~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<+~) :: Num a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the subtraction, (<a>-~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<-~) :: Num a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the multiplication, (<a>*~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<*~) :: Num a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Divide the target of a fractionally valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the division, (<a>//~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<//~) :: Fractional a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^~) :: (Num a, Integral e) => Optical (->) q ((,) a) s t a a -> e -> q s (a, t)

-- | Raise the target of a fractionally valued <a>Lens</a> to an
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^^~) :: (Fractional a, Integral e) => Optical (->) q ((,) a) s t a a -> e -> q s (a, t)

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<**~) :: Floating a => Optical (->) q ((,) a) s t a a -> a -> q s (a, t)

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>||~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<||~) :: Optical (->) q ((,) Bool) s t Bool Bool -> Bool -> q s (Bool, t)

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;~</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<&&~) :: Optical (->) q ((,) Bool) s t Bool Bool -> Bool -> q s (Bool, t)

-- | Modify the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>%~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%~) :: Strong p => Optical p q ((,) a) s t a b -> p a b -> q s (a, t)

-- | Replace the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>.~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.~</a>) ::             <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) ::             <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<.~) :: Optical (->) q ((,) a) s t a b -> b -> q s (a, t)

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>+~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;+~ c
--   (a,(a + c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;+~ c
--   (b,(a,b + c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<+~) :: Num a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;-~ c
--   (a,(a - c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;-~ c
--   (b,(a,b - c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<-~) :: Num a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;*~ c
--   (a,(a * c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;*~ c
--   (b,(a,b * c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<*~) :: Num a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Divide the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>//~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;//~ c
--   (a,(a / c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 &lt;&lt;//~ 2
--   (10.0,("Hawaii",5.0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<//~) :: Fractional a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<<^~) :: (Num a, Integral e) => Optical' (->) q ((,) a) s a -> e -> q s (a, s)

-- | Raise the target of a fractionally valued <a>Lens</a> to an integral
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; S -&gt; (a, s)
--   </pre>
(<<^^~) :: (Fractional a, Integral e) => Optical' (->) q ((,) a) s a -> e -> q s (a, s)

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the old value.
--   
--   When you do not need the old value, (<a>**~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;**~ c
--   (a,(a**c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;**~ c
--   (b,(a,b**c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<**~) :: Floating a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Logically <a>||</a> the target of a <a>Bool</a>-valued <a>Lens</a> and
--   return the old value.
--   
--   When you do not need the old value, (<a>||~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;||~ True
--   (False,(True,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;||~ False
--   (True,("hello",True))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<<||~) :: Optical' (->) q ((,) Bool) s Bool -> Bool -> q s (Bool, s)

-- | Logically <a>&amp;&amp;</a> the target of a <a>Bool</a>-valued
--   <a>Lens</a> and return the old value.
--   
--   When you do not need the old value, (<a>&amp;&amp;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;&amp;&amp;~ True
--   (False,(False,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;&amp;&amp;~ False
--   (True,("hello",False))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   </pre>
(<<&&~) :: Optical' (->) q ((,) Bool) s Bool -> Bool -> q s (Bool, s)

-- | Modify the target of a monoidally valued <a>Lens</a> by
--   <a>mappend</a>ing a new value and return the old value.
--   
--   When you do not need the old value, (<a>&lt;&gt;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&lt;&lt;&gt;~ Sum c
--   (Sum {getSum = a},(Sum {getSum = a + c},b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;&lt;&gt;~ ", 007" $ ("James", "Bond")
--   ("Bond",("James","Bond, 007"))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Monoid</a> r =&gt; <a>Lens'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Monoid</a> r =&gt; <a>Iso'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   </pre>
(<<<>~) :: Monoid r => Optical' (->) q ((,) r) s r -> r -> q s (r, s)

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the result.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the intermediate results.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
(<%=) :: (Profunctor p, MonadState s m) => Over p ((,) b) s s a b -> p a b -> m b

-- | Add to the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the addition, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Subtract from the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the subtraction, (<a>-=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Multiply the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the multiplication, (<a>*=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Divide the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the division, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a

-- | Raise the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to a non-negative <a>Integral</a> power and
--   return the result.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Raise the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an <a>Integral</a> power and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Iso'</a> s a  -&gt; e -&gt; m a
--   </pre>
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Raise the target of a floating-point valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m =&gt; <a>LensLike</a> ((,)a) s s a b -&gt; (a -&gt; b) -&gt; m a
--   </pre>
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with a user supplied value and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>.=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> t) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   adding a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   subtracting a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>-=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   multipling a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>*=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <a>Monad</a>s state by
--   dividing by a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by a non-negative power and return the <i>old</i> value
--   that was replaced.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an integral power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an arbitrary power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>||</a> with a value and return the <i>old</i>
--   value that was replaced.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>&amp;&amp;</a> with a value and return the
--   <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   <a>mappend</a>ing a value and return the <i>old</i> value that was
--   replaced.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Lens'</a> s r -&gt; r -&gt; m r
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Iso'</a> s r -&gt; r -&gt; m r
--   </pre>
(<<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r

-- | Run a monadic action, and set the target of <a>Lens</a> to its result.
--   
--   <pre>
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b   -&gt; m b -&gt; m b
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b  -&gt; m b -&gt; m b
--   </pre>
--   
--   NB: This is limited to taking an actual <a>Lens</a> than admitting a
--   <a>Traversal</a> because there are potential loss of state issues
--   otherwise.
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b

-- | <a>mappend</a> a monoidal value onto the end of the target of a
--   <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;~</a>)
--   is more flexible.
(<<>~) :: Monoid m => Optical (->) q ((,) m) s t m m -> m -> q s (m, t)

-- | <a>mappend</a> a monoidal value onto the end of the target of a
--   <a>Lens</a> into your <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
(<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary along with the answer.
--   
--   <pre>
--   l <a>&lt;%~</a> f  l <a>&lt;%@~</a> <a>const</a> f
--   </pre>
--   
--   When you do not need access to the index then (<a>&lt;%~</a>) is more
--   liberal in what it can accept.
--   
--   If you do not need the intermediate result, you can use (<a>%@~</a>)
--   or even (<a>%~</a>).
--   
--   <pre>
--   (<a>&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%@~</a>) :: <a>Monoid</a> b =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%@~) :: Optical (Indexed i) q ((,) b) s t a b -> (i -> a -> b) -> q s (b, t)

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> and return a
--   monoidal summary of the old values along with the answer.
--   
--   <pre>
--   (<a>&lt;&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%@~</a>) :: <a>Monoid</a> a =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%@~) :: Optical (Indexed i) q ((,) a) s t a b -> (i -> a -> b) -> q s (a, t)

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary of the supplementary results and the answer.
--   
--   <pre>
--   (<a>%%@~</a>)  <a>withIndex</a>
--   </pre>
--   
--   <pre>
--   (<a>%%@~</a>) :: <a>Functor</a> f =&gt; <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%@~</a>) :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   In particular, it is often useful to think of this function as having
--   one of these even more restricted type signatures:
--   
--   <pre>
--   (<a>%%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%@~</a>) :: <a>Monoid</a> r =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   </pre>
(%%@~) :: IndexedLensLike i f s t a b -> (i -> a -> f b) -> s -> f t

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   supplementary results.
--   
--   <pre>
--   l <a>%%@=</a> f  <a>state</a> (l <a>%%@~</a> f)
--   </pre>
--   
--   <pre>
--   (<a>%%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   (<a>%%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   </pre>
(%%@=) :: MonadState s m => IndexedLensLike i ((,) r) s s a b -> (i -> a -> (r, b)) -> m r

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   intermediate results.
--   
--   <pre>
--   (<a>&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   (<a>&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   </pre>
(<%@=) :: MonadState s m => IndexedLensLike i ((,) b) s s a b -> (i -> a -> b) -> m b

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> within the
--   current state, and return a monoidal summary of the old values.
--   
--   <pre>
--   (<a>&lt;&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   (<a>&lt;&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   </pre>
(<<%@=) :: MonadState s m => IndexedLensLike i ((,) a) s s a b -> (i -> a -> b) -> m a

-- | A version of (<a>^.</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^#_2
--   "world"
--   </pre>
(^#) :: s -> ALens s t a b -> a

-- | A version of (<a>.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 #~ "world"
--   ("hello","world")
--   </pre>
(#~) :: ALens s t a b -> b -> s -> t

-- | A version of (<a>%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%~ length
--   ("hello",5)
--   </pre>
(#%~) :: ALens s t a b -> (a -> b) -> s -> t

-- | A version of (<a>%%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%%~ \x -&gt; (length x, x ++ "!")
--   (5,("hello","world!"))
--   </pre>
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t

-- | A version of (<a>.=</a>) that works on <a>ALens</a>.
(#=) :: MonadState s m => ALens s s a b -> b -> m ()

-- | A version of (<a>%=</a>) that works on <a>ALens</a>.
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()

-- | A version of (<a>&lt;%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 &lt;#%~ length
--   (5,("hello",5))
--   </pre>
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)

-- | A version of (<a>&lt;%=</a>) that works on <a>ALens</a>.
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b

-- | A version of (<a>%%=</a>) that works on <a>ALens</a>.
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r

-- | A version of (<a>&lt;.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 &lt;#~ "world"
--   ("world",("hello","world"))
--   </pre>
(<#~) :: ALens s t a b -> b -> s -> (b, t)

-- | A version of (<a>&lt;.=</a>) that works on <a>ALens</a>.
(<#=) :: MonadState s m => ALens s s a b -> b -> m b

-- | Compose through a plate
(...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x  f x
--   l # x  x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f  <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f  <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: Profunctor p => Setting p s t a b -> p a b -> s -> t

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a  <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t  <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t

-- | Set with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.~</a> t</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;.~ c
--   (c,(c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("good","morning","vietnam") &amp; _3 &lt;.~ "world"
--   ("world",("good","morning","world"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,Map.fromList [("goodnight","gracie")]) &amp; _2.at "hello" &lt;.~ Just "world"
--   (Just "world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<.~) :: ASetter s t a b -> b -> s -> (b, t)

-- | Set to <a>Just</a> a value with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?~</a> d</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   ("world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)

-- | Increment the target(s) of a numerically valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 +~ c
--   (a + c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both +~ c
--   (a + c,b + c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 +~ 1
--   (1,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(a,b),(c,d)] &amp; traverse.both +~ e
--   [(a + e,b + e),(c + e,d + e)]
--   </pre>
--   
--   <pre>
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(+~) :: Num a => ASetter s t a a -> a -> s -> t

-- | Multiply the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 *~ c
--   (a * c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both *~ c
--   (a * c,b * c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 *~ 4
--   (1,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just 24 &amp; mapped *~ 2
--   Just 48
--   </pre>
--   
--   <pre>
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(*~) :: Num a => ASetter s t a a -> a -> s -> t

-- | Decrement the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 -~ c
--   (a - c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both -~ c
--   (a - c,b - c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 -~ 2 $ (1,2)
--   (-1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapped.mapped -~ 1 $ [[4,5],[6,7]]
--   [[3,4],[5,6]]
--   </pre>
--   
--   <pre>
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(-~) :: Num a => ASetter s t a a -> a -> s -> t

-- | Divide the target(s) of a numerically valued <a>Lens</a>, <a>Iso</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 //~ c
--   (a / c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both //~ c
--   (a / c,b / c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 //~ 2
--   ("Hawaii",5.0)
--   </pre>
--   
--   <pre>
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,3) &amp; _2 ^~ 2
--   (1,9)
--   </pre>
--   
--   <pre>
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t

-- | Raise the target(s) of a fractionally valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 ^^~ (-1)
--   (1,0.5)
--   </pre>
--   
--   <pre>
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t

-- | Raise the target(s) of a floating-point valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an arbitrary power.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 **~ c
--   (a**c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both **~ c
--   (a**c,b**c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 **~ 10 $ (3,2)
--   (3,1024.0)
--   </pre>
--   
--   <pre>
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(**~) :: Floating a => ASetter s t a a -> a -> s -> t

-- | Logically <a>||</a> the target(s) of a <a>Bool</a>-valued <a>Lens</a>
--   or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ True $ (False,True)
--   (True,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ False $ (False,True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   (<a>||~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t

-- | Logically <a>&amp;&amp;</a> the target(s) of a <a>Bool</a>-valued
--   <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ True $ (False, True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ False $ (False, True)
--   (False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .= c; _2 .= d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
--   
--   <i>It puts the state in the monad or it gets the hose again.</i>
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()

-- | Map over the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= f;_2 %= g) (a,b)
--   (f a,g b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do both %= f) (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; m ()
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>ASetter</a> s s a b -&gt; (a -&gt; b) -&gt; m ()
--   </pre>
(%=) :: (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with
--   <a>Just</a> a new value, irrespective of the old.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do at 1 ?= a; at 2 ?= b) Map.empty
--   fromList [(1,a),(2,b)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ?= b; _2 ?= c) (Just a, Nothing)
--   (Just b,Just c)
--   </pre>
--   
--   <pre>
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s (<a>Maybe</a> a)       -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s (<a>Maybe</a> a)      -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s (<a>Maybe</a> a) -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s (<a>Maybe</a> a)    -&gt; a -&gt; m ()
--   </pre>
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by adding a value.
--   
--   Example:
--   
--   <pre>
--   <tt>fresh</tt> :: <a>MonadState</a> <a>Int</a> m =&gt; m <a>Int</a>
--   <tt>fresh</tt> = do
--     <a>id</a> <a>+=</a> 1
--     <a>use</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 += c; _2 += d) (a,b)
--   (a + c,b + d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1.at 1.non 0 += 10) (Map.fromList [(2,100)],"hello")
--   (fromList [(1,10),(2,100)],"hello")
--   </pre>
--   
--   <pre>
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by subtracting a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 -= c; _2 -= d) (a,b)
--   (a - c,b - d)
--   </pre>
--   
--   <pre>
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by multiplying by value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 *= c; _2 *= d) (a,b)
--   (a * c,b * d)
--   </pre>
--   
--   <pre>
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by dividing by a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 //= c; _2 //= d) (a,b)
--   (a / c,b / d)
--   </pre>
--   
--   <pre>
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an arbitrary power
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 **= c; _2 **= d) (a,b)
--   (a**c,b**d)
--   </pre>
--   
--   <pre>
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>&amp;&amp;</a> with a
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &amp;&amp;= True; _2 &amp;&amp;= False; _3 &amp;&amp;= True; _4 &amp;&amp;= False) (True,True,False,False)
--   (True,False,False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, 'Iso, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>||</a> with a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ||= True; _2 ||= False; _3 ||= True; _4 ||= False) (True,True,False,False)
--   (True,True,True,False)
--   </pre>
--   
--   <pre>
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()

-- | Run a monadic action, and set all of the targets of a <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to its result.
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; m b -&gt; m ()
--   </pre>
--   
--   As a reasonable mnemonic, this lets you store the result of a monadic
--   action in a <a>Lens</a> rather than in a local variable.
--   
--   <pre>
--   do foo &lt;- bar
--      ...
--   </pre>
--   
--   will store the result in a variable, while
--   
--   <pre>
--   do foo <a>&lt;~</a> bar
--      ...
--   </pre>
--   
--   will store the result in a <a>Lens</a>, <a>Setter</a>, or
--   <a>Traversal</a>.
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()

-- | Set with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>_2</a> <a>&lt;.=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; b -&gt; m b
--   </pre>
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b

-- | Set <a>Just</a> a value with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>at</a> "foo" <a>&lt;?=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a (<a>Maybe</a> b)    -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a (<a>Maybe</a> b)       -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a (<a>Maybe</a> b)      -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a (<a>Maybe</a> b) -&gt; b -&gt; m b
--   </pre>
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b

-- | Modify the target of a monoidally valued by <a>mappend</a>ing another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Monoid a => ASetter s t a a -> a -> s -> t

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by <a>mappend</a>ing a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &lt;&gt;= Sum c; _2 &lt;&gt;= Product d) (Sum a,Product b)
--   (Sum {getSum = a + c},Product {getProduct = b * d})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;&gt;= "!!!") ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Setter'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(<>=) :: (MonadState s m, Monoid a) => ASetter' s a -> a -> m ()

-- | Adjust every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>%@~</a>)  <a>iover</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>%~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%~</a> f  l <a>%@~</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Adjust every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>%=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%=</a> f  l <a>%@=</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   </pre>
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()


module Control.Monad.Error.Lens

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>, really).
--   
--   <pre>
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadError e m => Getting (First a) e a -> m r -> (a -> m r) -> m r

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>), discarding the information about the match. This is
--   particuarly useful when you have a <tt><a>Prism'</a> e ()</tt> where
--   the result of the <a>Prism</a> or <a>Fold</a> isn't particularly
--   valuable, just the fact that it matches.
--   
--   <pre>
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a       -&gt; m r -&gt; m r -&gt; m r
--   </pre>
catching_ :: MonadError e m => Getting (First a) e a -> m r -> m r -> m r

-- | A version of <a>catching</a> with the arguments swapped around; useful
--   in situations where the code for the handler is shorter.
--   
--   <pre>
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a       -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a     -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   </pre>
handling :: MonadError e m => Getting (First a) e a -> (a -> m r) -> m r -> m r

-- | A version of <a>catching_</a> with the arguments swapped around;
--   useful in situations where the code for the handler is shorter.
--   
--   <pre>
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a     -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a       -&gt; m r -&gt; m r -&gt; m r
--   </pre>
handling_ :: MonadError e m => Getting (First a) e a -> m r -> m r -> m r

-- | <a>trying</a> takes a <a>Prism</a> (or any <a>Getter</a>) to select
--   which exceptions are caught If the <tt>Exception</tt> does not match
--   the predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a     -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a       -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadError e m => Getting (First a) e a -> m r -> m (Either a r)

-- | This function exists to remedy a gap between the functionality of
--   <tt>Control.Exception</tt> and <tt>Control.Monad.Error</tt>.
--   <tt>Control.Exception</tt> supplies <a>catches</a> and a notion of
--   <a>Handler</a>, which we duplicate here in a form suitable for working
--   with any <a>MonadError</a> instance.
--   
--   Sometimes you want to catch two different sorts of error. You could do
--   something like
--   
--   <pre>
--   f = <a>handling</a> _Foo handleFoo (<a>handling</a> _Bar handleBar expr)
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleFoo</tt> uses <a>throwError</a> then the second exception
--   handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = <a>catches</a> expr [ <a>handler</a> _Foo handleFoo
--                    , <a>handler</a> _Bar handleBar
--                    ]
--   </pre>
catches :: MonadError e m => m a -> [Handler e m a] -> m a

-- | You need this when using <a>catches</a>.
data Handler e m r
Handler :: (e -> Maybe a) -> (a -> m r) -> Handler e m r

-- | Both <tt>exceptions</tt> and <a>Control.Exception</a> provide a
--   <a>Handler</a> type.
--   
--   This lets us write combinators to build handlers that are agnostic
--   about the choice of which of these they use.
class Handleable e (m :: * -> *) (h :: * -> *) | h -> e m where handler_ l = handler l . const
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r

-- | Throw an <tt>Exception</tt> described by a <a>Prism</a>.
--   
--   <pre>
--   <a>throwing</a> l  <a>reviews</a> l <a>throwError</a>
--   </pre>
--   
--   <pre>
--   <a>throwing</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e t -&gt; t -&gt; a
--   <a>throwing</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e t   -&gt; t -&gt; a
--   </pre>
throwing :: MonadError e m => AReview e t -> t -> m x
instance Handleable e m (Handler e m)
instance Monad m => Monoid (Handler e m a)
instance Monad m => Plus (Handler e m)
instance Monad m => Alt (Handler e m)
instance Monad m => Semigroup (Handler e m a)
instance Monad m => Functor (Handler e m)


-- | A <a>Lens</a> or <a>Traversal</a> can be used to take the role of
--   <a>Traversable</a> in <tt>Control.Parallel.Strategies</tt>, enabling
--   those combinators to work with monomorphic containers.
module Control.Parallel.Strategies.Lens

-- | Evaluate the targets of a <a>Lens</a> or <a>Traversal</a> into a data
--   structure according to the given <a>Strategy</a>.
--   
--   <pre>
--   <a>evalTraversable</a> = <a>evalOf</a> <a>traverse</a> = <a>traverse</a>
--   <a>evalOf</a> = <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>evalOf</a> :: <a>Lens'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>evalOf</a> :: <a>Traversal'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>evalOf</a> :: (a -&gt; <a>Eval</a> a) -&gt; s -&gt; <a>Eval</a> s) -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   </pre>
evalOf :: LensLike' Eval s a -> Strategy a -> Strategy s

-- | Evaluate the targets of a <a>Lens</a> or <a>Traversal</a> according
--   into a data structure according to a given <a>Strategy</a> in
--   parallel.
--   
--   <pre>
--   <a>parTraversable</a> = <a>parOf</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>parOf</a> :: <a>Lens'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>parOf</a> :: <a>Traversal'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>parOf</a> :: ((a -&gt; <a>Eval</a> a) -&gt; s -&gt; <a>Eval</a> s) -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   </pre>
parOf :: LensLike' Eval s a -> Strategy a -> Strategy s

-- | Transform a <a>Lens</a>, <a>Fold</a>, <a>Getter</a>, <a>Setter</a> or
--   <a>Traversal</a> to first evaluates its argument according to a given
--   <a>Strategy</a> <i>before</i> proceeding.
--   
--   <pre>
--   <a>after</a> <a>rdeepseq</a> <a>traverse</a> :: <a>Traversable</a> t =&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> [a]
--   </pre>
after :: Strategy s -> LensLike f s t a b -> LensLike f s t a b

-- | Transform a <a>Lens</a>, <a>Fold</a>, <a>Getter</a>, <a>Setter</a> or
--   <a>Traversal</a> to evaluate its argument according to a given
--   <a>Strategy</a> <i>in parallel with</i> evaluating.
--   
--   <pre>
--   <a>throughout</a> <a>rdeepseq</a> <a>traverse</a> :: <a>Traversable</a> t =&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> [a]
--   </pre>
throughout :: Strategy s -> LensLike f s t a b -> LensLike f s t a b


-- | A <a>Fold</a> can be used to take the role of <tt>Foldable</tt> in
--   <tt>Control.Seq</tt>.
module Control.Seq.Lens

-- | Evaluate the elements targeted by a <a>Lens</a>, <a>Traversal</a>,
--   <a>Iso</a>, <a>Getter</a> or <a>Fold</a> according to the given
--   strategy.
--   
--   <pre>
--   <a>seqFoldable</a> = <a>seqOf</a> <a>folded</a>
--   </pre>
seqOf :: Getting (Endo [a]) s a -> Strategy a -> Strategy s


module Data.Array.Lens

-- | This <tt>setter</tt> can be used to derive a new <a>IArray</a> from an
--   old <tt>IAarray</tt> by applying a function to each of the indices to
--   look it up in the old <a>IArray</a>.
--   
--   This is a <i>contravariant</i> <a>Setter</a>.
--   
--   <pre>
--   <a>ixmap</a>  <a>over</a> <a>.</a> <a>ixmapped</a>
--   <a>ixmapped</a>  <a>setting</a> <a>.</a> <a>ixmap</a>
--   <a>over</a> (<a>ixmapped</a> b) f arr <a>!</a> i  arr <a>!</a> f i
--   <a>bounds</a> (<a>over</a> (<a>ixmapped</a> b) f arr)  b
--   </pre>
ixmapped :: (IArray a e, Ix i, Ix j) => (i, i) -> IndexPreservingSetter (a j e) (a i e) i j


module Data.Bits.Lens

-- | Bitwise <a>.|.</a> the target(s) of a <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .|.~ 6 $ ("hello",3)
--   ("hello",7)
--   </pre>
--   
--   <pre>
--   (<a>.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>.|.~</a>) :: (<a>Monoid</a> a, <a>Bits</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(.|.~) :: Bits a => ASetter s t a a -> a -> s -> t

-- | Bitwise <a>.&amp;.</a> the target(s) of a <a>Lens</a> or
--   <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .&amp;.~ 7 $ ("hello",254)
--   ("hello",6)
--   </pre>
--   
--   <pre>
--   (<a>.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>.&amp;.~</a>) :: (<a>Monoid</a> a, <a>Bits</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(.&.~) :: Bits a => ASetter s t a a -> a -> s -> t

-- | Bitwise <a>.|.</a> the target(s) of a <a>Lens</a> (or
--   <a>Traversal</a>), returning the result (or a monoidal summary of all
--   of the results).
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;.|.~ 6 $ ("hello",3)
--   (7,("hello",7))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.|.~</a>) :: (<a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; (a, t)
--   </pre>
(<.|.~) :: Bits a => LensLike ((,) a) s t a a -> a -> s -> (a, t)

-- | Bitwise <a>.&amp;.</a> the target(s) of a <a>Lens</a> or
--   <a>Traversal</a>, returning the result (or a monoidal summary of all
--   of the results).
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;.&amp;.~ 7 $ ("hello",254)
--   (6,("hello",6))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a>       s t a a -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a>      s t a a -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.&amp;.~</a>) :: (<a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; (a, t)
--   </pre>
(<.&.~) :: Bits a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<<.|.~) :: Bits a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)
(<<.&.~) :: Bits a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)

-- | Modify the target(s) of a <a>Lens'</a>, <a>Setter</a> or
--   <a>Traversal</a> by computing its bitwise <a>.|.</a> with another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .|.= 15; _2 .|.= 3) (7,7)
--   (15,7)
--   </pre>
--   
--   <pre>
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(.|.=) :: (MonadState s m, Bits a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, <a>Setter'</a> or
--   <a>Traversal'</a> by computing its bitwise <a>.&amp;.</a> with another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .&amp;.= 15; _2 .&amp;.= 3) (7,7)
--   (7,3)
--   </pre>
--   
--   <pre>
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(.&.=) :: (MonadState s m, Bits a) => ASetter' s a -> a -> m ()

-- | Modify the target(s) of a <a>Lens'</a>, (or <a>Traversal</a>) by
--   computing its bitwise <a>.|.</a> with another value, returning the
--   result (or a monoidal summary of all of the results traversed).
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;.|.= 7) (28,0)
--   (31,(31,0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a)           =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<.|.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a

-- | Modify the target(s) of a <a>Lens'</a> (or <a>Traversal'</a>) by
--   computing its bitwise <a>.&amp;.</a> with another value, returning the
--   result (or a monoidal summary of all of the results traversed).
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;.&amp;.= 15) (31,0)
--   (15,(15,0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a)           =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<.&.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
(<<.|.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
(<<.&.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a

-- | This <a>Lens</a> can be used to access the value of the nth bit in a
--   number.
--   
--   <tt><a>bitAt</a> n</tt> is only a legal <a>Lens</a> into <tt>b</tt> if
--   <tt>0 <a>&lt;=</a> n <a>&lt;</a> <a>bitSize</a> (<a>undefined</a> ::
--   b)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 16^.bitAt 4
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 15^.bitAt 4
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 15 &amp; bitAt 4 .~ True
--   31
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 16 &amp; bitAt 4 .~ False
--   0
--   </pre>
bitAt :: Bits b => Int -> IndexedLens' Int b Bool

-- | Traverse over all bits in a numeric type.
--   
--   The bit position is available as the index.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf bits (5 :: Word8)
--   [True,False,True,False,False,False,False,False]
--   </pre>
--   
--   If you supply this an <a>Integer</a>, the result will be an infinite
--   <a>Traversal</a>, which can be productively consumed, but not
--   reassembled.
bits :: (Num b, Bits b) => IndexedTraversal' Int b Bool

-- | Get the nth byte, counting from the low end.
--   
--   <tt><a>byteAt</a> n</tt> is a legal <a>Lens</a> into <tt>b</tt> iff
--   <tt>0 <a>&lt;=</a> n <a>&lt;</a> <a>div</a> (<a>bitSize</a>
--   (<a>undefined</a> :: b)) 8</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (0xff00 :: Word16)^.byteAt 0
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0xff00 :: Word16)^.byteAt 1
--   255
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; byteAt 1 .~ 0 $ 0xff00 :: Word16
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; byteAt 0 .~ 0xff $ 0 :: Word16
--   255
--   </pre>
byteAt :: (Integral b, Bits b) => Int -> IndexedLens' Int b Word8

-- | Traverse over all the bytes in an integral type, from the low end.
--   
--   The byte position is available as the index.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf bytewise (1312301580 :: Word32)
--   [12,34,56,78]
--   </pre>
--   
--   If you supply this an <a>Integer</a>, the result will be an infinite
--   <a>Traversal</a>, which can be productively consumed, but not
--   reassembled.
--   
--   Why is'nt this function called <tt>bytes</tt> to match <a>bits</a>?
--   Alas, there is already a function by that name in
--   <a>Data.ByteString.Lens</a>.
bytewise :: (Integral b, Bits b) => IndexedTraversal' Int b Word8


module Data.ByteString.Strict.Lens

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a
--   <a>ByteString</a>
--   
--   <pre>
--   <a>packedBytes</a>  <a>from</a> <a>unpackedBytes</a>
--   <a>pack</a> x   x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x  x <a>^.</a> <a>from</a> <a>packedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes
--   "hello"
--   </pre>
packedBytes :: Iso' [Word8] ByteString

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes
--   
--   <pre>
--   <a>unpackedBytes</a>  <a>from</a> <a>packedBytes</a>
--   <a>unpack</a> x  x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x   x <a>^.</a> <a>from</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.unpackedBytes
--   [104,101,108,108,111]
--   </pre>
unpackedBytes :: Iso' ByteString [Word8]

-- | Traverse each <a>Word8</a> in a <a>ByteString</a>.
--   
--   This <a>Traversal</a> walks the <a>ByteString</a> in a tree-like
--   fashion enable zippers to seek to locations in logarithmic time and
--   accelerating many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a>  <a>unpackedBytes</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf bytes (== 0x80) (Char8.pack "hello")
--   False
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
bytes :: IndexedTraversal' Int ByteString Word8

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   <pre>
--   <a>packedChars</a>  <a>from</a> <a>unpackedChars</a>
--   <a>pack</a> x  x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x  x <a>^.</a> <a>from</a> <a>packedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.each.re (base 16 . enum).to (\x -&gt; if Prelude.length x == 1 then '0':x else x)
--   "68656c6c6f"
--   </pre>
packedChars :: Iso' String ByteString

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a>  <a>from</a> <a>packedChars</a>
--   <a>unpack</a> x  x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x  x <a>^.</a> <a>from</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes.unpackedChars
--   "hello"
--   </pre>
unpackedChars :: Iso' ByteString String

-- | Traverse the individual bytes in a <a>ByteString</a> as characters.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   This <a>Traversal</a> walks the <a>ByteString</a> in a tree-like
--   fashion enable zippers to seek to locations in logarithmic time and
--   accelerating many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>chars</a> = <a>unpackedChars</a> <a>.</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf chars (== 'h') "hello"
--   True
--   </pre>
chars :: IndexedTraversal' Int ByteString Char


-- | Lazy <a>ByteString</a> lenses.
module Data.ByteString.Lazy.Lens

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a
--   <a>ByteString</a>.
--   
--   <pre>
--   <a>packedBytes</a>  <a>from</a> <a>unpackedBytes</a>
--   <a>pack</a> x   x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x  x <a>^.</a> <a>from</a> <a>packedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes == Char8.pack "hello"
--   True
--   </pre>
packedBytes :: Iso' [Word8] ByteString

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes
--   
--   <pre>
--   <a>unpackedBytes</a>  <a>from</a> <a>packedBytes</a>
--   <a>unpack</a> x  x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x   x <a>^.</a> <a>from</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.unpackedBytes
--   [104,101,108,108,111]
--   </pre>
unpackedBytes :: Iso' ByteString [Word8]

-- | Traverse the individual bytes in a <a>ByteString</a>.
--   
--   This <a>Traversal</a> walks each strict <a>ByteString</a> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a>  <a>unpackedBytes</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf bytes (== 0x80) (Char8.pack "hello")
--   False
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
bytes :: IndexedTraversal' Int64 ByteString Word8

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a
--   <a>ByteString</a>.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   <pre>
--   <a>packedChars</a>  <a>from</a> <a>unpackedChars</a>
--   <a>pack</a> x  x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x  x <a>^.</a> <a>from</a> <a>packedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.each.re (base 16 . enum).to (\x -&gt; if Prelude.length x == 1 then '0':x else x)
--   "68656c6c6f"
--   </pre>
packedChars :: Iso' String ByteString

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a>  <a>from</a> <a>packedChars</a>
--   <a>unpack</a> x  x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x  x <a>^.</a> <a>from</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes.unpackedChars
--   "hello"
--   </pre>
unpackedChars :: Iso' ByteString String

-- | Traverse the individual bytes in a <a>ByteString</a> as characters.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   This <a>Traversal</a> walks each strict <a>ByteString</a> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to:
--   
--   <pre>
--   <a>chars</a> = <a>unpackedChars</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf chars (== 'h') "hello"
--   True
--   </pre>
chars :: IndexedTraversal' Int64 ByteString Char


module Data.ByteString.Lens

-- | Traversals for ByteStrings.
class IsByteString t where bytes = from packedBytes . traversed chars = from packedChars . traversed
packedBytes :: IsByteString t => Iso' [Word8] t
packedChars :: IsByteString t => Iso' String t
bytes :: IsByteString t => IndexedTraversal' Int t Word8
chars :: IsByteString t => IndexedTraversal' Int t Char

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes
--   
--   <pre>
--   <a>unpackedBytes</a>  <a>from</a> <a>packedBytes</a>
--   <a>unpack</a> x  x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x   x <a>^.</a> <a>from</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   <a>unpackedBytes</a> :: <a>Iso'</a> <a>ByteString</a> [<a>Word8</a>]
--   <a>unpackedBytes</a> :: <a>Iso'</a> <a>ByteString</a> [<a>Word8</a>]
--   </pre>
unpackedBytes :: IsByteString t => Iso' t [Word8]

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a strict (or
--   lazy) <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'\x00'</tt> and <tt>'\xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a>  <a>from</a> <a>packedChars</a>
--   <a>unpack</a> x  x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x  x <a>^.</a> <a>from</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   <a>unpackedChars</a> :: <a>Iso'</a> <a>ByteString</a> <a>String</a>
--   <a>unpackedChars</a> :: <a>Iso'</a> <a>ByteString</a> <a>String</a>
--   </pre>
unpackedChars :: IsByteString t => Iso' t String
instance IsByteString ByteString
instance IsByteString ByteString


-- | Lenses and traversals for complex numbers
module Data.Complex.Lens

-- | Access the <a>realPart</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (a :+ b)^._realPart
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a :+ b &amp; _realPart *~ 2
--   a * 2 :+ b
--   </pre>
--   
--   <pre>
--   <a>_realPart</a> :: <a>Functor</a> f =&gt; (a -&gt; f a) -&gt; <a>Complex</a> a -&gt; f (<a>Complex</a> a)
--   </pre>
_realPart :: Lens' (Complex a) a

-- | Access the <a>imagPart</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (a :+ b)^._imagPart
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a :+ b &amp; _imagPart *~ 2
--   a :+ b * 2
--   </pre>
--   
--   <pre>
--   <a>_imagPart</a> :: <a>Functor</a> f =&gt; (a -&gt; f a) -&gt; <a>Complex</a> a -&gt; f (<a>Complex</a> a)
--   </pre>
_imagPart :: Lens' (Complex a) a

-- | This isn't <i>quite</i> a legal <a>Lens</a>. Notably the
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l b a) = b
--   </pre>
--   
--   law is violated when you set a <a>polar</a> value with 0
--   <a>magnitude</a> and non-zero <a>phase</a> as the <a>phase</a>
--   information is lost, or with a negative <a>magnitude</a> which flips
--   the <a>phase</a> and retains a positive <a>magnitude</a>. So don't do
--   that!
--   
--   Otherwise, this is a perfectly cromulent <a>Lens</a>.
_polar :: RealFloat a => Iso' (Complex a) (a, a)

-- | Access the <a>magnitude</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (10.0 :+ 20.0) &amp; _magnitude *~ 2
--   20.0 :+ 40.0
--   </pre>
--   
--   This isn't <i>quite</i> a legal <a>Lens</a>. Notably the
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l b a) = b
--   </pre>
--   
--   law is violated when you set a negative <a>magnitude</a>. This flips
--   the <a>phase</a> and retains a positive <a>magnitude</a>. So don't do
--   that!
--   
--   Otherwise, this is a perfectly cromulent <a>Lens</a>.
--   
--   Setting the <a>magnitude</a> of a zero <a>Complex</a> number assumes
--   the <a>phase</a> is 0.
_magnitude :: RealFloat a => Lens' (Complex a) a

-- | Access the <a>phase</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (mkPolar 10 (2-pi) &amp; _phase +~ pi &amp; view _phase)  2
--   True
--   </pre>
--   
--   This isn't <i>quite</i> a legal <a>Lens</a>. Notably the
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l b a) = b
--   </pre>
--   
--   law is violated when you set a <a>phase</a> outside the range
--   <tt>(-<a>pi</a>, <a>pi</a>]</tt>. The phase is always in that range
--   when queried. So don't do that!
--   
--   Otherwise, this is a perfectly cromulent <a>Lens</a>.
_phase :: RealFloat a => Lens' (Complex a) a

-- | Access the <a>conjugate</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (2.0 :+ 3.0) &amp; _conjugate . _imagPart -~ 1
--   2.0 :+ 4.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (mkPolar 10.0 2.0 ^. _conjugate . _phase)  (-2.0)
--   True
--   </pre>
_conjugate :: RealFloat a => Iso' (Complex a) (Complex a)


module Data.IntSet.Lens

-- | IntSet isn't Foldable, but this <a>Fold</a> can be used to access the
--   members of an <a>IntSet</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf members $ setOf folded [1,2,3,4]
--   10
--   </pre>
members :: Fold IntSet Int

-- | This <a>Setter</a> can be used to change the contents of an
--   <a>IntSet</a> by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <tt>Set</tt>,
--   because the number of elements might change but you can manipulate it
--   by reading using <a>folded</a> and reindexing it via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: IndexPreservingSetter' IntSet Int

-- | Construct an <a>IntSet</a> from a <a>Getter</a>, <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded [1,2,3,4]
--   fromList [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded._2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>setOf</a> :: <a>Getter</a> s <a>Int</a>     -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Fold</a> s <a>Int</a>       -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Iso'</a> s <a>Int</a>       -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Lens'</a> s <a>Int</a>      -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Traversal'</a> s <a>Int</a> -&gt; s -&gt; <a>IntSet</a>
--   </pre>
setOf :: Getting IntSet s Int -> s -> IntSet


-- | Traversals for manipulating parts of a list.
module Data.List.Lens

-- | A <a>Prism</a> stripping a prefix from a list when used as a
--   <a>Traversal</a>, or prepending that prefix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? prefixed "pre"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "pre" # "amble"
--   "preamble"
--   </pre>
prefixed :: Eq a => [a] -> Prism' [a] [a]

-- | A <a>Prism</a> stripping a suffix from a list when used as a
--   <a>Traversal</a>, or appending that suffix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "view"
--   Just "re"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "tire"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
suffixed :: Eq a => [a] -> Prism' [a] [a]
stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]


module Data.Sequence.Lens

-- | A <a>Seq</a> is isomorphic to a <a>ViewL</a>
--   
--   <pre>
--   <a>viewl</a> m  m <a>^.</a> <a>viewL</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^. viewL
--   a :&lt; fromList [b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewL
--   EmptyL
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyL ^. from viewL
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewL $ a :&lt; fromList [b,c]
--   fromList [a,b,c]
--   </pre>
viewL :: Iso (Seq a) (Seq b) (ViewL a) (ViewL b)

-- | A <a>Seq</a> is isomorphic to a <a>ViewR</a>
--   
--   <pre>
--   <a>viewr</a> m  m <a>^.</a> <a>viewR</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^. viewR
--   fromList [a,b] :&gt; c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewR
--   EmptyR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyR ^. from viewR
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewR $ fromList [a,b] :&gt; c
--   fromList [a,b,c]
--   </pre>
viewR :: Iso (Seq a) (Seq b) (ViewR a) (ViewR b)

-- | Traverse all the elements numbered from <tt>i</tt> to <tt>j</tt> of a
--   <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] &amp; sliced 1 3 %~ f
--   fromList [a,f b,f c,d,e]
--   </pre>
sliced :: Int -> Int -> IndexedTraversal' Int (Seq a) a

-- | Traverse the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] ^.. slicedTo 2
--   [a,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] &amp; slicedTo 2 %~ f
--   fromList [f a,f b,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] &amp; slicedTo 10 .~ x
--   fromList [x,x,x,x,x]
--   </pre>
slicedTo :: Int -> IndexedTraversal' Int (Seq a) a

-- | Traverse all but the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] ^.. slicedFrom 2
--   [c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] &amp; slicedFrom 2 %~ f
--   fromList [a,b,f c,f d,f e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [a,b,c,d,e] &amp; slicedFrom 10 .~ x
--   fromList [a,b,c,d,e]
--   </pre>
slicedFrom :: Int -> IndexedTraversal' Int (Seq a) a

-- | Construct a <a>Seq</a> from a <a>Getter</a>, <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   &gt;&gt;&gt; seqOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; seqOf (folded._2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>seqOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Seq</a> a
--   </pre>
seqOf :: Getting (Seq a) s a -> s -> Seq a


module Data.Text.Strict.Lens

-- | This isomorphism can be used to <a>pack</a> (or <a>unpack</a>) strict
--   <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packed -- :: Text
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>pack</a> x  x <a>^.</a> <a>packed</a>
--   <a>unpack</a> x  x <a>^.</a> <a>from</a> <a>packed</a>
--   <a>packed</a>  <a>from</a> <a>unpacked</a>
--   <a>packed</a>  <a>iso</a> <a>pack</a> <a>unpack</a>
--   </pre>
packed :: Iso' String Text

-- | This isomorphism can be used to <a>unpack</a> (or <a>pack</a>) lazy
--   <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.unpacked -- :: String
--   "hello"
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a>  <a>from</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   <a>pack</a> x  x <a>^.</a> <a>from</a> <a>unpacked</a>
--   <a>unpack</a> x  x <a>^.</a> <a>packed</a>
--   <a>unpacked</a>  <a>iso</a> <a>unpack</a> <a>pack</a>
--   </pre>
unpacked :: Iso' Text String

-- | Convert between strict <a>Text</a> and <a>Builder</a> .
--   
--   <pre>
--   <a>fromText</a> x  x <a>^.</a> <a>builder</a>
--   <a>toStrict</a> (<a>toLazyText</a> x)  x <a>^.</a> <a>from</a> <a>builder</a>
--   </pre>
builder :: Iso' Text Builder

-- | Traverse the individual characters in strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf text (=='o') "hello"
--   True
--   </pre>
--   
--   When the type is unambiguous, you can also use the more general
--   <a>each</a>.
--   
--   <pre>
--   <a>text</a>  <a>unpacked</a> . <a>traversed</a>
--   <a>text</a>  <a>each</a>
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
text :: IndexedTraversal' Int Text Char

-- | Encode<i>Decode a strict <a>Text</a> to</i>from strict
--   <a>ByteString</a>, via UTF-8.
--   
--   <pre>
--   &gt;&gt;&gt; utf8 # ""
--   "\226\152\131"
--   </pre>
utf8 :: Prism' ByteString Text

-- | This is an alias for <a>unpacked</a> that makes it more obvious how to
--   use it with '#'
--   
--   <pre>
--   &gt; _Text # "hello" -- :: Text
--   </pre>
--   
--   "hello"
_Text :: Iso' Text String


module Data.Text.Lazy.Lens

-- | This isomorphism can be used to <a>pack</a> (or <a>unpack</a>) lazy
--   <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packed -- :: Text
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>pack</a> x  x <a>^.</a> <a>packed</a>
--   <a>unpack</a> x  x <a>^.</a> <a>from</a> <a>packed</a>
--   <a>packed</a>  <a>from</a> <a>unpacked</a>
--   </pre>
packed :: Iso' String Text

-- | This isomorphism can be used to <a>unpack</a> (or <a>pack</a>) lazy
--   <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.unpacked -- :: String
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>pack</a> x  x <a>^.</a> <a>from</a> <a>unpacked</a>
--   <a>unpack</a> x  x <a>^.</a> <a>packed</a>
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a>  <a>from</a> <a>packed</a>
--   </pre>
unpacked :: Iso' Text String

-- | This is an alias for <a>unpacked</a> that makes it clearer how to use
--   it with <tt>('#')</tt>.
--   
--   <pre>
--   <a>_Text</a> = <a>from</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Text # "hello" -- :: Text
--   "hello"
--   </pre>
_Text :: Iso' Text String

-- | Traverse the individual characters in a <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf text (=='c') "chello"
--   True
--   </pre>
--   
--   <pre>
--   <a>text</a> = <a>unpacked</a> . <a>traversed</a>
--   </pre>
--   
--   When the type is unambiguous, you can also use the more general
--   <a>each</a>.
--   
--   <pre>
--   <a>text</a>  <a>each</a>
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
text :: IndexedTraversal' Int Text Char

-- | Convert between lazy <a>Text</a> and <a>Builder</a> .
--   
--   <pre>
--   <a>fromLazyText</a> x  x <a>^.</a> <a>builder</a>
--   <a>toLazyText</a> x  x <a>^.</a> <a>from</a> <a>builder</a>
--   </pre>
builder :: Iso' Text Builder

-- | Encode<i>Decode a lazy <a>Text</a> to</i>from lazy <a>ByteString</a>,
--   via UTF-8.
--   
--   Note: This function does not decode lazily, as it must consume the
--   entire input before deciding whether or not it fails.
--   
--   <pre>
--   &gt;&gt;&gt; ByteString.unpack (utf8 # "")
--   [226,152,131]
--   </pre>
utf8 :: Prism' ByteString Text


module Data.Text.Lens

-- | Traversals for strict or lazy <a>Text</a>
class IsText t where text = unpacked . traversed
packed :: IsText t => Iso' String t
builder :: IsText t => Iso' t Builder
text :: IsText t => IndexedTraversal' Int t Char

-- | This isomorphism can be used to <a>unpack</a> (or <a>pack</a>) both
--   strict or lazy <a>Text</a>.
--   
--   <pre>
--   <a>unpack</a> x  x <a>^.</a> <a>unpacked</a>
--   <a>pack</a> x  x <a>^.</a> <a>from</a> <a>unpacked</a>
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a>  <a>from</a> <a>packed</a>
--   </pre>
unpacked :: IsText t => Iso' t String

-- | This is an alias for <a>unpacked</a> that makes it clearer how to use
--   it with <tt>('#')</tt>.
--   
--   <pre>
--   <a>_Text</a> = <a>from</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Text # "hello" :: Strict.Text
--   "hello"
--   </pre>
_Text :: IsText t => Iso' t String
instance IsText Text
instance IsText Text
instance IsText String


module Data.Tree.Lens

-- | A <a>Lens</a> that focuses on the root of a <a>Tree</a>.
--   
--   <pre>
--   &gt;&gt;&gt; view root $ Node 42 []
--   42
--   </pre>
root :: Lens' (Tree a) a

-- | A <a>Lens</a> returning the direct descendants of the root of a
--   <a>Tree</a>
--   
--   <pre>
--   <a>view</a> <a>branches</a>  <a>subForest</a>
--   </pre>
branches :: Lens' (Tree a) [Tree a]


module Data.Typeable.Lens

-- | A <a>Traversal'</a> for working with a <a>cast</a> of a
--   <a>Typeable</a> value.
_cast :: (Typeable s, Typeable a) => Traversal' s a

-- | A <a>Traversal'</a> for working with a <a>gcast</a> of a
--   <a>Typeable</a> value.
_gcast :: (Typeable s, Typeable a) => Traversal' (c s) (c a)


-- | This module provides lenses and traversals for working with generic
--   vectors.
module Data.Vector.Lens

-- | Similar to <a>toListOf</a>, but returning a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toVectorOf both (8,15)
--   fromList [8,15]
--   </pre>
toVectorOf :: Getting (Endo [a]) s a -> s -> Vector a

-- | Convert a list to a <a>Vector</a> (or back)
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector . from vector
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [0,8,15] ^. from vector . vector
--   fromList [0,8,15]
--   </pre>
vector :: Iso [a] [b] (Vector a) (Vector b)

-- | Convert a <a>Vector</a> to a version that doesn't retain any extra
--   memory.
forced :: Iso (Vector a) (Vector b) (Vector a) (Vector b)

-- | <tt>sliced i n</tt> provides a <a>Lens</a> that edits the <tt>n</tt>
--   elements starting at index <tt>i</tt> from a <a>Lens</a>.
--   
--   This is only a valid <a>Lens</a> if you do not change the length of
--   the resulting <a>Vector</a>.
--   
--   Attempting to return a longer or shorter vector will result in
--   violations of the <a>Lens</a> laws.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] ^. sliced 2 5
--   fromList [3,4,5,6,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] &amp; sliced 2 5 . mapped .~ 0
--   fromList [1,2,0,0,0,0,0,8,9,10]
--   </pre>
sliced :: Int -> Int -> Lens' (Vector a) (Vector a)

-- | This <a>Traversal</a> will ignore any duplicates in the supplied list
--   of indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]
--   [4,8,6,12,20,22]
--   </pre>
ordinals :: [Int] -> IndexedTraversal' Int (Vector a) a


-- | This module provides lenses and traversals for working with generic
--   vectors.
module Data.Vector.Generic.Lens

-- | Similar to <a>toListOf</a>, but returning a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toVectorOf both (8,15) :: Vector.Vector Int
--   fromList [8,15]
--   </pre>
toVectorOf :: Vector v a => Getting (Endo [a]) s a -> s -> v a

-- | Convert a <a>Vector</a> to a version that doesn't retain any extra
--   memory.
forced :: Vector v a => Iso' (v a) (v a)

-- | Convert a list to a <a>Vector</a> (or back.)
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector :: Vector.Vector Int
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [0,8,15] ^. from vector
--   [0,8,15]
--   </pre>
vector :: (Vector v a, Vector v b) => Iso [a] [b] (v a) (v b)

-- | Convert a <a>Vector</a> to a finite <a>Stream</a> (or back.)
asStream :: (Vector v a, Vector v b) => Iso (v a) (v b) (Stream a) (Stream b)

-- | Convert a <a>Vector</a> to a finite <a>Stream</a> from right to left
--   (or back.)
asStreamR :: (Vector v a, Vector v b) => Iso (v a) (v b) (Stream a) (Stream b)

-- | Convert a <a>Vector</a> back and forth to an initializer that when run
--   produces a copy of the <a>Vector</a>.
cloned :: Vector v a => Iso' (v a) (New v a)

-- | Different vector implementations are isomorphic to each other.
converted :: (Vector v a, Vector w a, Vector v b, Vector w b) => Iso (v a) (v b) (w a) (w b)

-- | <tt>sliced i n</tt> provides a <a>Lens</a> that edits the <tt>n</tt>
--   elements starting at index <tt>i</tt> from a <a>Lens</a>.
--   
--   This is only a valid <a>Lens</a> if you do not change the length of
--   the resulting <a>Vector</a>.
--   
--   Attempting to return a longer or shorter vector will result in
--   violations of the <a>Lens</a> laws.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] ^. sliced 2 5
--   fromList [3,4,5,6,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] &amp; sliced 2 5 . mapped .~ 0
--   fromList [1,2,0,0,0,0,0,8,9,10]
--   </pre>
sliced :: Vector v a => Int -> Int -> Lens' (v a) (v a)

-- | This <a>Traversal</a> will ignore any duplicates in the supplied list
--   of indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]
--   [4,8,6,12,20,22]
--   </pre>
ordinals :: Vector v a => [Int] -> IndexedTraversal' Int (v a) a

-- | Like <a>ix</a> but polymorphic in the vector type.
vectorIx :: Vector v a => Int -> Traversal' (v a) a


-- | Note: <tt>Generics.Deriving</tt> exports a number of names that
--   collide with <tt>Control.Lens</tt>.
--   
--   You can use hiding to mitigate this to an extent, and the following
--   import represents a fair compromise for user code:
--   
--   <pre>
--   import Generics.Deriving hiding (from, to)
--   </pre>
--   
--   You can use <a>generic</a> to replace <a>from</a> and <a>to</a> from
--   <tt>Generics.Deriving</tt>.
module Generics.Deriving.Lens

-- | Convert from the data type to its representation (or back)
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.generic.from generic :: String
--   "hello"
--   </pre>
generic :: Generic a => Iso' a (Rep a b)

-- | Convert from the data type to its representation (or back)
generic1 :: Generic1 f => Iso' (f a) (Rep1 f a)

-- | A <a>Generic</a> <a>Traversal</a> that visits every occurrence of
--   something <a>Typeable</a> anywhere in a container.
--   
--   <pre>
--   &gt;&gt;&gt; allOf tinplate (=="Hello") (1::Int,2::Double,(),"Hello",["Hello"])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf_ tinplate putStrLn ("hello",[(2 :: Int, "world!")])
--   hello
--   world!
--   </pre>
tinplate :: (Generic a, GTraversal (Rep a), Typeable b) => Traversal' a b

-- | Used to traverse <a>Generic</a> data by <tt>uniplate</tt>.
class GTraversal f
instance GTraversal a => GTraversal (M1 i c a)
instance (GTraversal f, GTraversal g) => GTraversal (f :+: g)
instance (GTraversal f, GTraversal g) => GTraversal (f :*: g)
instance GTraversal V1
instance GTraversal U1
instance (Generic a, GTraversal (Rep a), Typeable a) => GTraversal (K1 i a)


-- | Note: <tt>GHC.Generics</tt> exports a number of names that collide
--   with <tt>Control.Lens</tt>.
--   
--   You can use hiding or imports to mitigate this to an extent, and the
--   following imports, represent a fair compromise for user code:
--   
--   <pre>
--   import Control.Lens hiding (Rep)
--   import GHC.Generics hiding (from, to)
--   </pre>
--   
--   You can use <a>generic</a> to replace <a>from</a> and <a>to</a> from
--   <tt>GHC.Generics</tt>, and probably won't be explicitly referencing
--   <a>Rep</a> from <tt>Control.Lens</tt> in code that uses generics.
--   
--   This module provides compatibility with older GHC versions by using
--   the <a>generic-deriving</a> package.
module GHC.Generics.Lens
_V1 :: Over p f (V1 s) (V1 t) a b
_U1 :: Iso (U1 p) (U1 q) () ()
_Par1 :: Iso (Par1 p) (Par1 q) p q
_Rec1 :: Iso (Rec1 f p) (Rec1 g q) (f p) (g q)
_K1 :: Iso (K1 i c p) (K1 j d q) c d
_M1 :: Iso (M1 i c f p) (M1 j d g q) (f p) (g q)
_L1 :: Prism' ((f :+: g) a) (f a)
_R1 :: Prism' ((f :+: g) a) (g a)


module System.FilePath.Lens

-- | Modify the path by adding another path.
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;/&gt;~ "bin" $ ("hello","world")
--   ("hello/bin","world/bin")
--   </pre>
--   
--   <pre>
--   (<a>&lt;/&gt;~</a>) :: <a>Setter</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   (<a>&lt;/&gt;~</a>) :: <a>Iso</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   (<a>&lt;/&gt;~</a>) :: <a>Lens</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   (<a>&lt;/&gt;~</a>) :: <a>Traversal</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   </pre>
(</>~) :: ASetter s t FilePath FilePath -> FilePath -> s -> t

-- | Add a path onto the end of the target of a <a>Lens</a> and return the
--   result
--   
--   When you do not need the result of the operation, (<a>&lt;/&gt;~</a>)
--   is more flexible.
(<</>~) :: LensLike ((,) FilePath) s a FilePath FilePath -> FilePath -> s -> (FilePath, a)
(<<</>~) :: Optical' (->) q ((,) FilePath) s FilePath -> FilePath -> q s (FilePath, s)

-- | Modify the path by adding an extension.
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;.&gt;~ "txt" $ ("hello","world")
--   ("hello.txt","world.txt")
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&gt;~</a>) :: <a>Setter</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   (<a>&lt;.&gt;~</a>) :: <a>Iso</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   (<a>&lt;.&gt;~</a>) :: <a>Lens</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   (<a>&lt;.&gt;~</a>) :: <a>Traversal</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   </pre>
(<.>~) :: ASetter s a FilePath FilePath -> String -> s -> a

-- | Add an extension onto the end of the target of a <a>Lens</a> and
--   return the result
--   
--   <pre>
--   &gt;&gt;&gt; _1 &lt;&lt;.&gt;~ "txt" $ ("hello","world")
--   ("hello.txt",("hello.txt","world"))
--   </pre>
--   
--   When you do not need the result of the operation, (<a>&lt;.&gt;~</a>)
--   is more flexible.
(<<.>~) :: LensLike ((,) FilePath) s a FilePath FilePath -> String -> s -> (FilePath, a)

-- | Add an extension onto the end of the target of a <a>Lens</a> but
--   return the old value
--   
--   <pre>
--   &gt;&gt;&gt; _1 &lt;&lt;&lt;.&gt;~ "txt" $ ("hello","world")
--   ("hello",("hello.txt","world"))
--   </pre>
--   
--   When you do not need the old value, (<a>&lt;.&gt;~</a>) is more
--   flexible.
(<<<.>~) :: Optical' (->) q ((,) FilePath) s FilePath -> String -> q s (FilePath, s)

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso'</a>, <a>Setter'</a> or
--   <a>Traversal'</a> by adding a path.
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;/&gt;= "bin") ("hello","world")
--   ("hello/bin","world/bin")
--   </pre>
--   
--   <pre>
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   </pre>
(</>=) :: MonadState s m => ASetter' s FilePath -> FilePath -> m ()

-- | Add a path onto the end of the target of a <a>Lens</a> into your
--   monad's state and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;/&gt;=</a>)
--   is more flexible.
(<</>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> FilePath -> m FilePath
(<<</>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> FilePath -> m FilePath

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso'</a>, <a>Setter'</a> or
--   <a>Traversal'</a> by adding an extension.
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;.&gt;= "txt") ("hello","world")
--   ("hello.txt","world.txt")
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   </pre>
(<.>=) :: MonadState s m => ASetter' s FilePath -> String -> m ()

-- | Add an extension onto the end of the target of a <a>Lens</a> into your
--   monad's state and return the result.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (_1 &lt;&lt;.&gt;= "txt") ("hello","world")
--   "hello.txt"
--   </pre>
--   
--   When you do not need the result of the operation, (<a>&lt;.&gt;=</a>)
--   is more flexible.
(<<.>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> String -> m FilePath
(<<<.>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> String -> m FilePath

-- | A <a>Lens</a> for reading and writing to the basename
--   
--   Note: This is <a>not</a> a legal <a>Lens</a> unless the outer
--   <a>FilePath</a> has both a directory and filename component and the
--   generated basenames are not null and contain no directory separators.
--   
--   <pre>
--   &gt;&gt;&gt; basename .~ "filename" $ "path/name.png"
--   "path/filename.png"
--   </pre>
basename :: Lens' FilePath FilePath

-- | A <a>Lens</a> for reading and writing to the directory
--   
--   Note: this is <i>not</i> a legal <a>Lens</a> unless the outer
--   <a>FilePath</a> already has a directory component, and generated
--   directories are not null.
--   
--   <pre>
--   &gt;&gt;&gt; "long/path/name.txt" ^. directory
--   "long/path"
--   </pre>
directory :: Lens' FilePath FilePath

-- | A <a>Lens</a> for reading and writing to the extension
--   
--   Note: This is <i>not</i> a legal <a>Lens</a>, unless you are careful
--   to ensure that generated extension <a>FilePath</a> components are
--   either null or start with <a>extSeparator</a> and do not contain any
--   internal <a>extSeparator</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; extension .~ ".png" $ "path/name.txt"
--   "path/name.png"
--   </pre>
extension :: Lens' FilePath FilePath

-- | A <a>Lens</a> for reading and writing to the full filename
--   
--   Note: This is <i>not</i> a legal <a>Lens</a>, unless you are careful
--   to ensure that generated filename <a>FilePath</a> components are not
--   null and do not contain any elements of <a>pathSeparators</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; filename .~ "name.txt" $ "path/name.png"
--   "path/name.txt"
--   </pre>
filename :: Lens' FilePath FilePath


module System.IO.Error.Lens

-- | Where the error happened.
location :: Lens' IOException String

-- | Error type specific information.
description :: Lens' IOException String

-- | The handle used by the action flagging this error.
handle :: Lens' IOException (Maybe Handle)

-- | <a>fileName</a> the error is related to.
fileName :: Lens' IOException (Maybe FilePath)

-- | <a>errno</a> leading to this error, if any.
errno :: Lens' IOException (Maybe CInt)

-- | What type of error it is
errorType :: Lens' IOException IOErrorType
_AlreadyExists :: Prism' IOErrorType ()
_NoSuchThing :: Prism' IOErrorType ()
_ResourceBusy :: Prism' IOErrorType ()
_ResourceExhausted :: Prism' IOErrorType ()
_EOF :: Prism' IOErrorType ()
_IllegalOperation :: Prism' IOErrorType ()
_PermissionDenied :: Prism' IOErrorType ()
_UserError :: Prism' IOErrorType ()
_UnsatisfiedConstraints :: Prism' IOErrorType ()
_SystemError :: Prism' IOErrorType ()
_ProtocolError :: Prism' IOErrorType ()
_OtherError :: Prism' IOErrorType ()
_InvalidArgument :: Prism' IOErrorType ()
_InappropriateType :: Prism' IOErrorType ()
_HardwareFault :: Prism' IOErrorType ()
_UnsupportedOperation :: Prism' IOErrorType ()
_TimeExpired :: Prism' IOErrorType ()
_ResourceVanished :: Prism' IOErrorType ()
_Interrupted :: Prism' IOErrorType ()


module Numeric.Lens

-- | A prism that shows and reads integers in base-2 through base-36
--   
--   Note: This is an improper prism, since leading 0s are stripped when
--   reading.
--   
--   <pre>
--   &gt;&gt;&gt; "100" ^? base 16
--   Just 256
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1767707668033969 ^. re (base 36)
--   "helloworld"
--   </pre>
base :: Integral a => Int -> Prism' String a

-- | This <a>Prism</a> can be used to model the fact that every
--   <a>Integral</a> type is a subset of <a>Integer</a>.
--   
--   Embedding through the <a>Prism</a> only succeeds if the <a>Integer</a>
--   would pass through unmodified when re-extracted.
integral :: (Integral a, Integral b) => Prism Integer Integer a b

-- | <pre>
--   <a>binary</a> = <a>base</a> 2
--   </pre>
binary :: Integral a => Prism' String a

-- | <pre>
--   <a>octal</a> = <a>base</a> 8
--   </pre>
octal :: Integral a => Prism' String a

-- | <pre>
--   <a>decimal</a> = <a>base</a> 10
--   </pre>
decimal :: Integral a => Prism' String a

-- | <pre>
--   <a>hex</a> = <a>base</a> 16
--   </pre>
hex :: Integral a => Prism' String a

-- | <pre>
--   <a>adding</a> n = <a>iso</a> (+n) (subtract n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..3]^..traverse.adding 1000
--   [1001,1002,1003]
--   </pre>
adding :: Num a => a -> Iso' a a

-- | <pre>
--   <a>subtracting</a> n = <a>iso</a> (subtract n) ((+n)
--   <a>subtracting</a> n = <a>from</a> (<a>adding</a> n)
--   </pre>
subtracting :: Num a => a -> Iso' a a

-- | <pre>
--   <a>multiplying</a> n = iso (*n) (/n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; multiplying 1000 +~ 3
--   5.003
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fahrenheit = multiplying (9/5).adding 32 in 230^.from fahrenheit
--   110.0
--   </pre>
multiplying :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>dividing</a> n = <a>iso</a> (/n) (*n)
--   <a>dividing</a> n = <a>from</a> (<a>multiplying</a> n)
--   </pre>
--   
--   Note: This errors for n = 0
dividing :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>exponentiating</a> n = <a>iso</a> (**n) (**recip n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum . from (exponentiating 2)) (foldMapOf each) (3,4) == 5
--   True
--   </pre>
exponentiating :: (Floating a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>negated</a> = <a>iso</a> <a>negate</a> <a>negate</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum . negated) (foldMapOf each) (3,4) == 7
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum) (foldMapOf (each.negated)) (3,4) == -7
--   True
--   </pre>
negated :: Num a => Iso' a a


-- | <tt>Control.Exception</tt> provides an example of a large open
--   hierarchy that we can model with prisms and isomorphisms.
--   
--   Additional combinators for working with <a>IOException</a> results can
--   be found in <a>System.IO.Error.Lens</a>.
--   
--   The combinators in this module have been generalized to work with
--   <a>MonadCatch</a> instead of just <tt>IO</tt>. This enables them to be
--   used more easily in <a>Monad</a> transformer stacks.
module Control.Exception.Lens

-- | Catch exceptions that match a given <a>Prism</a> (or any <a>Fold</a>,
--   really).
--   
--   <pre>
--   &gt;&gt;&gt; catching _AssertionFailed (assert False (return "uncaught")) $ \ _ -&gt; return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>), discarding the information about the match. This is
--   particuarly useful when you have a <tt><a>Prism'</a> e ()</tt> where
--   the result of the <a>Prism</a> or <a>Fold</a> isn't particularly
--   valuable, just the fact that it matches.
--   
--   <pre>
--   &gt;&gt;&gt; catching_ _AssertionFailed (assert False (return "uncaught")) $ return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   </pre>
catching_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | A version of <a>catching</a> with the arguments swapped around; useful
--   in situations where the code for the handler is shorter.
--   
--   <pre>
--   &gt;&gt;&gt; handling _NonTermination (\_ -&gt; return "caught") $ throwIO NonTermination
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   </pre>
handling :: MonadCatch m => Getting (First a) SomeException a -> (a -> m r) -> m r -> m r

-- | A version of <a>catching_</a> with the arguments swapped around;
--   useful in situations where the code for the handler is shorter.
--   
--   <pre>
--   &gt;&gt;&gt; handling_ _NonTermination (return "caught") $ throwIO NonTermination
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   </pre>
handling_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | A variant of <a>try</a> that takes a <a>Prism</a> (or any <a>Fold</a>)
--   to select which exceptions are caught (c.f. <a>tryJust</a>,
--   <a>catchJust</a>). If the <a>Exception</a> does not match the
--   predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Either a r)

-- | A version of <a>trying</a> that discards the specific exception
--   thrown.
--   
--   <pre>
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   </pre>
trying_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Maybe r)

-- | Throw an <a>Exception</a> described by a <a>Prism</a>. Exceptions may
--   be thrown from purely functional code, but may only be caught within
--   the <tt>IO</tt> <a>Monad</a>.
--   
--   <pre>
--   <a>throwing</a> l  <a>reviews</a> l <a>throw</a>
--   </pre>
--   
--   <pre>
--   <a>throwing</a> :: <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; r
--   <a>throwing</a> :: <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; r
--   </pre>
throwing :: AReview SomeException b -> b -> r

-- | A variant of <a>throwing</a> that can only be used within the
--   <tt>IO</tt> <a>Monad</a> (or any other <a>MonadCatch</a> instance) to
--   throw an <a>Exception</a> described by a <a>Prism</a>.
--   
--   Although <a>throwingM</a> has a type that is a specialization of the
--   type of <a>throwing</a>, the two functions are subtly different:
--   
--   <pre>
--   <a>throwing</a> l e `seq` x   <a>throwing</a> e
--   <a>throwingM</a> l e `seq` x  x
--   </pre>
--   
--   The first example will cause the <a>Exception</a> <tt>e</tt> to be
--   raised, whereas the second one won't. In fact, <a>throwingM</a> will
--   only cause an <a>Exception</a> to be raised when it is used within the
--   <a>MonadCatch</a> instance. The <a>throwingM</a> variant should be
--   used in preference to <a>throwing</a> to raise an <a>Exception</a>
--   within the <a>Monad</a> because it guarantees ordering with respect to
--   other monadic operations, whereas <a>throwing</a> does not.
--   
--   <pre>
--   <a>throwingM</a> l  <a>reviews</a> l <a>throw</a>
--   </pre>
--   
--   <pre>
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; m r
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; m r
--   </pre>
throwingM :: MonadThrow m => AReview SomeException b -> b -> m r

-- | <a>throwingTo</a> raises an <a>Exception</a> specified by a
--   <a>Prism</a> in the target thread.
--   
--   <pre>
--   <a>throwingTo</a> thread l  <a>reviews</a> l (<a>throwTo</a> thread)
--   </pre>
--   
--   <pre>
--   <a>throwingTo</a> :: <a>ThreadId</a> -&gt; <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; m a
--   <a>throwingTo</a> :: <a>ThreadId</a> -&gt; <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; m a
--   </pre>
throwingTo :: MonadIO m => ThreadId -> AReview SomeException b -> b -> m ()

-- | This <a>Setter</a> can be used to purely map over the
--   <a>Exception</a>s an arbitrary expression might throw; it is a variant
--   of <a>mapException</a> in the same way that <a>mapped</a> is a variant
--   of <a>fmap</a>.
--   
--   <pre>
--   'mapException'  'over' 'mappedException'
--   </pre>
--   
--   This view that every Haskell expression can be regarded as carrying a
--   bag of <a>Exception</a>s is detailed in A Semantics for Imprecise
--   Exceptions by Peyton Jones &amp; al. at PLDI 99.
--   
--   The following maps failed assertions to arithmetic overflow:
--   
--   <pre>
--   &gt;&gt;&gt; handling _Overflow (\_ -&gt; return "caught") $ assert False (return "uncaught") &amp; mappedException %~ \ (AssertionFailed _) -&gt; Overflow
--   "caught"
--   </pre>
mappedException :: (Exception e, Exception e') => Setter s s e e'

-- | This is a type restricted version of <a>mappedException</a>, which
--   avoids the type ambiguity in the input <a>Exception</a> when using
--   <a>set</a>.
--   
--   The following maps any exception to arithmetic overflow:
--   
--   <pre>
--   &gt;&gt;&gt; handling _Overflow (\_ -&gt; return "caught") $ assert False (return "uncaught") &amp; mappedException' .~ Overflow
--   "caught"
--   </pre>
mappedException' :: Exception e' => Setter s s SomeException e'

-- | Traverse the strongly typed <a>Exception</a> contained in
--   <a>SomeException</a> where the type of your function matches the
--   desired <a>Exception</a>.
--   
--   <pre>
--   <a>exception</a> :: (<a>Applicative</a> f, <a>Exception</a> a)
--             =&gt; (a -&gt; f a) -&gt; <a>SomeException</a> -&gt; f <a>SomeException</a>
--   </pre>
exception :: Exception a => Prism' SomeException a

-- | Both <tt>exceptions</tt> and <a>Control.Exception</a> provide a
--   <a>Handler</a> type.
--   
--   This lets us write combinators to build handlers that are agnostic
--   about the choice of which of these they use.
class Handleable e (m :: * -> *) (h :: * -> *) | h -> e m where handler_ l = handler l . const
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r

-- | Exceptions that occur in the <tt>IO</tt> <a>Monad</a>. An
--   <a>IOException</a> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
--   
--   Due to their richer structure relative to other exceptions, these have
--   a more carefully overloaded signature.
class AsIOException t
_IOException :: AsIOException t => Prism' t IOException

-- | Arithmetic exceptions.
class AsArithException t
_ArithException :: AsArithException t => Prism' t ArithException

-- | Handle arithmetic <a>_Overflow</a>.
--   
--   <pre>
--   <a>_Overflow</a>  <a>_ArithException</a> <a>.</a> <a>_Overflow</a>
--   </pre>
--   
--   <pre>
--   <a>_Overflow</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_Overflow</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_Overflow :: AsArithException t => Prism' t ()

-- | Handle arithmetic <a>_Underflow</a>.
--   
--   <pre>
--   <a>_Underflow</a>  <a>_ArithException</a> <a>.</a> <a>_Underflow</a>
--   </pre>
--   
--   <pre>
--   <a>_Underflow</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_Underflow</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_Underflow :: AsArithException t => Prism' t ()

-- | Handle arithmetic loss of precision.
--   
--   <pre>
--   <a>_LossOfPrecision</a>  <a>_ArithException</a> <a>.</a> <a>_LossOfPrecision</a>
--   </pre>
--   
--   <pre>
--   <a>_LossOfPrecision</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_LossOfPrecision</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_LossOfPrecision :: AsArithException t => Prism' t ()

-- | Handle division by zero.
--   
--   <pre>
--   <a>_DivideByZero</a>  <a>_ArithException</a> <a>.</a> <a>_DivideByZero</a>
--   </pre>
--   
--   <pre>
--   <a>_DivideByZero</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_DivideByZero</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_DivideByZero :: AsArithException t => Prism' t ()

-- | Handle exceptional _Denormalized floating pure.
--   
--   <pre>
--   <a>_Denormal</a>  <a>_ArithException</a> <a>.</a> <a>_Denormal</a>
--   </pre>
--   
--   <pre>
--   <a>_Denormal</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_Denormal</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_Denormal :: AsArithException t => Prism' t ()

-- | Added in <tt>base</tt> 4.6 in response to this libraries discussion:
--   
--   
--   <a>http://haskell.1045720.n5.nabble.com/Data-Ratio-and-exceptions-td5711246.html</a>
--   
--   <pre>
--   <a>_RatioZeroDenominator</a>  <a>_ArithException</a> <a>.</a> <a>_RatioZeroDenominator</a>
--   </pre>
--   
--   <pre>
--   <a>_RatioZeroDenominator</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_RatioZeroDenominator</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_RatioZeroDenominator :: AsArithException t => Prism' t ()

-- | Exceptions generated by array operations.
class AsArrayException t
_ArrayException :: AsArrayException t => Prism' t ArrayException

-- | An attempt was made to index an array outside its declared bounds.
--   
--   <pre>
--   <a>_IndexOutOfBounds</a>  <a>_ArrayException</a> <a>.</a> <a>_IndexOutOfBounds</a>
--   </pre>
--   
--   <pre>
--   <a>_IndexOutOfBounds</a> :: <a>Prism'</a> <a>ArrayException</a> <a>String</a>
--   <a>_IndexOutOfBounds</a> :: <a>Prism'</a> <a>SomeException</a>  <a>String</a>
--   </pre>
_IndexOutOfBounds :: AsArrayException t => Prism' t String

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
--   
--   <pre>
--   <a>_UndefinedElement</a>  <a>_ArrayException</a> <a>.</a> <a>_UndefinedElement</a>
--   </pre>
--   
--   <pre>
--   <a>_UndefinedElement</a> :: <a>Prism'</a> <a>ArrayException</a> <a>String</a>
--   <a>_UndefinedElement</a> :: <a>Prism'</a> <a>SomeException</a>  <a>String</a>
--   </pre>
_UndefinedElement :: AsArrayException t => Prism' t String

-- | <a>assert</a> was applied to <a>False</a>.
class AsAssertionFailed t
_AssertionFailed :: AsAssertionFailed t => Prism' t String

-- | Asynchronous exceptions.
class AsAsyncException t
_AsyncException :: AsAsyncException t => Prism' t AsyncException

-- | The current thread's stack exceeded its limit. Since an
--   <a>Exception</a> has been raised, the thread's stack will certainly be
--   below its limit again, but the programmer should take remedial action
--   immediately.
--   
--   <pre>
--   <a>_StackOverflow</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_StackOverflow</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_StackOverflow :: AsAsyncException t => Prism' t ()

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has.
--   
--   Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this <a>Exception</a>.</li>
--   <li>GHC currently does not throw <a>HeapOverflow</a> exceptions.</li>
--   </ul>
--   
--   <pre>
--   <a>_HeapOverflow</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_HeapOverflow</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_HeapOverflow :: AsAsyncException t => Prism' t ()

-- | This <a>Exception</a> is raised by another thread calling
--   <a>killThread</a>, or by the system if it needs to terminate the
--   thread for some reason.
--   
--   <pre>
--   <a>_ThreadKilled</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_ThreadKilled</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_ThreadKilled :: AsAsyncException t => Prism' t ()

-- | This <a>Exception</a> is raised by default in the main thread of the
--   program when the user requests to terminate the program via the usual
--   mechanism(s) (<i>e.g.</i> Control-C in the console).
--   
--   <pre>
--   <a>_UserInterrupt</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_UserInterrupt</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_UserInterrupt :: AsAsyncException t => Prism' t ()

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
class AsNonTermination t
_NonTermination :: AsNonTermination t => Prism' t ()

-- | Thrown when the program attempts to call atomically, from the
--   <a>STM</a> package, inside another call to atomically.
class AsNestedAtomically t
_NestedAtomically :: AsNestedAtomically t => Prism' t ()

-- | The thread is blocked on an <a>MVar</a>, but there are no other
--   references to the <a>MVar</a> so it can't ever continue.
class AsBlockedIndefinitelyOnMVar t
_BlockedIndefinitelyOnMVar :: AsBlockedIndefinitelyOnMVar t => Prism' t ()

-- | The thread is waiting to retry an <a>STM</a> transaction, but there
--   are no other references to any TVars involved, so it can't ever
--   continue.
class AsBlockedIndefinitelyOnSTM t
_BlockedIndefinitelyOnSTM :: AsBlockedIndefinitelyOnSTM t => Prism' t ()

-- | There are no runnable threads, so the program is deadlocked. The
--   <a>Deadlock</a> <a>Exception</a> is raised in the main thread only.
class AsDeadlock t
_Deadlock :: AsDeadlock t => Prism' t ()

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called.
class AsNoMethodError t
_NoMethodError :: AsNoMethodError t => Prism' t String

-- | A pattern match failed.
class AsPatternMatchFail t
_PatternMatchFail :: AsPatternMatchFail t => Prism' t String

-- | An uninitialised record field was used.
class AsRecConError t
_RecConError :: AsRecConError t => Prism' t String

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another.
class AsRecSelError t
_RecSelError :: AsRecSelError t => Prism' t String

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another.
class AsRecUpdError t
_RecUpdError :: AsRecUpdError t => Prism' t String

-- | This is thrown when the user calls <a>error</a>.
class AsErrorCall t
_ErrorCall :: AsErrorCall t => Prism' t String

-- | This <a>Exception</a> is thrown by <tt>lens</tt> when the user somehow
--   manages to rethrow an internal <a>HandlingException</a>.
class AsHandlingException t
_HandlingException :: AsHandlingException t => Prism' t ()
instance AsHandlingException SomeException
instance AsHandlingException HandlingException
instance AsErrorCall SomeException
instance AsErrorCall ErrorCall
instance AsRecUpdError SomeException
instance AsRecUpdError RecUpdError
instance AsRecSelError SomeException
instance AsRecSelError RecSelError
instance AsRecConError SomeException
instance AsRecConError RecConError
instance AsPatternMatchFail SomeException
instance AsPatternMatchFail PatternMatchFail
instance AsNoMethodError SomeException
instance AsNoMethodError NoMethodError
instance AsDeadlock SomeException
instance AsDeadlock Deadlock
instance AsBlockedIndefinitelyOnSTM SomeException
instance AsBlockedIndefinitelyOnSTM BlockedIndefinitelyOnSTM
instance AsBlockedIndefinitelyOnMVar SomeException
instance AsBlockedIndefinitelyOnMVar BlockedIndefinitelyOnMVar
instance AsNestedAtomically SomeException
instance AsNestedAtomically NestedAtomically
instance AsNonTermination SomeException
instance AsNonTermination NonTermination
instance AsAsyncException SomeException
instance AsAsyncException AsyncException
instance AsAssertionFailed SomeException
instance AsAssertionFailed AssertionFailed
instance AsArrayException SomeException
instance AsArrayException ArrayException
instance AsArithException SomeException
instance AsArithException ArithException
instance AsIOException SomeException
instance AsIOException IOException


module Data.Dynamic.Lens

-- | Any <a>Dynamic</a> can be thrown as an <a>Exception</a>
class AsDynamic t
_Dynamic :: (AsDynamic t, Typeable a) => Prism' t a
instance AsDynamic SomeException
instance AsDynamic Dynamic


-- | These prisms can be used with the combinators in
--   <a>Control.Exception.Lens</a>.
module System.Exit.Lens

-- | Exit codes that a program can return with:
class AsExitCode p f t
_ExitCode :: AsExitCode p f t => Optic' p f t ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
--   
--   <pre>
--   <a>_ExitFailure</a> :: <a>Prism'</a> <a>ExitCode</a>      <a>Int</a>
--   <a>_ExitFailure</a> :: <a>Prism'</a> <a>SomeException</a> <a>Int</a>
--   </pre>
_ExitFailure :: (AsExitCode p f t, Choice p, Applicative f) => Optic' p f t Int

-- | indicates successful termination;
--   
--   <pre>
--   <a>_ExitSuccess</a> :: <a>Prism'</a> <a>ExitCode</a>      ()
--   <a>_ExitSuccess</a> :: <a>Prism'</a> <a>SomeException</a> ()
--   </pre>
_ExitSuccess :: (AsExitCode p f t, Choice p, Applicative f) => Optic' p f t ()
instance (Choice p, Applicative f) => AsExitCode p f SomeException
instance AsExitCode p f ExitCode
